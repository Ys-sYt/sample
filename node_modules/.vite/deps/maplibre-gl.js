import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var maplibregl = {};
      var modules = {};
      function define2(moduleName, _dependencies, moduleFactory) {
        modules[moduleName] = moduleFactory;
        if (moduleName !== "index") {
          return;
        }
        var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
        var sharedModule = {};
        modules.shared(sharedModule);
        modules.index(maplibregl, sharedModule);
        if (typeof window !== "undefined") {
          maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
        return maplibregl;
      }
      ;
      define2("shared", ["exports"], function(t) {
        "use strict";
        function e(t2, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i2, s2) {
            function a2(t3) {
              try {
                l2(n2.next(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function o2(t3) {
              try {
                l2(n2.throw(t3));
              } catch (t4) {
                s2(t4);
              }
            }
            function l2(t3) {
              var e3;
              t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                t4(e3);
              })).then(a2, o2);
            }
            l2((n2 = n2.apply(t2, e2 || [])).next());
          });
        }
        function r(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var n = i;
        function i(t2, e2) {
          this.x = t2, this.y = e2;
        }
        i.prototype = { clone: function() {
          return new i(this.x, this.y);
        }, add: function(t2) {
          return this.clone()._add(t2);
        }, sub: function(t2) {
          return this.clone()._sub(t2);
        }, multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        }, divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        }, mult: function(t2) {
          return this.clone()._mult(t2);
        }, div: function(t2) {
          return this.clone()._div(t2);
        }, rotate: function(t2) {
          return this.clone()._rotate(t2);
        }, rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        }, matMult: function(t2) {
          return this.clone()._matMult(t2);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        }, dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        }, distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        }, angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        }, angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        }, _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        }, _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        }, _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        }, _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        }, _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        }, _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }, _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        }, _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, i.convert = function(t2) {
          return t2 instanceof i ? t2 : Array.isArray(t2) ? new i(t2[0], t2[1]) : t2;
        };
        var s = r(n), a = o;
        function o(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        o.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 1e-6)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var l = r(a);
        let u, c;
        function h() {
          return null == u && (u = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u;
        }
        function p() {
          if (null == c && (c = false, h())) {
            const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
            if (e2) {
              for (let r3 = 0; r3 < t2 * t2; r3++) {
                const n2 = 4 * r3;
                e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
              }
              const r2 = e2.getImageData(0, 0, t2, t2).data;
              for (let e3 = 0; e3 < t2 * t2 * 4; e3++)
                if (e3 % 4 != 3 && r2[e3] !== e3) {
                  c = true;
                  break;
                }
            }
          }
          return c || false;
        }
        function f(t2, e2, r2, n2) {
          const i2 = new l(t2, e2, r2, n2);
          return function(t3) {
            return i2.solve(t3);
          };
        }
        const d = f(0.25, 0.1, 0.25, 1);
        function y(t2, e2, r2) {
          return Math.min(r2, Math.max(e2, t2));
        }
        function m(t2, e2, r2) {
          const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
          return i2 === e2 ? r2 : i2;
        }
        function g(t2, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        let x = 1;
        function v(t2, e2, r2) {
          const n2 = {};
          for (const i2 in t2)
            n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
          return n2;
        }
        function b(t2, e2, r2) {
          const n2 = {};
          for (const i2 in t2)
            e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
          return n2;
        }
        function w(t2) {
          return Array.isArray(t2) ? t2.map(w) : "object" == typeof t2 && t2 ? v(t2, w) : t2;
        }
        const _ = {};
        function A(t2) {
          _[t2] || ("undefined" != typeof console && console.warn(t2), _[t2] = true);
        }
        function S(t2, e2, r2) {
          return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
        }
        function k(t2) {
          let e2 = 0;
          for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
            r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        function I(t2) {
          return "undefined" != typeof WorkerGlobalScope && void 0 !== t2 && t2 instanceof WorkerGlobalScope;
        }
        let z = null;
        function M(t2) {
          return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
        }
        const B = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function C(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame)
              throw new Error("VideoFrame not supported");
            const e2 = new VideoFrame(t2, { timestamp: 0 });
            try {
              const a2 = null == e2 ? void 0 : e2.format;
              if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB"))
                throw new Error(`Unrecognized format ${a2}`);
              const o2 = a2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
              if (yield e2.copyTo(l2, function(t3, e3, r3, n3, i3) {
                const s3 = 4 * Math.max(-e3, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l3 = Math.max(0, e3), u2 = Math.max(0, r3);
                return { rect: { x: l3, y: u2, width: Math.min(t3.width, e3 + n3) - l3, height: Math.min(t3.height, r3 + i3) - u2 }, layout: [{ offset: a3, stride: o3 }] };
              }(t2, r2, n2, i2, s2)), o2)
                for (let t3 = 0; t3 < l2.length; t3 += 4) {
                  const e3 = l2[t3];
                  l2[t3] = l2[t3 + 2], l2[t3 + 2] = e3;
                }
              return l2;
            } finally {
              e2.close();
            }
          });
        }
        let P, V;
        const E = "AbortError";
        function F() {
          return new Error(E);
        }
        const T = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function $(t2) {
          return T.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
        }
        const D = "global-dispatcher";
        class L extends Error {
          constructor(t2, e2, r2, n2) {
            super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
          }
        }
        const O = () => I(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, R = function(t2, r2) {
          if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
            const e2 = $(t2.url);
            if (e2)
              return e2(t2, r2);
            if (I(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: D }, r2);
          }
          if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(O()) && !/^\w+:/.test(n2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
              return function(t3, r3) {
                return e(this, void 0, void 0, function* () {
                  const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: O(), signal: r3.signal });
                  "json" === t3.type && e2.headers.set("Accept", "application/json");
                  const n3 = yield fetch(e2);
                  if (!n3.ok) {
                    const e3 = yield n3.blob();
                    throw new L(n3.status, n3.statusText, t3.url, e3);
                  }
                  let i2;
                  i2 = "arrayBuffer" === t3.type || "image" === t3.type ? n3.arrayBuffer() : "json" === t3.type ? n3.json() : n3.text();
                  const s2 = yield i2;
                  if (r3.signal.aborted)
                    throw F();
                  return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
                });
              }(t2, r2);
            if (I(self) && self.worker && self.worker.actor)
              return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: D }, r2);
          }
          var n2;
          return function(t3, e2) {
            return new Promise((r3, n3) => {
              const i2 = new XMLHttpRequest();
              i2.open(t3.method || "GET", t3.url, true), "arrayBuffer" !== t3.type && "image" !== t3.type || (i2.responseType = "arraybuffer");
              for (const e3 in t3.headers)
                i2.setRequestHeader(e3, t3.headers[e3]);
              "json" === t3.type && (i2.responseType = "text", i2.setRequestHeader("Accept", "application/json")), i2.withCredentials = "include" === t3.credentials, i2.onerror = () => {
                n3(new Error(i2.statusText));
              }, i2.onload = () => {
                if (!e2.signal.aborted)
                  if ((i2.status >= 200 && i2.status < 300 || 0 === i2.status) && null !== i2.response) {
                    let e3 = i2.response;
                    if ("json" === t3.type)
                      try {
                        e3 = JSON.parse(i2.response);
                      } catch (t4) {
                        return void n3(t4);
                      }
                    r3({ data: e3, cacheControl: i2.getResponseHeader("Cache-Control"), expires: i2.getResponseHeader("Expires") });
                  } else {
                    const e3 = new Blob([i2.response], { type: i2.getResponseHeader("Content-Type") });
                    n3(new L(i2.status, i2.statusText, t3.url, e3));
                  }
              }, e2.signal.addEventListener("abort", () => {
                i2.abort(), n3(F());
              }), i2.send(t3.body);
            });
          }(t2, r2);
        };
        function U(t2) {
          if (!t2 || t2.indexOf("://") <= 0 || 0 === t2.indexOf("data:image/") || 0 === t2.indexOf("blob:"))
            return true;
          const e2 = new URL(t2), r2 = window.location;
          return e2.protocol === r2.protocol && e2.host === r2.host;
        }
        function j(t2, e2, r2) {
          r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
        }
        function q(t2, e2, r2) {
          if (r2 && r2[t2]) {
            const n2 = r2[t2].indexOf(e2);
            -1 !== n2 && r2[t2].splice(n2, 1);
          }
        }
        class N {
          constructor(t2, e2 = {}) {
            g(this, e2), this.type = t2;
          }
        }
        class Z extends N {
          constructor(t2, e2 = {}) {
            super("error", g({ error: t2 }, e2));
          }
        }
        class K {
          on(t2, e2) {
            return this._listeners = this._listeners || {}, j(t2, e2, this._listeners), this;
          }
          off(t2, e2) {
            return q(t2, e2, this._listeners), q(t2, e2, this._oneTimeListeners), this;
          }
          once(t2, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, j(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
          }
          fire(t2, e2) {
            "string" == typeof t2 && (t2 = new N(t2, e2 || {}));
            const r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e3)
                r3.call(this, t2);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e4 of n2)
                q(r2, e4, this._oneTimeListeners), e4.call(this, t2);
              const i2 = this._eventedParent;
              i2 && (g(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
            } else
              t2 instanceof Z && console.error(t2.error);
            return this;
          }
          listens(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }
          setEventedParent(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          }
        }
        var G = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const J = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function X(t2, e2) {
          const r2 = {};
          for (const e3 in t2)
            "ref" !== e3 && (r2[e3] = t2[e3]);
          return J.forEach((t3) => {
            t3 in e2 && (r2[t3] = e2[t3]);
          }), r2;
        }
        function H(t2, e2) {
          if (Array.isArray(t2)) {
            if (!Array.isArray(e2) || t2.length !== e2.length)
              return false;
            for (let r2 = 0; r2 < t2.length; r2++)
              if (!H(t2[r2], e2[r2]))
                return false;
            return true;
          }
          if ("object" == typeof t2 && null !== t2 && null !== e2) {
            if ("object" != typeof e2)
              return false;
            if (Object.keys(t2).length !== Object.keys(e2).length)
              return false;
            for (const r2 in t2)
              if (!H(t2[r2], e2[r2]))
                return false;
            return true;
          }
          return t2 === e2;
        }
        function Y(t2, e2) {
          t2.push(e2);
        }
        function W(t2, e2, r2) {
          Y(r2, { command: "addSource", args: [t2, e2[t2]] });
        }
        function Q(t2, e2, r2) {
          Y(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
        }
        function tt(t2, e2, r2, n2) {
          Q(t2, r2, n2), W(t2, e2, r2);
        }
        function et(t2, e2, r2) {
          let n2;
          for (n2 in t2[r2])
            if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && "data" !== n2 && !H(t2[r2][n2], e2[r2][n2]))
              return false;
          for (n2 in e2[r2])
            if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !H(t2[r2][n2], e2[r2][n2]))
              return false;
          return true;
        }
        function rt(t2, e2, r2, n2, i2, s2) {
          t2 = t2 || {}, e2 = e2 || {};
          for (const a2 in t2)
            Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
          for (const a2 in e2)
            Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        }
        function nt(t2) {
          return t2.id;
        }
        function it(t2, e2) {
          return t2[e2.id] = e2, t2;
        }
        class st {
          constructor(t2, e2, r2, n2) {
            this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function at(t2, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t2[e3] = r2[e3];
          return t2;
        }
        class ot extends Error {
          constructor(t2, e2) {
            super(e2), this.message = e2, this.key = t2;
          }
        }
        class lt {
          constructor(t2, e2 = []) {
            this.parent = t2, this.bindings = {};
            for (const [t3, r2] of e2)
              this.bindings[t3] = r2;
          }
          concat(t2) {
            return new lt(this, t2);
          }
          get(t2) {
            if (this.bindings[t2])
              return this.bindings[t2];
            if (this.parent)
              return this.parent.get(t2);
            throw new Error(`${t2} not found in scope.`);
          }
          has(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          }
        }
        const ut = { kind: "null" }, ct = { kind: "number" }, ht = { kind: "string" }, pt = { kind: "boolean" }, ft = { kind: "color" }, dt = { kind: "object" }, yt = { kind: "value" }, mt = { kind: "collator" }, gt = { kind: "formatted" }, xt = { kind: "padding" }, vt = { kind: "resolvedImage" }, bt = { kind: "variableAnchorOffsetCollection" };
        function wt(t2, e2) {
          return { kind: "array", itemType: t2, N: e2 };
        }
        function _t(t2) {
          if ("array" === t2.kind) {
            const e2 = _t(t2.itemType);
            return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t2.kind;
        }
        const At = [ut, ct, ht, pt, ft, gt, dt, wt(yt), xt, vt, bt];
        function St(t2, e2) {
          if ("error" === e2.kind)
            return null;
          if ("array" === t2.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !St(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
              return null;
          } else {
            if (t2.kind === e2.kind)
              return null;
            if ("value" === t2.kind) {
              for (const t3 of At)
                if (!St(t3, e2))
                  return null;
            }
          }
          return `Expected ${_t(t2)} but found ${_t(e2)} instead.`;
        }
        function kt(t2, e2) {
          return e2.some((e3) => e3.kind === t2.kind);
        }
        function It(t2, e2) {
          return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
        }
        function zt(t2, e2) {
          return "array" === t2.kind && "array" === e2.kind ? t2.itemType.kind === e2.itemType.kind && "number" == typeof t2.N : t2.kind === e2.kind;
        }
        const Mt = 0.96422, Bt = 0.82521, Ct = 4 / 29, Pt = 6 / 29, Vt = 3 * Pt * Pt, Et = Pt * Pt * Pt, Ft = Math.PI / 180, Tt = 180 / Math.PI;
        function $t(t2) {
          return (t2 %= 360) < 0 && (t2 += 360), t2;
        }
        function Dt([t2, e2, r2, n2]) {
          let i2, s2;
          const a2 = Ot((0.2225045 * (t2 = Lt(t2)) + 0.7168786 * (e2 = Lt(e2)) + 0.0606169 * (r2 = Lt(r2))) / 1);
          t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = Ot((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / Mt), s2 = Ot((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / Bt));
          const o2 = 116 * a2 - 16;
          return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
        }
        function Lt(t2) {
          return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
        }
        function Ot(t2) {
          return t2 > Et ? Math.pow(t2, 1 / 3) : t2 / Vt + Ct;
        }
        function Rt([t2, e2, r2, n2]) {
          let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
          return i2 = 1 * jt(i2), s2 = Mt * jt(s2), a2 = Bt * jt(a2), [Ut(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), Ut(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), Ut(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
        }
        function Ut(t2) {
          return (t2 = t2 <= 304e-5 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
        }
        function jt(t2) {
          return t2 > Pt ? t2 * t2 * t2 : Vt * (t2 - Ct);
        }
        function qt(t2) {
          return parseInt(t2.padEnd(2, t2), 16) / 255;
        }
        function Nt(t2, e2) {
          return Zt(e2 ? t2 / 100 : t2, 0, 1);
        }
        function Zt(t2, e2, r2) {
          return Math.min(Math.max(e2, t2), r2);
        }
        function Kt(t2) {
          return !t2.some(Number.isNaN);
        }
        const Gt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        class Jt {
          constructor(t2, e2, r2, n2 = 1, i2 = true) {
            this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
          }
          static parse(t2) {
            if (t2 instanceof Jt)
              return t2;
            if ("string" != typeof t2)
              return;
            const e2 = function(t3) {
              if ("transparent" === (t3 = t3.toLowerCase().trim()))
                return [0, 0, 0, 0];
              const e3 = Gt[t3];
              if (e3) {
                const [t4, r3, n2] = e3;
                return [t4 / 255, r3 / 255, n2 / 255, 1];
              }
              if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
                const e4 = t3.length < 6 ? 1 : 2;
                let r3 = 1;
                return [qt(t3.slice(r3, r3 += e4)), qt(t3.slice(r3, r3 += e4)), qt(t3.slice(r3, r3 += e4)), qt(t3.slice(r3, r3 + e4) || "ff")];
              }
              if (t3.startsWith("rgb")) {
                const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e4) {
                  const [t4, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                  if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                    const t5 = [n2, a2, u2].join(""), e5 = "%%%" === t5 ? 100 : "" === t5 ? 255 : 0;
                    if (e5) {
                      const t6 = [Zt(+r3 / e5, 0, 1), Zt(+s2 / e5, 0, 1), Zt(+l2 / e5, 0, 1), h2 ? Nt(+h2, p2) : 1];
                      if (Kt(t6))
                        return t6;
                    }
                  }
                  return;
                }
              }
              const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r2) {
                const [t4, e4, n2, i2, s2, a2, o2, l2, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
                if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
                  const t5 = [+e4, Zt(+i2, 0, 100), Zt(+a2, 0, 100), l2 ? Nt(+l2, u2) : 1];
                  if (Kt(t5))
                    return function([t6, e5, r3, n3]) {
                      function i3(n4) {
                        const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                        return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                      }
                      return t6 = $t(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                    }(t5);
                }
              }
            }(t2);
            return e2 ? new Jt(...e2, false) : void 0;
          }
          get rgb() {
            const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
            return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t2) {
              const [e2, r2, n2, i2] = Dt(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
              return [Math.round(1e4 * s2) ? $t(Math.atan2(n2, r2) * Tt) : NaN, s2, e2, i2];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Dt(this.rgb));
          }
          overwriteGetter(t2, e2) {
            return Object.defineProperty(this, t2, { value: e2 }), e2;
          }
          toString() {
            const [t2, e2, r2, n2] = this.rgb;
            return `rgba(${[t2, e2, r2].map((t3) => Math.round(255 * t3)).join(",")},${n2})`;
          }
        }
        Jt.black = new Jt(0, 0, 0, 1), Jt.white = new Jt(1, 1, 1, 1), Jt.transparent = new Jt(0, 0, 0, 0), Jt.red = new Jt(1, 0, 0, 1);
        class Xt {
          constructor(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t2, e2) {
            return this.collator.compare(t2, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Ht {
          constructor(t2, e2, r2, n2, i2) {
            this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }
        }
        class Yt {
          constructor(t2) {
            this.sections = t2;
          }
          static fromString(t2) {
            return new Yt([new Ht(t2, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
          }
          static factory(t2) {
            return t2 instanceof Yt ? t2 : Yt.fromString(t2);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
          }
        }
        class Wt {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof Wt)
              return t2;
            if ("number" == typeof t2)
              return new Wt([t2, t2, t2, t2]);
            if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
              for (const e2 of t2)
                if ("number" != typeof e2)
                  return;
              switch (t2.length) {
                case 1:
                  t2 = [t2[0], t2[0], t2[0], t2[0]];
                  break;
                case 2:
                  t2 = [t2[0], t2[1], t2[0], t2[1]];
                  break;
                case 3:
                  t2 = [t2[0], t2[1], t2[2], t2[1]];
              }
              return new Wt(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const Qt = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class te {
          constructor(t2) {
            this.values = t2.slice();
          }
          static parse(t2) {
            if (t2 instanceof te)
              return t2;
            if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
              for (let e2 = 0; e2 < t2.length; e2 += 2) {
                const r2 = t2[e2], n2 = t2[e2 + 1];
                if ("string" != typeof r2 || !Qt.has(r2))
                  return;
                if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1])
                  return;
              }
              return new te(t2);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class ee {
          constructor(t2) {
            this.name = t2.name, this.available = t2.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t2) {
            return t2 ? new ee({ name: t2, available: false }) : null;
          }
        }
        function re(t2, e2, r2, n2) {
          return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ne(t2) {
          if (null === t2 || "string" == typeof t2 || "boolean" == typeof t2 || "number" == typeof t2 || t2 instanceof Jt || t2 instanceof Xt || t2 instanceof Yt || t2 instanceof Wt || t2 instanceof te || t2 instanceof ee)
            return true;
          if (Array.isArray(t2)) {
            for (const e2 of t2)
              if (!ne(e2))
                return false;
            return true;
          }
          if ("object" == typeof t2) {
            for (const e2 in t2)
              if (!ne(t2[e2]))
                return false;
            return true;
          }
          return false;
        }
        function ie(t2) {
          if (null === t2)
            return ut;
          if ("string" == typeof t2)
            return ht;
          if ("boolean" == typeof t2)
            return pt;
          if ("number" == typeof t2)
            return ct;
          if (t2 instanceof Jt)
            return ft;
          if (t2 instanceof Xt)
            return mt;
          if (t2 instanceof Yt)
            return gt;
          if (t2 instanceof Wt)
            return xt;
          if (t2 instanceof te)
            return bt;
          if (t2 instanceof ee)
            return vt;
          if (Array.isArray(t2)) {
            const e2 = t2.length;
            let r2;
            for (const e3 of t2) {
              const t3 = ie(e3);
              if (r2) {
                if (r2 === t3)
                  continue;
                r2 = yt;
                break;
              }
              r2 = t3;
            }
            return wt(r2 || yt, e2);
          }
          return dt;
        }
        function se(t2) {
          const e2 = typeof t2;
          return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof Jt || t2 instanceof Yt || t2 instanceof Wt || t2 instanceof te || t2 instanceof ee ? t2.toString() : JSON.stringify(t2);
        }
        class ae {
          constructor(t2, e2) {
            this.type = t2, this.value = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (!ne(t2[1]))
              return e2.error("invalid value");
            const r2 = t2[1];
            let n2 = ie(r2);
            const i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new ae(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class oe {
          constructor(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          }
          toJSON() {
            return this.message;
          }
        }
        const le = { string: ht, number: ct, boolean: pt, object: dt };
        class ue {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i2 = t2[0];
            if ("array" === i2) {
              let i3, s3;
              if (t2.length > 2) {
                const r3 = t2[1];
                if ("string" != typeof r3 || !(r3 in le) || "object" === r3)
                  return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i3 = le[r3], n2++;
              } else
                i3 = yt;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                  return e2.error('The length argument to "array" must be a positive integer literal', 2);
                s3 = t2[2], n2++;
              }
              r2 = wt(i3, s3);
            } else {
              if (!le[i2])
                throw new Error(`Types doesn't contain name = ${i2}`);
              r2 = le[i2];
            }
            const s2 = [];
            for (; n2 < t2.length; n2++) {
              const r3 = e2.parse(t2[n2], n2, yt);
              if (!r3)
                return null;
              s2.push(r3);
            }
            return new ue(r2, s2);
          }
          evaluate(t2) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t2);
              if (!St(this.type, ie(r2)))
                return r2;
              if (e2 === this.args.length - 1)
                throw new oe(`Expected value to be of type ${_t(this.type)}, but found ${_t(ie(r2))} instead.`);
            }
            throw new Error();
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        const ce = { "to-boolean": pt, "to-color": ft, "to-number": ct, "to-string": ht };
        class he {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t2[0];
            if (!ce[r2])
              throw new Error(`Can't parse ${r2} as it is not part of the known types`);
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
              return e2.error("Expected one argument.");
            const n2 = ce[r2], i2 = [];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const n3 = e2.parse(t2[r3], r3, yt);
              if (!n3)
                return null;
              i2.push(n3);
            }
            return new he(n2, i2);
          }
          evaluate(t2) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t2));
              case "color": {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Jt)
                    return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : re(e2[0], e2[1], e2[2], e2[3]), !r2))
                    return new Jt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new oe(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "padding": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = Wt.parse(e2);
                  if (n2)
                    return n2;
                }
                throw new oe(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t2);
                  const n2 = te.parse(e2);
                  if (n2)
                    return n2;
                }
                throw new oe(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "number": {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new oe(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              case "formatted":
                return Yt.fromString(se(this.args[0].evaluate(t2)));
              case "resolvedImage":
                return ee.fromString(se(this.args[0].evaluate(t2)));
              default:
                return se(this.args[0].evaluate(t2));
            }
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        const pe = ["Unknown", "Point", "LineString", "Polygon"];
        class fe {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? pe[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t2) {
            let e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = Jt.parse(t2)), e2;
          }
        }
        class de {
          constructor(t2, e2, r2 = [], n2, i2 = new lt(), s2 = []) {
            this.registry = t2, this.path = r2, this.key = r2.map((t3) => `[${t3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
          }
          parse(t2, e2, r2, n2, i2 = {}) {
            return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }
          _parse(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new ue(e3, [t3]) : "coerce" === r3 ? new he(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t2[0];
              if ("string" != typeof n2)
                return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i2 = this.registry[n2];
              if (i2) {
                let n3 = i2.parse(t2, this);
                if (!n3)
                  return null;
                if (this.expectedType) {
                  const t3 = this.expectedType, i3 = n3.type;
                  if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                    if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind)
                      if ("padding" !== t3.kind || "value" !== i3.kind && "number" !== i3.kind && "array" !== i3.kind)
                        if ("variableAnchorOffsetCollection" !== t3.kind || "value" !== i3.kind && "array" !== i3.kind) {
                          if (this.checkSubtype(t3, i3))
                            return null;
                        } else
                          n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                      else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof ae) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
                  const t3 = new fe();
                  try {
                    n3 = new ae(n3.type, n3.evaluate(t3));
                  } catch (t4) {
                    return this.error(t4.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
          }
          concat(t2, e2, r2) {
            const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new de(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
          }
          error(t2, ...e2) {
            const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
            this.errors.push(new ot(r2, t2));
          }
          checkSubtype(t2, e2) {
            const r2 = St(t2, e2);
            return r2 && this.error(r2), r2;
          }
        }
        class ye {
          constructor(t2, e2, r2) {
            this.type = mt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected one argument.");
            const r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2))
              return e2.error("Collator options argument must be an object.");
            const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, pt);
            if (!n2)
              return null;
            const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, pt);
            if (!i2)
              return null;
            let s2 = null;
            return r2.locale && (s2 = e2.parse(r2.locale, 1, ht), !s2) ? null : new ye(n2, i2, s2);
          }
          evaluate(t2) {
            return new Xt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }
          eachChild(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        const me = 8192;
        function ge(t2, e2) {
          t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
        }
        function xe(t2, e2) {
          return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
        }
        function ve(t2, e2) {
          const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
          return [Math.round(r2 * i2 * me), Math.round(n2 * i2 * me)];
        }
        function be(t2, e2, r2) {
          const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
          return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
        }
        function we(t2, e2) {
          let r2 = false;
          for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
            const o3 = e2[a2];
            for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
              if (be(t2, o3[e3], o3[e3 + 1]))
                return false;
              (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
            }
          }
          var n2, i2, s2;
          return r2;
        }
        function _e(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (we(t2, e2[r2]))
              return true;
          return false;
        }
        function Ae(t2, e2, r2, n2) {
          const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
          return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function Se(t2, e2, r2) {
          for (const u2 of r2)
            for (let r3 = 0; r3 < u2.length - 1; ++r3)
              if (0 != (o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && Ae(n2, i2, s2, a2) && Ae(s2, a2, n2, i2))
                return true;
          var n2, i2, s2, a2, o2, l2;
          return false;
        }
        function ke(t2, e2) {
          for (let r2 = 0; r2 < t2.length; ++r2)
            if (!we(t2[r2], e2))
              return false;
          for (let r2 = 0; r2 < t2.length - 1; ++r2)
            if (Se(t2[r2], t2[r2 + 1], e2))
              return false;
          return true;
        }
        function Ie(t2, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (ke(t2, e2[r2]))
              return true;
          return false;
        }
        function ze(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = [];
            for (let n3 = 0; n3 < t2[i2].length; n3++) {
              const a2 = ve(t2[i2][n3], r2);
              ge(e2, a2), s2.push(a2);
            }
            n2.push(s2);
          }
          return n2;
        }
        function Me(t2, e2, r2) {
          const n2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            const s2 = ze(t2[i2], e2, r2);
            n2.push(s2);
          }
          return n2;
        }
        function Be(t2, e2, r2, n2) {
          if (t2[0] < r2[0] || t2[0] > r2[2]) {
            const e3 = 0.5 * n2;
            let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
            0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
          }
          ge(e2, t2);
        }
        function Ce(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * me, s2 = [n2.x * me, n2.y * me], a2 = [];
          for (const n3 of t2)
            for (const t3 of n3) {
              const n4 = [t3.x + s2[0], t3.y + s2[1]];
              Be(n4, e2, r2, i2), a2.push(n4);
            }
          return a2;
        }
        function Pe(t2, e2, r2, n2) {
          const i2 = Math.pow(2, n2.z) * me, s2 = [n2.x * me, n2.y * me], a2 = [];
          for (const r3 of t2) {
            const t3 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + s2[0], n3.y + s2[1]];
              ge(e2, r4), t3.push(r4);
            }
            a2.push(t3);
          }
          if (e2[2] - e2[0] <= i2 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t3 of a2)
              for (const n3 of t3)
                Be(n3, e2, r2, i2);
          }
          var o2;
          return a2;
        }
        class Ve {
          constructor(t2, e2) {
            this.type = pt, this.geojson = t2, this.geometries = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
            if (ne(t2[1])) {
              const e3 = t2[1];
              if ("FeatureCollection" === e3.type) {
                const t3 = [];
                for (const r2 of e3.features) {
                  const { type: e4, coordinates: n2 } = r2.geometry;
                  "Polygon" === e4 && t3.push(n2), "MultiPolygon" === e4 && t3.push(...n2);
                }
                if (t3.length)
                  return new Ve(e3, { type: "MultiPolygon", coordinates: t3 });
              } else if ("Feature" === e3.type) {
                const t3 = e3.geometry.type;
                if ("Polygon" === t3 || "MultiPolygon" === t3)
                  return new Ve(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
                return new Ve(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType())
                return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    const s2 = ze(e2.coordinates, n2, i2), a2 = Ce(t3.geometry(), r2, n2, i2);
                    if (!xe(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!we(t4, s2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = Me(e2.coordinates, n2, i2), a2 = Ce(t3.geometry(), r2, n2, i2);
                    if (!xe(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!_e(t4, s2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
              if ("LineString" === t2.geometryType())
                return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    const s2 = ze(e2.coordinates, n2, i2), a2 = Pe(t3.geometry(), r2, n2, i2);
                    if (!xe(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!ke(t4, s2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = Me(e2.coordinates, n2, i2), a2 = Pe(t3.geometry(), r2, n2, i2);
                    if (!xe(r2, n2))
                      return false;
                    for (const t4 of a2)
                      if (!Ie(t4, s2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Ee {
          constructor(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1])
              return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t2[1];
            return e2.scope.has(r2) ? new Ee(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t2) {
            return this.boundExpression.evaluate(t2);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Fe {
          constructor(t2, e2, r2, n2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
          }
          evaluate(t2) {
            return this._evaluate(t2, this.args);
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return false;
          }
          static parse(t2, e2) {
            const r2 = t2[0], n2 = Fe.definitions[r2];
            if (!n2)
              return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
            let o2 = null;
            for (const [n3, s3] of a2) {
              o2 = new de(e2.registry, Te, e2.path, null, e2.scope);
              const a3 = [];
              let l2 = false;
              for (let e3 = 1; e3 < t2.length; e3++) {
                const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                if (!s4) {
                  l2 = true;
                  break;
                }
                a3.push(s4);
              }
              if (!l2)
                if (Array.isArray(n3) && n3.length !== a3.length)
                  o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < a3.length; t3++) {
                    const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                    o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                  }
                  if (0 === o2.errors.length)
                    return new Fe(r2, i2, s3, a3);
                }
            }
            if (1 === a2.length)
              e2.errors.push(...o2.errors);
            else {
              const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                return e3 = t3, Array.isArray(e3) ? `(${e3.map(_t).join(", ")})` : `(${_t(e3.type)}...)`;
                var e3;
              }).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t2.length; r4++) {
                const i3 = e2.parse(t2[r4], 1 + n3.length);
                if (!i3)
                  return null;
                n3.push(_t(i3.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t2, e2) {
            Fe.definitions = e2;
            for (const r2 in e2)
              t2[r2] = Fe;
          }
        }
        function Te(t2) {
          if (t2 instanceof Ee)
            return Te(t2.boundExpression);
          if (t2 instanceof Fe && "error" === t2.name)
            return false;
          if (t2 instanceof ye)
            return false;
          if (t2 instanceof Ve)
            return false;
          const e2 = t2 instanceof he || t2 instanceof ue;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 = e2 ? r2 && Te(t3) : r2 && t3 instanceof ae;
          }), !!r2 && $e(t2) && Le(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function $e(t2) {
          if (t2 instanceof Fe) {
            if ("get" === t2.name && 1 === t2.args.length)
              return false;
            if ("feature-state" === t2.name)
              return false;
            if ("has" === t2.name && 1 === t2.args.length)
              return false;
            if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
              return false;
            if (/^filter-/.test(t2.name))
              return false;
          }
          if (t2 instanceof Ve)
            return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !$e(t3) && (e2 = false);
          }), e2;
        }
        function De(t2) {
          if (t2 instanceof Fe && "feature-state" === t2.name)
            return false;
          let e2 = true;
          return t2.eachChild((t3) => {
            e2 && !De(t3) && (e2 = false);
          }), e2;
        }
        function Le(t2, e2) {
          if (t2 instanceof Fe && e2.indexOf(t2.name) >= 0)
            return false;
          let r2 = true;
          return t2.eachChild((t3) => {
            r2 && !Le(t3, e2) && (r2 = false);
          }), r2;
        }
        function Oe(t2, e2) {
          const r2 = t2.length - 1;
          let n2, i2, s2 = 0, a2 = r2, o2 = 0;
          for (; s2 <= a2; )
            if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
              if (o2 === r2 || e2 < i2)
                return o2;
              s2 = o2 + 1;
            } else {
              if (!(n2 > e2))
                throw new oe("Input is not a number.");
              a2 = o2 - 1;
            }
          return 0;
        }
        class Re {
          constructor(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of r2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static parse(t2, e2) {
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t2[1], 1, ct);
            if (!r2)
              return null;
            const n2 = [];
            let i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (let r3 = 1; r3 < t2.length; r3 += 2) {
              const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
              if ("number" != typeof s2)
                return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= s2)
                return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(a2, l2, i2);
              if (!u2)
                return null;
              i2 = i2 || u2.type, n2.push([s2, u2]);
            }
            return new Re(i2, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            const i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Oe(e2, n2)].evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Ue(t2) {
          return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
        }
        var je = qe;
        function qe(t2, e2, r2, n2) {
          this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        qe.prototype = { sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        }, sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        }, sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        }, solveCurveX: function(t2, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 1e-6)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        }, solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        } };
        var Ne = Ue(je);
        function Ze(t2, e2, r2) {
          return t2 + r2 * (e2 - t2);
        }
        function Ke(t2, e2, r2) {
          return t2.map((t3, n2) => Ze(t3, e2[n2], r2));
        }
        const Ge = { number: Ze, color: function(t2, e2, r2, n2 = "rgb") {
          switch (n2) {
            case "rgb": {
              const [n3, i2, s2, a2] = Ke(t2.rgb, e2.rgb, r2);
              return new Jt(n3, i2, s2, a2, false);
            }
            case "hcl": {
              const [n3, i2, s2, a2] = t2.hcl, [o2, l2, u2, c2] = e2.hcl;
              let h2, p2;
              if (isNaN(n3) || isNaN(o2))
                isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, 1 !== s2 && 0 !== s2 || (p2 = l2)) : (h2 = n3, 1 !== u2 && 0 !== u2 || (p2 = i2));
              else {
                let t3 = o2 - n3;
                o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
              }
              const [f2, d2, y2, m2] = function([t3, e3, r3, n4]) {
                return t3 = isNaN(t3) ? 0 : t3 * Ft, Rt([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
              }([h2, null != p2 ? p2 : Ze(i2, l2, r2), Ze(s2, u2, r2), Ze(a2, c2, r2)]);
              return new Jt(f2, d2, y2, m2, false);
            }
            case "lab": {
              const [n3, i2, s2, a2] = Rt(Ke(t2.lab, e2.lab, r2));
              return new Jt(n3, i2, s2, a2, false);
            }
          }
        }, array: Ke, padding: function(t2, e2, r2) {
          return new Wt(Ke(t2.values, e2.values, r2));
        }, variableAnchorOffsetCollection: function(t2, e2, r2) {
          const n2 = t2.values, i2 = e2.values;
          if (n2.length !== i2.length)
            throw new oe(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
          const s2 = [];
          for (let t3 = 0; t3 < n2.length; t3 += 2) {
            if (n2[t3] !== i2[t3])
              throw new oe(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
            s2.push(n2[t3]);
            const [e3, a2] = n2[t3 + 1], [o2, l2] = i2[t3 + 1];
            s2.push([Ze(e3, o2, r2), Ze(a2, l2, r2)]);
          }
          return new te(s2);
        } };
        class Je {
          constructor(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t3, e3] of i2)
              this.labels.push(t3), this.outputs.push(e3);
          }
          static interpolationFactor(t2, e2, r2, n2) {
            let i2 = 0;
            if ("exponential" === t2.name)
              i2 = Xe(e2, t2.base, r2, n2);
            else if ("linear" === t2.name)
              i2 = Xe(e2, 1, r2, n2);
            else if ("cubic-bezier" === t2.name) {
              const s2 = t2.controlPoints;
              i2 = new Ne(s2[0], s2[1], s2[2], s2[3]).solve(Xe(e2, 1, r2, n2));
            }
            return i2;
          }
          static parse(t2, e2) {
            let [r2, n2, i2, ...s2] = t2;
            if (!Array.isArray(n2) || 0 === n2.length)
              return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0])
              n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t3 = n2[1];
              if ("number" != typeof t3)
                return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t3 };
            } else {
              if ("cubic-bezier" !== n2[0])
                return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t3 = n2.slice(1);
                if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                  return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t3 };
              }
            }
            if (t2.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            if (i2 = e2.parse(i2, 2, ct), !i2)
              return null;
            const a2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = ft : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t3 = 0; t3 < s2.length; t3 += 2) {
              const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
              if ("number" != typeof r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
              if (a2.length && a2[a2.length - 1][0] >= r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
              const u2 = e2.parse(n3, l2, o2);
              if (!u2)
                return null;
              o2 = o2 || u2.type, a2.push([r3, u2]);
            }
            return zt(o2, ct) || zt(o2, ft) || zt(o2, xt) || zt(o2, bt) || zt(o2, wt(ct)) ? new Je(o2, r2, n2, i2, a2) : e2.error(`Type ${_t(o2)} is not interpolatable.`);
          }
          evaluate(t2) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            const n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            const i2 = e2.length;
            if (n2 >= e2[i2 - 1])
              return r2[i2 - 1].evaluate(t2);
            const s2 = Oe(e2, n2), a2 = Je.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
            switch (this.operator) {
              case "interpolate":
                return Ge[this.type.kind](o2, l2, a2);
              case "interpolate-hcl":
                return Ge.color(o2, l2, a2, "hcl");
              case "interpolate-lab":
                return Ge.color(o2, l2, a2, "lab");
            }
          }
          eachChild(t2) {
            t2(this.input);
            for (const e2 of this.outputs)
              t2(e2);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined());
          }
        }
        function Xe(t2, e2, r2, n2) {
          const i2 = n2 - r2, s2 = t2 - r2;
          return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
        }
        class He {
          constructor(t2, e2) {
            this.type = t2, this.args = e2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expectected at least one argument.");
            let r2 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i2 = [];
            for (const n3 of t2.slice(1)) {
              const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t3)
                return null;
              r2 = r2 || t3.type, i2.push(t3);
            }
            if (!r2)
              throw new Error("No output type");
            const s2 = n2 && i2.some((t3) => St(n2, t3.type));
            return new He(s2 ? yt : r2, i2);
          }
          evaluate(t2) {
            let e2, r2 = null, n2 = 0;
            for (const i2 of this.args)
              if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof ee && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2)
                break;
            return r2;
          }
          eachChild(t2) {
            this.args.forEach(t2);
          }
          outputDefined() {
            return this.args.every((t2) => t2.outputDefined());
          }
        }
        class Ye {
          constructor(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          }
          evaluate(t2) {
            return this.result.evaluate(t2);
          }
          eachChild(t2) {
            for (const e2 of this.bindings)
              t2(e2[1]);
            t2(this.result);
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
            const r2 = [];
            for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
              const i2 = t2[n3];
              if ("string" != typeof i2)
                return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i2))
                return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const s2 = e2.parse(t2[n3 + 1], n3 + 1);
              if (!s2)
                return null;
              r2.push([i2, s2]);
            }
            const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return n2 ? new Ye(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class We {
          constructor(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, ct), n2 = e2.parse(t2[2], 2, wt(e2.expectedType || yt));
            return r2 && n2 ? new We(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t2) {
            const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0)
              throw new oe(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r2.length)
              throw new oe(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 !== Math.floor(e2))
              throw new oe(`Array index must be an integer, but found ${e2} instead.`);
            return r2[e2];
          }
          eachChild(t2) {
            t2(this.index), t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Qe {
          constructor(t2, e2) {
            this.type = pt, this.needle = t2, this.haystack = e2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, yt), n2 = e2.parse(t2[2], 2, yt);
            return r2 && n2 ? kt(r2.type, [pt, ht, ct, ut, yt]) ? new Qe(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`) : null;
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2)
              return false;
            if (!It(e2, ["boolean", "string", "number", "null"]))
              throw new oe(`Expected first argument to be of type boolean, string, number or null, but found ${_t(ie(e2))} instead.`);
            if (!It(r2, ["string", "array"]))
              throw new oe(`Expected second argument to be of type array or string, but found ${_t(ie(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class tr {
          constructor(t2, e2, r2) {
            this.type = ct, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, yt), n2 = e2.parse(t2[2], 2, yt);
            if (!r2 || !n2)
              return null;
            if (!kt(r2.type, [pt, ht, ct, ut, yt]))
              return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ct);
              return i2 ? new tr(r2, n2, i2) : null;
            }
            return new tr(r2, n2);
          }
          evaluate(t2) {
            const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!It(e2, ["boolean", "string", "number", "null"]))
              throw new oe(`Expected first argument to be of type boolean, string, number or null, but found ${_t(ie(e2))} instead.`);
            if (!It(r2, ["string", "array"]))
              throw new oe(`Expected second argument to be of type array or string, but found ${_t(ie(r2))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e2, n2);
            }
            return r2.indexOf(e2);
          }
          eachChild(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class er {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
          }
          static parse(t2, e2) {
            if (t2.length < 5)
              return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 1)
              return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i2 = {}, s2 = [];
            for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
              let o3 = t2[a3];
              const l2 = t2[a3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(a3);
              if (0 === o3.length)
                return u2.error("Expected at least one branch label.");
              for (const t3 of o3) {
                if ("number" != typeof t3 && "string" != typeof t3)
                  return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                  return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t3 && Math.floor(t3) !== t3)
                  return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, ie(t3)))
                    return null;
                } else
                  r2 = ie(t3);
                if (void 0 !== i2[String(t3)])
                  return u2.error("Branch labels must be unique.");
                i2[String(t3)] = s2.length;
              }
              const c2 = e2.parse(l2, a3, n2);
              if (!c2)
                return null;
              n2 = n2 || c2.type, s2.push(c2);
            }
            const a2 = e2.parse(t2[1], 1, yt);
            if (!a2)
              return null;
            const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new er(r2, n2, a2, i2, s2, o2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            return (ie(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }
          eachChild(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class rr {
          constructor(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          }
          static parse(t2, e2) {
            if (t2.length < 4)
              return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
            if (t2.length % 2 != 0)
              return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n2 = [];
            for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
              const s2 = e2.parse(t2[i3], i3, pt);
              if (!s2)
                return null;
              const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
              if (!a2)
                return null;
              n2.push([s2, a2]), r2 = r2 || a2.type;
            }
            const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            if (!i2)
              return null;
            if (!r2)
              throw new Error("Can't infer output type");
            return new rr(r2, n2, i2);
          }
          evaluate(t2) {
            for (const [e2, r2] of this.branches)
              if (e2.evaluate(t2))
                return r2.evaluate(t2);
            return this.otherwise.evaluate(t2);
          }
          eachChild(t2) {
            for (const [e2, r2] of this.branches)
              t2(e2), t2(r2);
            t2(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class nr {
          constructor(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1, yt), n2 = e2.parse(t2[2], 2, ct);
            if (!r2 || !n2)
              return null;
            if (!kt(r2.type, [wt(yt), ht, yt]))
              return e2.error(`Expected first argument to be of type array or string, but found ${_t(r2.type)} instead`);
            if (4 === t2.length) {
              const i2 = e2.parse(t2[3], 3, ct);
              return i2 ? new nr(r2.type, r2, n2, i2) : null;
            }
            return new nr(r2.type, r2, n2);
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!It(e2, ["string", "array"]))
              throw new oe(`Expected first argument to be of type array or string, but found ${_t(ie(e2))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t2);
              return e2.slice(r2, n2);
            }
            return e2.slice(r2);
          }
          eachChild(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function ir(t2, e2) {
          return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function sr(t2, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function ar(t2, e2, r2) {
          const n2 = "==" !== t2 && "!=" !== t2;
          return class i2 {
            constructor(t3, e3, r3) {
              this.type = pt, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
            }
            static parse(t3, e3) {
              if (3 !== t3.length && 4 !== t3.length)
                return e3.error("Expected two or three arguments.");
              const r3 = t3[0];
              let s2 = e3.parse(t3[1], 1, yt);
              if (!s2)
                return null;
              if (!ir(r3, s2.type))
                return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${_t(s2.type)}'.`);
              let a2 = e3.parse(t3[2], 2, yt);
              if (!a2)
                return null;
              if (!ir(r3, a2.type))
                return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${_t(a2.type)}'.`);
              if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                return e3.error(`Cannot compare types '${_t(s2.type)}' and '${_t(a2.type)}'.`);
              n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new ue(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new ue(s2.type, [a2])));
              let o2 = null;
              if (4 === t3.length) {
                if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                  return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t3[3], 3, mt), !o2)
                  return null;
              }
              return new i2(s2, a2, o2);
            }
            evaluate(i3) {
              const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
              if (n2 && this.hasUntypedArgument) {
                const e3 = ie(s2), r3 = ie(a2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                  throw new oe(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t3 = ie(s2), r3 = ie(a2);
                if ("string" !== t3.kind || "string" !== r3.kind)
                  return e2(i3, s2, a2);
              }
              return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
            }
            eachChild(t3) {
              t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const or = ar("==", function(t2, e2, r2) {
          return e2 === r2;
        }, sr), lr = ar("!=", function(t2, e2, r2) {
          return e2 !== r2;
        }, function(t2, e2, r2, n2) {
          return !sr(0, e2, r2, n2);
        }), ur = ar("<", function(t2, e2, r2) {
          return e2 < r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), cr = ar(">", function(t2, e2, r2) {
          return e2 > r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), hr = ar("<=", function(t2, e2, r2) {
          return e2 <= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), pr = ar(">=", function(t2, e2, r2) {
          return e2 >= r2;
        }, function(t2, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        });
        class fr {
          constructor(t2, e2, r2, n2, i2) {
            this.type = ht, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          }
          static parse(t2, e2) {
            if (3 !== t2.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ct);
            if (!r2)
              return null;
            const n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2))
              return e2.error("NumberFormat options argument must be an object.");
            let i2 = null;
            if (n2.locale && (i2 = e2.parse(n2.locale, 1, ht), !i2))
              return null;
            let s2 = null;
            if (n2.currency && (s2 = e2.parse(n2.currency, 1, ht), !s2))
              return null;
            let a2 = null;
            if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, ct), !a2))
              return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, ct), !o2) ? null : new fr(r2, i2, s2, a2, o2);
          }
          evaluate(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }
          eachChild(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class dr {
          constructor(t2) {
            this.type = gt, this.sections = t2;
          }
          static parse(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2)
              return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i2 = false;
            for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
              const s2 = t2[r3];
              if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                i2 = false;
                let t3 = null;
                if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, ct), !t3))
                  return null;
                let r4 = null;
                if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, wt(ht)), !r4))
                  return null;
                let a2 = null;
                if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, ft), !a2))
                  return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t3, o2.font = r4, o2.textColor = a2;
              } else {
                const s3 = e2.parse(t2[r3], 1, yt);
                if (!s3)
                  return null;
                const a2 = s3.type.kind;
                if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                  return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
              }
            }
            return new dr(n2);
          }
          evaluate(t2) {
            return new Yt(this.sections.map((e2) => {
              const r2 = e2.content.evaluate(t2);
              return ie(r2) === vt ? new Ht("", r2, null, null, null) : new Ht(se(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }
          eachChild(t2) {
            for (const e2 of this.sections)
              t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
          }
          outputDefined() {
            return false;
          }
        }
        class yr {
          constructor(t2) {
            this.type = vt, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t2[1], 1, ht);
            return r2 ? new yr(r2) : e2.error("No image name provided.");
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2), r2 = ee.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class mr {
          constructor(t2) {
            this.type = ct, this.input = t2;
          }
          static parse(t2, e2) {
            if (2 !== t2.length)
              return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
            const r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${_t(r2.type)} instead.`) : new mr(r2) : null;
          }
          evaluate(t2) {
            const e2 = this.input.evaluate(t2);
            if ("string" == typeof e2)
              return e2.length;
            if (Array.isArray(e2))
              return e2.length;
            throw new oe(`Expected value to be of type string or array, but found ${_t(ie(e2))} instead.`);
          }
          eachChild(t2) {
            t2(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const gr = { "==": or, "!=": lr, ">": cr, "<": ur, ">=": pr, "<=": hr, array: ue, at: We, boolean: ue, case: rr, coalesce: He, collator: ye, format: dr, image: yr, in: Qe, "index-of": tr, interpolate: Je, "interpolate-hcl": Je, "interpolate-lab": Je, length: mr, let: Ye, literal: ae, match: er, number: ue, "number-format": fr, object: ue, slice: nr, step: Re, string: ue, "to-boolean": he, "to-color": he, "to-number": he, "to-string": he, var: Ee, within: Ve };
        function xr(t2, [e2, r2, n2, i2]) {
          e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
          const s2 = i2 ? i2.evaluate(t2) : 1, a2 = re(e2, r2, n2, s2);
          if (a2)
            throw new oe(a2);
          return new Jt(e2 / 255, r2 / 255, n2 / 255, s2, false);
        }
        function vr(t2, e2) {
          return t2 in e2;
        }
        function br(t2, e2) {
          const r2 = e2[t2];
          return void 0 === r2 ? null : r2;
        }
        function wr(t2) {
          return { type: t2 };
        }
        function _r(t2) {
          return { result: "success", value: t2 };
        }
        function Ar(t2) {
          return { result: "error", value: t2 };
        }
        function Sr(t2) {
          return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
        }
        function kr(t2) {
          return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
        }
        function Ir(t2) {
          return !!t2.expression && t2.expression.interpolated;
        }
        function zr(t2) {
          return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
        }
        function Mr(t2) {
          return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
        }
        function Br(t2) {
          return t2;
        }
        function Cr(t2, e2) {
          const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Ir(e2) ? "exponential" : "interval");
          if (r2 || "padding" === e2.type) {
            const n3 = r2 ? Jt.parse : Wt.parse;
            (t2 = at({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e2.default);
          }
          if (t2.colorSpace && "rgb" !== (a2 = t2.colorSpace) && "hcl" !== a2 && "lab" !== a2)
            throw new Error(`Unknown color space: "${t2.colorSpace}"`);
          var a2;
          let o2, l2, u2;
          if ("exponential" === s2)
            o2 = Fr;
          else if ("interval" === s2)
            o2 = Er;
          else if ("categorical" === s2) {
            o2 = Vr, l2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t2.stops)
              l2[e3[0]] = e3[1];
            u2 = typeof t2.stops[0][0];
          } else {
            if ("identity" !== s2)
              throw new Error(`Unknown function type "${s2}"`);
            o2 = Tr;
          }
          if (n2) {
            const r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t2.stops.length; e3++) {
              const i4 = t2.stops[e3], s4 = i4[0].zoom;
              void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
            }
            const i3 = [];
            for (const t3 of n3)
              i3.push([r3[t3].zoom, Cr(r3[t3], e2)]);
            const s3 = { name: "linear" };
            return { kind: "composite", interpolationType: s3, interpolationFactor: Je.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Fr({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
          }
          if (i2) {
            const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Je.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l2, u2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
            return void 0 === i3 ? Pr(t2.default, e2.default) : o2(t2, e2, i3, l2, u2);
          } };
        }
        function Pr(t2, e2, r2) {
          return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Vr(t2, e2, r2, n2, i2) {
          return Pr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
        }
        function Er(t2, e2, r2) {
          if ("number" !== zr(r2))
            return Pr(t2.default, e2.default);
          const n2 = t2.stops.length;
          if (1 === n2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[n2 - 1][0])
            return t2.stops[n2 - 1][1];
          const i2 = Oe(t2.stops.map((t3) => t3[0]), r2);
          return t2.stops[i2][1];
        }
        function Fr(t2, e2, r2) {
          const n2 = void 0 !== t2.base ? t2.base : 1;
          if ("number" !== zr(r2))
            return Pr(t2.default, e2.default);
          const i2 = t2.stops.length;
          if (1 === i2)
            return t2.stops[0][1];
          if (r2 <= t2.stops[0][0])
            return t2.stops[0][1];
          if (r2 >= t2.stops[i2 - 1][0])
            return t2.stops[i2 - 1][1];
          const s2 = Oe(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
            const i3 = n3 - r3, s3 = t3 - r3;
            return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
          }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1], u2 = Ge[e2.type] || Br;
          return "function" == typeof o2.evaluate ? { evaluate(...e3) {
            const r3 = o2.evaluate.apply(void 0, e3), n3 = l2.evaluate.apply(void 0, e3);
            if (void 0 !== r3 && void 0 !== n3)
              return u2(r3, n3, a2, t2.colorSpace);
          } } : u2(o2, l2, a2, t2.colorSpace);
        }
        function Tr(t2, e2, r2) {
          switch (e2.type) {
            case "color":
              r2 = Jt.parse(r2);
              break;
            case "formatted":
              r2 = Yt.fromString(r2.toString());
              break;
            case "resolvedImage":
              r2 = ee.fromString(r2.toString());
              break;
            case "padding":
              r2 = Wt.parse(r2);
              break;
            default:
              zr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0);
          }
          return Pr(r2, t2.default, e2.default);
        }
        Fe.register(gr, { error: [{ kind: "error" }, [ht], (t2, [e2]) => {
          throw new oe(e2.evaluate(t2));
        }], typeof: [ht, [yt], (t2, [e2]) => _t(ie(e2.evaluate(t2)))], "to-rgba": [wt(ct, 4), [ft], (t2, [e2]) => {
          const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
          return [255 * r2, 255 * n2, 255 * i2, s2];
        }], rgb: [ft, [ct, ct, ct], xr], rgba: [ft, [ct, ct, ct, ct], xr], has: { type: pt, overloads: [[[ht], (t2, [e2]) => vr(e2.evaluate(t2), t2.properties())], [[ht, dt], (t2, [e2, r2]) => vr(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: yt, overloads: [[[ht], (t2, [e2]) => br(e2.evaluate(t2), t2.properties())], [[ht, dt], (t2, [e2, r2]) => br(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [yt, [ht], (t2, [e2]) => br(e2.evaluate(t2), t2.featureState || {})], properties: [dt, [], (t2) => t2.properties()], "geometry-type": [ht, [], (t2) => t2.geometryType()], id: [yt, [], (t2) => t2.id()], zoom: [ct, [], (t2) => t2.globals.zoom], "heatmap-density": [ct, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [ct, [], (t2) => t2.globals.lineProgress || 0], accumulated: [yt, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [ct, wr(ct), (t2, e2) => {
          let r2 = 0;
          for (const n2 of e2)
            r2 += n2.evaluate(t2);
          return r2;
        }], "*": [ct, wr(ct), (t2, e2) => {
          let r2 = 1;
          for (const n2 of e2)
            r2 *= n2.evaluate(t2);
          return r2;
        }], "-": { type: ct, overloads: [[[ct, ct], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[ct], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [ct, [ct, ct], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [ct, [ct, ct], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [ct, [], () => Math.LN2], pi: [ct, [], () => Math.PI], e: [ct, [], () => Math.E], "^": [ct, [ct, ct], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [ct, [ct], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [ct, [ct], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [ct, [ct], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [ct, [ct], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [ct, [ct], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [ct, [ct], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [ct, [ct], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [ct, [ct], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [ct, [ct], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [ct, [ct], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [ct, wr(ct), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [ct, wr(ct), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [ct, [ct], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [ct, [ct], (t2, [e2]) => {
          const r2 = e2.evaluate(t2);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [ct, [ct], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [ct, [ct], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [pt, [ht, yt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [pt, [yt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [pt, [ht], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [pt, [ht, yt], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 < i2;
        }], "filter-id-<": [pt, [yt], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [pt, [ht, yt], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 > i2;
        }], "filter-id->": [pt, [yt], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [pt, [ht, yt], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 <= i2;
        }], "filter-id-<=": [pt, [yt], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [pt, [ht, yt], (t2, [e2, r2]) => {
          const n2 = t2.properties()[e2.value], i2 = r2.value;
          return typeof n2 == typeof i2 && n2 >= i2;
        }], "filter-id->=": [pt, [yt], (t2, [e2]) => {
          const r2 = t2.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [pt, [yt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [pt, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [pt, [wt(ht)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [pt, [wt(yt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [pt, [ht, wt(yt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [pt, [ht, wt(yt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
          for (; r3 <= n2; ) {
            const i2 = r3 + n2 >> 1;
            if (e3[i2] === t3)
              return true;
            e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
          }
          return false;
        }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: pt, overloads: [[[pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [wr(pt), (t2, e2) => {
          for (const r2 of e2)
            if (!r2.evaluate(t2))
              return false;
          return true;
        }]] }, any: { type: pt, overloads: [[[pt, pt], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [wr(pt), (t2, e2) => {
          for (const r2 of e2)
            if (r2.evaluate(t2))
              return true;
          return false;
        }]] }, "!": [pt, [pt], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [pt, [ht], (t2, [e2]) => {
          const r2 = t2.globals && t2.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t2));
        }], upcase: [ht, [ht], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ht, [ht], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ht, wr(yt), (t2, e2) => e2.map((e3) => se(e3.evaluate(t2))).join("")], "resolved-locale": [ht, [mt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
        class $r {
          constructor(t2, e2) {
            var r2;
            this.expression = t2, this._warningHistory = {}, this._evaluator = new fe(), this._defaultValue = e2 ? "color" === (r2 = e2).type && Mr(r2.default) ? new Jt(0, 0, 0, 0) : "color" === r2.type ? Jt.parse(r2.default) || null : "padding" === r2.type ? Wt.parse(r2.default) || null : "variableAnchorOffsetCollection" === r2.type ? te.parse(r2.default) || null : void 0 === r2.default ? null : r2.default : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
            try {
              const t3 = this.expression.evaluate(this._evaluator);
              if (null == t3 || "number" == typeof t3 && t3 != t3)
                return this._defaultValue;
              if (this._enumValues && !(t3 in this._enumValues))
                throw new oe(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
              return t3;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          }
        }
        function Dr(t2) {
          return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in gr;
        }
        function Lr(t2, e2) {
          const r2 = new de(gr, Te, [], e2 ? function(t3) {
            const e3 = { color: ft, string: ht, number: ct, enum: ht, boolean: pt, formatted: gt, padding: xt, resolvedImage: vt, variableAnchorOffsetCollection: bt };
            return "array" === t3.type ? wt(e3[t3.value] || yt, t3.length) : e3[t3.type];
          }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? _r(new $r(n2, e2)) : Ar(r2.errors);
        }
        class Or {
          constructor(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !De(e2.expression);
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
        }
        class Rr {
          constructor(t2, e2, r2, n2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !De(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
          }
          interpolationFactor(t2, e2, r2) {
            return this.interpolationType ? Je.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          }
        }
        function Ur(t2, e2) {
          const r2 = Lr(t2, e2);
          if ("error" === r2.result)
            return r2;
          const n2 = r2.value.expression, i2 = $e(n2);
          if (!i2 && !Sr(e2))
            return Ar([new ot("", "data expressions not supported")]);
          const s2 = Le(n2, ["zoom"]);
          if (!s2 && !kr(e2))
            return Ar([new ot("", "zoom expressions not supported")]);
          const a2 = qr(n2);
          return a2 || s2 ? a2 instanceof ot ? Ar([a2]) : a2 instanceof Je && !Ir(e2) ? Ar([new ot("", '"interpolate" expressions cannot be used with this property')]) : _r(a2 ? new Rr(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Je ? a2.interpolation : void 0) : new Or(i2 ? "constant" : "source", r2.value)) : Ar([new ot("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class jr {
          constructor(t2, e2) {
            this._parameters = t2, this._specification = e2, at(this, Cr(this._parameters, this._specification));
          }
          static deserialize(t2) {
            return new jr(t2._parameters, t2._specification);
          }
          static serialize(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          }
        }
        function qr(t2) {
          let e2 = null;
          if (t2 instanceof Ye)
            e2 = qr(t2.result);
          else if (t2 instanceof He) {
            for (const r2 of t2.args)
              if (e2 = qr(r2), e2)
                break;
          } else
            (t2 instanceof Re || t2 instanceof Je) && t2.input instanceof Fe && "zoom" === t2.input.name && (e2 = t2);
          return e2 instanceof ot || t2.eachChild((t3) => {
            const r2 = qr(t3);
            r2 instanceof ot ? e2 = r2 : !e2 && r2 ? e2 = new ot("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ot("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        function Nr(t2) {
          if (true === t2 || false === t2)
            return true;
          if (!Array.isArray(t2) || 0 === t2.length)
            return false;
          switch (t2[0]) {
            case "has":
              return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
            case "in":
              return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
            case "any":
            case "all":
              for (const e2 of t2.slice(1))
                if (!Nr(e2) && "boolean" != typeof e2)
                  return false;
              return true;
            default:
              return true;
          }
        }
        const Zr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Kr(t2) {
          if (null == t2)
            return { filter: () => true, needGeometry: false };
          Nr(t2) || (t2 = Xr(t2));
          const e2 = Lr(t2, Zr);
          if ("error" === e2.result)
            throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
          return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: Jr(t2) };
        }
        function Gr(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Jr(t2) {
          if (!Array.isArray(t2))
            return false;
          if ("within" === t2[0])
            return true;
          for (let e2 = 1; e2 < t2.length; e2++)
            if (Jr(t2[e2]))
              return true;
          return false;
        }
        function Xr(t2) {
          if (!t2)
            return true;
          const e2 = t2[0];
          return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? Hr(t2[1], t2[2], "==") : "!=" === e2 ? Qr(Hr(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Hr(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(Xr))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(Xr)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(Xr).map(Qr)) : "in" === e2 ? Yr(t2[1], t2.slice(2)) : "!in" === e2 ? Qr(Yr(t2[1], t2.slice(2))) : "has" === e2 ? Wr(t2[1]) : "!has" === e2 ? Qr(Wr(t2[1])) : "within" !== e2 || t2;
          var r2;
        }
        function Hr(t2, e2, r2) {
          switch (t2) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t2, e2];
          }
        }
        function Yr(t2, e2) {
          if (0 === e2.length)
            return false;
          switch (t2) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Gr)]] : ["filter-in-small", t2, ["literal", e2]];
          }
        }
        function Wr(t2) {
          switch (t2) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t2];
          }
        }
        function Qr(t2) {
          return ["!", t2];
        }
        function tn(t2) {
          const e2 = typeof t2;
          if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t2)
            return JSON.stringify(t2);
          if (Array.isArray(t2)) {
            let e3 = "[";
            for (const r3 of t2)
              e3 += `${tn(r3)},`;
            return `${e3}]`;
          }
          const r2 = Object.keys(t2).sort();
          let n2 = "{";
          for (let e3 = 0; e3 < r2.length; e3++)
            n2 += `${JSON.stringify(r2[e3])}:${tn(t2[r2[e3]])},`;
          return `${n2}}`;
        }
        function en(t2) {
          let e2 = "";
          for (const r2 of J)
            e2 += `/${tn(t2[r2])}`;
          return e2;
        }
        function rn(t2) {
          const e2 = t2.value;
          return e2 ? [new st(t2.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function nn(t2) {
          return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
        }
        function sn(t2) {
          if (Array.isArray(t2))
            return t2.map(sn);
          if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t2)
              e2[r2] = sn(t2[r2]);
            return e2;
          }
          return nn(t2);
        }
        function an(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
          let l2 = [];
          const u2 = zr(r2);
          if ("object" !== u2)
            return [new st(e2, r2, `object expected, ${u2} found`)];
          for (const t3 in r2) {
            const u3 = t3.split(".")[0], c2 = n2[u3] || n2["*"];
            let h2;
            if (i2[u3])
              h2 = i2[u3];
            else if (n2[u3])
              h2 = o2;
            else if (i2["*"])
              h2 = i2["*"];
            else {
              if (!n2["*"]) {
                l2.push(new st(e2, r2[t3], `unknown property "${t3}"`));
                continue;
              }
              h2 = o2;
            }
            l2 = l2.concat(h2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
          }
          for (const t3 in n2)
            i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && l2.push(new st(e2, r2, `missing required property "${t3}"`));
          return l2;
        }
        function on(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || t2.validateSpec;
          if ("array" !== zr(e2))
            return [new st(s2, e2, `array expected, ${zr(e2)} found`)];
          if (r2.length && e2.length !== r2.length)
            return [new st(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new st(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
          let o2 = { type: r2.value, values: r2.values };
          i2.$version < 7 && (o2.function = r2.function), "object" === zr(r2.value) && (o2 = r2.value);
          let l2 = [];
          for (let r3 = 0; r3 < e2.length; r3++)
            l2 = l2.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
          return l2;
        }
        function ln(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
          let i2 = zr(r2);
          return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new st(e2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new st(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new st(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
        }
        function un(t2) {
          const e2 = t2.valueSpec, r2 = nn(t2.value.type);
          let n2, i2, s2, a2 = {};
          const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === zr(t2.value.stops) && "array" === zr(t2.value.stops[0]) && "object" === zr(t2.value.stops[0][0]), c2 = an({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
            if ("identity" === r2)
              return [new st(t3.key, t3.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n3 = t3.value;
            return e3 = e3.concat(on({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === zr(n3) && 0 === n3.length && e3.push(new st(t3.key, n3, "array must have at least one stop")), e3;
          }, default: function(t3) {
            return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
          } } });
          return "identity" === r2 && o2 && c2.push(new st(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new st(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Ir(t2.valueSpec) && c2.push(new st(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !Sr(t2.valueSpec) ? c2.push(new st(t2.key, t2.value, "property functions not supported")) : o2 && !kr(t2.valueSpec) && c2.push(new st(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new st(t2.key, t2.value, '"property" property is required')), c2;
          function h2(t3) {
            let r3 = [];
            const n3 = t3.value, o3 = t3.key;
            if ("array" !== zr(n3))
              return [new st(o3, n3, `array expected, ${zr(n3)} found`)];
            if (2 !== n3.length)
              return [new st(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if ("object" !== zr(n3[0]))
                return [new st(o3, n3, `object expected, ${zr(n3[0])} found`)];
              if (void 0 === n3[0].zoom)
                return [new st(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value)
                return [new st(o3, n3, "object stop key must have value")];
              if (s2 && s2 > nn(n3[0].zoom))
                return [new st(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              nn(n3[0].zoom) !== s2 && (s2 = nn(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat(an({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: ln, value: p2 } }));
            } else
              r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
            return Dr(sn(n3[1])) ? r3.concat([new st(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
          }
          function p2(t3, s3) {
            const o3 = zr(t3.value), l3 = nn(t3.value), u3 = null !== t3.value ? t3.value : s3;
            if (n2) {
              if (o3 !== n2)
                return [new st(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else
              n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
              return [new st(t3.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n3 = `number expected, ${o3} found`;
              return Sr(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new st(t3.key, u3, n3)];
            }
            return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new st(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new st(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new st(t3.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function cn(t2) {
          const e2 = ("property" === t2.expressionContext ? Ur : Lr)(sn(t2.value), t2.valueSpec);
          if ("error" === e2.result)
            return e2.value.map((e3) => new st(`${t2.key}${e3.key}`, t2.value, e3.message));
          const r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
            return [new st(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t2.expressionContext && "layout" === t2.propertyType && !De(r2))
            return [new st(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t2.expressionContext && !De(r2))
            return [new st(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
          if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
            if (!Le(r2, ["zoom", "feature-state"]))
              return [new st(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t2.expressionContext && !$e(r2))
              return [new st(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function hn(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(nn(r2)) && i2.push(new st(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(nn(r2)) && i2.push(new st(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
        }
        function pn(t2) {
          return Nr(sn(t2.value)) ? cn(at({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : fn(t2);
        }
        function fn(t2) {
          const e2 = t2.value, r2 = t2.key;
          if ("array" !== zr(e2))
            return [new st(r2, e2, `array expected, ${zr(e2)} found`)];
          const n2 = t2.styleSpec;
          let i2, s2 = [];
          if (e2.length < 1)
            return [new st(r2, e2, "filter array must have at least 1 element")];
          switch (s2 = s2.concat(hn({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), nn(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === nn(e2[1]) && s2.push(new st(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && s2.push(new st(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i2 = zr(e2[1]), "string" !== i2 && s2.push(new st(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
              for (let a2 = 2; a2 < e2.length; a2++)
                i2 = zr(e2[a2]), "$type" === nn(e2[1]) ? s2 = s2.concat(hn({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new st(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++)
                s2 = s2.concat(fn({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
              break;
            case "has":
            case "!has":
              i2 = zr(e2[1]), 2 !== e2.length ? s2.push(new st(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new st(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
              break;
            case "within":
              i2 = zr(e2[1]), 2 !== e2.length ? s2.push(new st(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i2 && s2.push(new st(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
          }
          return s2;
        }
        function dn(t2, e2) {
          const r2 = t2.key, n2 = t2.validateSpec, i2 = t2.style, s2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, l2 = s2[`${e2}_${t2.layerType}`];
          if (!l2)
            return [];
          const u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && l2[u2[1]] && l2[u2[1]].transition)
            return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
          const c2 = t2.valueSpec || l2[o2];
          if (!c2)
            return [new st(r2, a2, `unknown property "${o2}"`)];
          let h2;
          if ("string" === zr(a2) && Sr(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2)))
            return [new st(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
          const p2 = [];
          return "symbol" === t2.layerType && ("text-field" === o2 && i2 && !i2.glyphs && p2.push(new st(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Mr(sn(a2)) && "identity" === nn(a2.type) && p2.push(new st(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function yn(t2) {
          return dn(t2, "paint");
        }
        function mn(t2) {
          return dn(t2, "layout");
        }
        function gn(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
          r2.type || r2.ref || e2.push(new st(n2, r2, 'either "type" or "ref" is required'));
          let a2 = nn(r2.type);
          const o2 = nn(r2.ref);
          if (r2.id) {
            const s3 = nn(r2.id);
            for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
              const t3 = i2.layers[a3];
              nn(t3.id) === s3 && e2.push(new st(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t3;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
              t4 in r2 && e2.push(new st(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
            }), i2.layers.forEach((e3) => {
              nn(e3.id) === o2 && (t3 = e3);
            }), t3 ? t3.ref ? e2.push(new st(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = nn(t3.type) : e2.push(new st(n2, r2.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== a2)
            if (r2.source) {
              const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && nn(t3.type);
              t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new st(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster-dem" !== s3 && "hillshade" === a2 ? e2.push(new st(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new st(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new st(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e2.push(new st(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new st(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new st(n2, r2.source, `source "${r2.source}" not found`));
            } else
              e2.push(new st(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(an({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: pn, layout: (t3) => an({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => mn(at({ layerType: a2 }, t4)) } }), paint: (t3) => an({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => yn(at({ layerType: a2 }, t4)) } }) } })), e2;
        }
        function xn(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = zr(e2);
          return "string" !== n2 ? [new st(r2, e2, `string expected, ${n2} found`)] : [];
        }
        const vn = { promoteId: function({ key: t2, value: e2 }) {
          if ("string" === zr(e2))
            return xn({ key: t2, value: e2 });
          {
            const r2 = [];
            for (const n2 in e2)
              r2.push(...xn({ key: `${t2}.${n2}`, value: e2[n2] }));
            return r2;
          }
        } };
        function bn(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style, s2 = t2.validateSpec;
          if (!e2.type)
            return [new st(r2, e2, '"type" is required')];
          const a2 = nn(e2.type);
          let o2;
          switch (a2) {
            case "vector":
            case "raster":
              return o2 = an({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: vn, validateSpec: s2 }), o2;
            case "raster-dem":
              return o2 = function(t3) {
                var e3;
                const r3 = null !== (e3 = t3.sourceName) && void 0 !== e3 ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
                let o3 = [];
                const l2 = zr(n3);
                if (void 0 === n3)
                  return o3;
                if ("object" !== l2)
                  return o3.push(new st("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
                const u2 = "custom" === nn(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
                for (const e4 in n3)
                  !u2 && c2.includes(e4) ? o3.push(new st(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new st(e4, n3[e4], `unknown property "${e4}"`));
                return o3;
              }({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
            case "geojson":
              if (o2 = an({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: vn }), e2.cluster)
                for (const t3 in e2.clusterProperties) {
                  const [n3, i3] = e2.clusterProperties[t3], a3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                  o2.push(...cn({ key: `${r2}.${t3}.map`, value: i3, validateSpec: s2, expressionContext: "cluster-map" })), o2.push(...cn({ key: `${r2}.${t3}.reduce`, value: a3, validateSpec: s2, expressionContext: "cluster-reduce" }));
                }
              return o2;
            case "video":
              return an({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
            case "image":
              return an({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
            case "canvas":
              return [new st(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return hn({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, validateSpec: s2, styleSpec: n2 });
          }
        }
        function wn(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
          let s2 = [];
          const a2 = zr(e2);
          if (void 0 === e2)
            return s2;
          if ("object" !== a2)
            return s2 = s2.concat([new st("light", e2, `object expected, ${a2} found`)]), s2;
          for (const a3 in e2) {
            const o2 = a3.match(/^(.*)-transition$/);
            s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new st(a3, e2[a3], `unknown property "${a3}"`)]);
          }
          return s2;
        }
        function _n(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.sky, i2 = t2.style, s2 = zr(e2);
          if (void 0 === e2)
            return [];
          if ("object" !== s2)
            return [new st("sky", e2, `object expected, ${s2} found`)];
          let a2 = [];
          for (const t3 in e2)
            a2 = a2.concat(n2[t3] ? In({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new st(t3, e2[t3], `unknown property "${t3}"`)]);
          return a2;
        }
        function An(t2) {
          const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
          let s2 = [];
          const a2 = zr(e2);
          if (void 0 === e2)
            return s2;
          if ("object" !== a2)
            return s2 = s2.concat([new st("terrain", e2, `object expected, ${a2} found`)]), s2;
          for (const a3 in e2)
            s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new st(a3, e2[a3], `unknown property "${a3}"`)]);
          return s2;
        }
        function Sn(t2) {
          let e2 = [];
          const r2 = t2.value, n2 = t2.key;
          if (Array.isArray(r2)) {
            const i2 = [], s2 = [];
            for (const a2 in r2)
              r2[a2].id && i2.includes(r2[a2].id) && e2.push(new st(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new st(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(an({ key: `${n2}[${a2}]`, value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
            return e2;
          }
          return xn({ key: n2, value: r2 });
        }
        const kn = { "*": () => [], array: on, boolean: function(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = zr(e2);
          return "boolean" !== n2 ? [new st(r2, e2, `boolean expected, ${n2} found`)] : [];
        }, number: ln, color: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = zr(r2);
          return "string" !== n2 ? [new st(e2, r2, `color expected, ${n2} found`)] : Jt.parse(String(r2)) ? [] : [new st(e2, r2, `color expected, "${r2}" found`)];
        }, constants: rn, enum: hn, filter: pn, function: un, layer: gn, object: an, source: bn, light: wn, sky: _n, terrain: An, string: xn, formatted: function(t2) {
          return 0 === xn(t2).length ? [] : cn(t2);
        }, resolvedImage: function(t2) {
          return 0 === xn(t2).length ? [] : cn(t2);
        }, padding: function(t2) {
          const e2 = t2.key, r2 = t2.value;
          if ("array" === zr(r2)) {
            if (r2.length < 1 || r2.length > 4)
              return [new st(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
            const n2 = { type: "number" };
            let i2 = [];
            for (let s2 = 0; s2 < r2.length; s2++)
              i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
            return i2;
          }
          return ln({ key: e2, value: r2, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t2) {
          const e2 = t2.key, r2 = t2.value, n2 = zr(r2), i2 = t2.styleSpec;
          if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0)
            return [new st(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let s2 = [];
          for (let n3 = 0; n3 < r2.length; n3 += 2)
            s2 = s2.concat(hn({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(on({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
          return s2;
        }, sprite: Sn };
        function In(t2) {
          const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
          return t2.validateSpec = In, r2.expression && Mr(nn(e2)) ? un(t2) : r2.expression && Dr(sn(e2)) ? cn(t2) : r2.type && kn[r2.type] ? kn[r2.type](t2) : an(at({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function zn(t2) {
          const e2 = t2.value, r2 = t2.key, n2 = xn(t2);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new st(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new st(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function Mn(t2, e2 = G) {
          let r2 = [];
          return r2 = r2.concat(In({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: In, objectElementValidators: { glyphs: zn, "*": () => [] } })), t2.constants && (r2 = r2.concat(rn({ key: "constants", value: t2.constants, style: t2, styleSpec: e2, validateSpec: In }))), Cn(r2);
        }
        function Bn(t2) {
          return function(e2) {
            return t2({ ...e2, validateSpec: In });
          };
        }
        function Cn(t2) {
          return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
        }
        function Pn(t2) {
          return function(...e2) {
            return Cn(t2.apply(this, e2));
          };
        }
        Mn.source = Pn(Bn(bn)), Mn.sprite = Pn(Bn(Sn)), Mn.glyphs = Pn(Bn(zn)), Mn.light = Pn(Bn(wn)), Mn.sky = Pn(Bn(_n)), Mn.terrain = Pn(Bn(An)), Mn.layer = Pn(Bn(gn)), Mn.filter = Pn(Bn(pn)), Mn.paintProperty = Pn(Bn(yn)), Mn.layoutProperty = Pn(Bn(mn));
        const Vn = Mn, En = Vn.light, Fn = Vn.paintProperty, Tn = Vn.layoutProperty;
        function $n(t2, e2) {
          let r2 = false;
          if (e2 && e2.length)
            for (const n2 of e2)
              t2.fire(new Z(new Error(n2.message))), r2 = true;
          return r2;
        }
        class Dn {
          constructor(t2, e2, r2) {
            const n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              const i3 = new Int32Array(this.arrayBuffer);
              t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
              for (let t3 = 0; t3 < this.d * this.d; t3++) {
                const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
              }
              const s2 = i3[3 + n2.length + 1];
              this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (let t3 = 0; t3 < this.d * this.d; t3++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            const i2 = r2 / e2 * t2;
            this.min = -i2, this.max = t2 + i2;
          }
          insert(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t2, e2, r2, n2, i2, s2) {
            this.cells[i2].push(s2);
          }
          query(t2, e2, r2, n2, i2) {
            const s2 = this.min, a2 = this.max;
            if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            {
              const s3 = [];
              return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
            }
          }
          _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this.cells[i2];
            if (null !== l2) {
              const i3 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l2.length; c2++) {
                const h2 = l2[c2];
                if (void 0 === a2[h2]) {
                  const l3 = 4 * h2;
                  (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
                }
              }
            }
          }
          _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l2; p2 <= c2; p2++)
              for (let l3 = u2; l3 <= h2; l3++) {
                const u3 = this.d * l3 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2))
                  return;
              }
          }
          _convertFromCellCoord(t2) {
            return (t2 - this.padding) / this.scale;
          }
          _convertToCellCoord(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
            let r2 = 0;
            for (let t3 = 0; t3 < this.cells.length; t3++)
              r2 += this.cells[t3].length;
            const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i2 = e2;
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = t2[e3];
              n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
            }
            return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
          }
          static serialize(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }
          static deserialize(t2) {
            return new Dn(t2.buffer);
          }
        }
        const Ln = {};
        function On(t2, e2, r2 = {}) {
          if (Ln[t2])
            throw new Error(`${t2} is already registered.`);
          Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), Ln[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        On("Object", Object), On("TransferableGridIndex", Dn), On("Color", Jt), On("Error", Error), On("AJAXError", L), On("ResolvedImage", ee), On("StylePropertyFunction", jr), On("StyleExpression", $r, { omit: ["_evaluator"] }), On("ZoomDependentExpression", Rr), On("ZoomConstantExpression", Or), On("CompoundExpression", Fe, { omit: ["_evaluate"] });
        for (const t2 in gr)
          gr[t2]._classRegistryKey || On(`Expression_${t2}`, gr[t2]);
        function Rn(t2) {
          return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
        }
        function Un(t2, e2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error)
            return t2;
          if (Rn(t2))
            return e2 && e2.push(t2), t2;
          if (M(t2))
            return e2 && e2.push(t2), t2;
          if (ArrayBuffer.isView(t2)) {
            const r2 = t2;
            return e2 && e2.push(r2.buffer), r2;
          }
          if (t2 instanceof ImageData)
            return e2 && e2.push(t2.data.buffer), t2;
          if (Array.isArray(t2)) {
            const r2 = [];
            for (const n2 of t2)
              r2.push(Un(n2, e2));
            return r2;
          }
          if ("object" == typeof t2) {
            const r2 = t2.constructor, n2 = r2._classRegistryKey;
            if (!n2)
              throw new Error(`can't serialize object of unregistered class ${r2.name}`);
            if (!Ln[n2])
              throw new Error(`${n2} is not registered.`);
            const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
            if (r2.serialize) {
              if (e2 && i2 === e2[e2.length - 1])
                throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const r3 in t2) {
                if (!t2.hasOwnProperty(r3))
                  continue;
                if (Ln[n2].omit.indexOf(r3) >= 0)
                  continue;
                const s2 = t2[r3];
                i2[r3] = Ln[n2].shallow.indexOf(r3) >= 0 ? s2 : Un(s2, e2);
              }
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n2 && (i2.$name = n2), i2;
          }
          throw new Error("can't serialize object of type " + typeof t2);
        }
        function jn(t2) {
          if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || Rn(t2) || M(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
            return t2;
          if (Array.isArray(t2))
            return t2.map(jn);
          if ("object" == typeof t2) {
            const e2 = t2.$name || "Object";
            if (!Ln[e2])
              throw new Error(`can't deserialize unregistered class ${e2}`);
            const { klass: r2 } = Ln[e2];
            if (!r2)
              throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r2.deserialize)
              return r2.deserialize(t2);
            const n2 = Object.create(r2.prototype);
            for (const r3 of Object.keys(t2)) {
              if ("$name" === r3)
                continue;
              const i2 = t2[r3];
              n2[r3] = Ln[e2].shallow.indexOf(r3) >= 0 ? i2 : jn(i2);
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t2);
        }
        class qn {
          constructor() {
            this.first = true;
          }
          update(t2, e2) {
            const r2 = Math.floor(t2);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
          }
        }
        const Nn = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
        function Zn(t2) {
          for (const e2 of t2)
            if (Jn(e2.charCodeAt(0)))
              return true;
          return false;
        }
        function Kn(t2) {
          for (const e2 of t2)
            if (!Gn(e2.charCodeAt(0)))
              return false;
          return true;
        }
        function Gn(t2) {
          return !(Nn.Arabic(t2) || Nn["Arabic Supplement"](t2) || Nn["Arabic Extended-A"](t2) || Nn["Arabic Presentation Forms-A"](t2) || Nn["Arabic Presentation Forms-B"](t2));
        }
        function Jn(t2) {
          return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Nn["Bopomofo Extended"](t2) || Nn.Bopomofo(t2) || Nn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Nn["CJK Compatibility Ideographs"](t2) || Nn["CJK Compatibility"](t2) || Nn["CJK Radicals Supplement"](t2) || Nn["CJK Strokes"](t2) || !(!Nn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Nn["CJK Unified Ideographs Extension A"](t2) || Nn["CJK Unified Ideographs"](t2) || Nn["Enclosed CJK Letters and Months"](t2) || Nn["Hangul Compatibility Jamo"](t2) || Nn["Hangul Jamo Extended-A"](t2) || Nn["Hangul Jamo Extended-B"](t2) || Nn["Hangul Jamo"](t2) || Nn["Hangul Syllables"](t2) || Nn.Hiragana(t2) || Nn["Ideographic Description Characters"](t2) || Nn.Kanbun(t2) || Nn["Kangxi Radicals"](t2) || Nn["Katakana Phonetic Extensions"](t2) || Nn.Katakana(t2) && 12540 !== t2 || !(!Nn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Nn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Nn["Unified Canadian Aboriginal Syllabics"](t2) || Nn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Nn["Vertical Forms"](t2) || Nn["Yijing Hexagram Symbols"](t2) || Nn["Yi Syllables"](t2) || Nn["Yi Radicals"](t2))));
        }
        function Xn(t2) {
          return !(Jn(t2) || function(t3) {
            return !!(Nn["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Nn["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Nn["Letterlike Symbols"](t3) || Nn["Number Forms"](t3) || Nn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Nn["Control Pictures"](t3) && 9251 !== t3 || Nn["Optical Character Recognition"](t3) || Nn["Enclosed Alphanumerics"](t3) || Nn["Geometric Shapes"](t3) || Nn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Nn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Nn["CJK Symbols and Punctuation"](t3) || Nn.Katakana(t3) || Nn["Private Use Area"](t3) || Nn["CJK Compatibility Forms"](t3) || Nn["Small Form Variants"](t3) || Nn["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
          }(t2));
        }
        function Hn(t2) {
          return t2 >= 1424 && t2 <= 2303 || Nn["Arabic Presentation Forms-A"](t2) || Nn["Arabic Presentation Forms-B"](t2);
        }
        function Yn(t2, e2) {
          return !(!e2 && Hn(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Nn.Khmer(t2));
        }
        function Wn(t2) {
          for (const e2 of t2)
            if (Hn(e2.charCodeAt(0)))
              return true;
          return false;
        }
        const Qn = new class {
          constructor() {
            this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
          }
          setState(t2) {
            this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(t2) {
            this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText;
          }
          isParsed() {
            return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
          }
          getPluginURL() {
            return this.pluginURL;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
        }();
        class ti {
          constructor(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new qn(), this.transition = {});
          }
          isSupportedScript(t2) {
            return function(t3, e2) {
              for (const r2 of t3)
                if (!Yn(r2.charCodeAt(0), e2))
                  return false;
              return true;
            }(t2, "loaded" === Qn.getRTLTextPluginStatus());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          }
        }
        class ei {
          constructor(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if (Mr(t3))
                return new jr(t3, e3);
              if (Dr(t3)) {
                const r2 = Ur(t3, e3);
                if ("error" === r2.result)
                  throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                return r2.value;
              }
              {
                let r2 = t3;
                return "color" === e3.type && "string" == typeof t3 ? r2 = Jt.parse(t3) : "padding" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t3) && (r2 = te.parse(t3)) : r2 = Wt.parse(t3), { kind: "constant", evaluate: () => r2 };
              }
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          }
        }
        class ri {
          constructor(t2) {
            this.property = t2, this.value = new ei(t2, void 0);
          }
          transitioned(t2, e2) {
            return new ii(this.property, this.value, e2, g({}, t2.transition, this.transition), t2.now);
          }
          untransitioned() {
            return new ii(this.property, this.value, null, {}, 0);
          }
        }
        class ni {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          }
          getValue(t2) {
            return w(this._values[t2].value.value);
          }
          setValue(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ri(this._values[t2].property)), this._values[t2].value = new ei(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }
          getTransition(t2) {
            return w(this._values[t2].transition);
          }
          setTransition(t2, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ri(this._values[t2].property)), this._values[t2].transition = w(e2) || void 0;
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t2[`${e2}-transition`] = n2);
            }
            return t2;
          }
          transitioned(t2, e2) {
            const r2 = new si(this._properties);
            for (const n2 of Object.keys(this._values))
              r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            const t2 = new si(this._properties);
            for (const e2 of Object.keys(this._values))
              t2._values[e2] = this._values[e2].untransitioned();
            return t2;
          }
        }
        class ii {
          constructor(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
            if (s2) {
              if (n2 > this.end)
                return this.prior = null, i2;
              if (this.value.isDataDriven())
                return this.prior = null, i2;
              if (n2 < this.begin)
                return s2.possiblyEvaluate(t2, e2, r2);
              {
                const a2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                  if (t3 <= 0)
                    return 0;
                  if (t3 >= 1)
                    return 1;
                  const e3 = t3 * t3, r3 = e3 * t3;
                  return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
                }(a2));
              }
            }
            return i2;
          }
        }
        class si {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new li(this._properties);
            for (const i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
          hasTransition() {
            for (const t2 of Object.keys(this._values))
              if (this._values[t2].prior)
                return true;
            return false;
          }
        }
        class ai {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          }
          hasValue(t2) {
            return void 0 !== this._values[t2].value;
          }
          getValue(t2) {
            return w(this._values[t2].value);
          }
          setValue(t2, e2) {
            this._values[t2] = new ei(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }
          serialize() {
            const t2 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t2[e2] = r2);
            }
            return t2;
          }
          possiblyEvaluate(t2, e2, r2) {
            const n2 = new li(this._properties);
            for (const i2 of Object.keys(this._values))
              n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
            return n2;
          }
        }
        class oi {
          constructor(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }
          evaluate(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
          }
        }
        class li {
          constructor(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          }
          get(t2) {
            return this._values[t2];
          }
        }
        class ui {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2) {
            if (t2.isDataDriven())
              throw new Error("Value should not be data driven");
            return t2.expression.evaluate(e2);
          }
          interpolate(t2, e2, r2) {
            const n2 = Ge[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          }
        }
        class ci {
          constructor(t2, e2) {
            this.specification = t2, this.overrides = e2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return new oi(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
          }
          interpolate(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
              return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value)
              return new oi(this, { kind: "constant", value: void 0 }, t2.parameters);
            const n2 = Ge[this.specification.type];
            if (n2) {
              const i2 = n2(t2.value.value, e2.value.value, r2);
              return new oi(this, { kind: "constant", value: i2 }, t2.parameters);
            }
            return t2;
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
          }
        }
        class hi extends ci {
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 === t2.value)
              return new oi(this, { kind: "constant", value: void 0 }, e2);
            if ("constant" === t2.expression.kind) {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
              return new oi(this, { kind: "constant", value: a2 }, e2);
            }
            if ("camera" === t2.expression.kind) {
              const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new oi(this, { kind: "constant", value: r3 }, e2);
            }
            return new oi(this, t2.expression, e2);
          }
          evaluate(t2, e2, r2, n2, i2, s2) {
            if ("source" === t2.kind) {
              const a2 = t2.evaluate(e2, r2, n2, i2, s2);
              return this._calculate(a2, a2, a2, e2);
            }
            return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class pi {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            if (void 0 !== t2.value) {
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e2);
              }
              return this._calculate(t2.expression.evaluate(new ti(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new ti(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new ti(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t2) {
            return t2;
          }
        }
        class fi {
          constructor(t2) {
            this.specification = t2;
          }
          possiblyEvaluate(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class di {
          constructor(t2) {
            this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e2 in t2) {
              const r2 = t2[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              const n2 = this.defaultPropertyValues[e2] = new ei(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new ri(r2);
              this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          }
        }
        On("DataDrivenProperty", ci), On("DataConstantProperty", ui), On("CrossFadedDataDrivenProperty", hi), On("CrossFadedProperty", pi), On("ColorRampProperty", fi);
        const yi = "-transition";
        class mi extends K {
          constructor(t2, e2) {
            if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new ai(e2.layout)), e2.paint)) {
              this._transitionablePaint = new ni(e2.paint);
              for (const e3 in t2.paint)
                this.setPaintProperty(e3, t2.paint[e3], { validate: false });
              for (const e3 in t2.layout)
                this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new li(e2.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t2) {
            return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
          }
          setLayoutProperty(t2, e2, r2 = {}) {
            null != e2 && this._validate(Tn, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
          }
          getPaintProperty(t2) {
            return t2.endsWith(yi) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
          }
          setPaintProperty(t2, e2, r2 = {}) {
            if (null != e2 && this._validate(Fn, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
              return false;
            if (t2.endsWith(yi))
              return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
              this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
              const a2 = this._transitionablePaint._values[t2].value;
              return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t2) {
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return false;
          }
          isHidden(t2) {
            return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t2) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t2, e2) {
            t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
          }
          serialize() {
            const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), b(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
          }
          _validate(t2, e2, r2, n2, i2 = {}) {
            return (!i2 || false !== i2.validate) && $n(this, t2.call(Vn, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: G, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t2 in this.paint._values) {
              const e2 = this.paint.get(t2);
              if (e2 instanceof oi && Sr(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
                return true;
            }
            return false;
          }
        }
        const gi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class xi {
          constructor(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class vi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }
          static deserialize(t2) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t2) {
            this.reserve(t2), this.length = t2;
          }
          reserve(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function bi(t2, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t2.map((t3) => {
            const i2 = gi[t3.type].BYTES_PER_ELEMENT, s2 = r2 = wi(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }), size: wi(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function wi(t2, e2) {
          return Math.ceil(t2 / e2) * e2;
        }
        class _i extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
          }
        }
        _i.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", _i);
        class Ai extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
          }
        }
        Ai.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Ai);
        class Si extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
          }
        }
        Si.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Si);
        class ki extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        ki.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", ki);
        class Ii extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 4 * t2, l2 = 8 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
          }
        }
        Ii.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Ii);
        class zi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
          }
        }
        zi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", zi);
        class Mi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = 10 * t2;
            return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
          }
        }
        Mi.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Mi);
        class Bi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = 12 * t2;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
          }
        }
        Bi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Bi);
        class Ci extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        Ci.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Ci);
        class Pi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint32[1 * t2 + 0] = e2, t2;
          }
        }
        Pi.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Pi);
        class Vi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
            const c2 = 10 * t2, h2 = 5 * t2;
            return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
          }
        }
        Vi.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Vi);
        class Ei extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2) {
            const o2 = 6 * t2;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
          }
        }
        Ei.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Ei);
        class Fi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
          }
          emplace(t2, e2, r2, n2, i2, s2) {
            const a2 = 4 * t2, o2 = 8 * t2;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
          }
        }
        Fi.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Fi);
        class Ti extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 12 * t2, a2 = 3 * t2;
            return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
          }
        }
        Ti.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ti);
        class $i extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
          }
        }
        $i.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", $i);
        class Di extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
            const g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
            const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
            return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
          }
        }
        Di.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Di);
        class Li extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, z2) {
            const M2 = this.length;
            return this.resize(M2 + 1), this.emplace(M2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, z2);
          }
          emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, I2, z2, M2) {
            const B2 = 32 * t2, C2 = 16 * t2;
            return this.int16[B2 + 0] = e2, this.int16[B2 + 1] = r2, this.int16[B2 + 2] = n2, this.int16[B2 + 3] = i2, this.int16[B2 + 4] = s2, this.int16[B2 + 5] = a2, this.int16[B2 + 6] = o2, this.int16[B2 + 7] = l2, this.uint16[B2 + 8] = u2, this.uint16[B2 + 9] = c2, this.uint16[B2 + 10] = h2, this.uint16[B2 + 11] = p2, this.uint16[B2 + 12] = f2, this.uint16[B2 + 13] = d2, this.uint16[B2 + 14] = y2, this.uint16[B2 + 15] = m2, this.uint16[B2 + 16] = g2, this.uint16[B2 + 17] = x2, this.uint16[B2 + 18] = v2, this.uint16[B2 + 19] = b2, this.uint16[B2 + 20] = w2, this.uint16[B2 + 21] = _2, this.uint16[B2 + 22] = A2, this.uint32[C2 + 12] = S2, this.float32[C2 + 13] = k2, this.float32[C2 + 14] = I2, this.uint16[B2 + 30] = z2, this.uint16[B2 + 31] = M2, t2;
          }
        }
        Li.prototype.bytesPerElement = 64, On("StructArrayLayout8i15ui1ul2f2ui64", Li);
        class Oi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.float32[1 * t2 + 0] = e2, t2;
          }
        }
        Oi.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Oi);
        class Ri extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 3 * t2;
            return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
          }
        }
        Ri.prototype.bytesPerElement = 12, On("StructArrayLayout1ui2f12", Ri);
        class Ui extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
          }
          emplace(t2, e2, r2, n2) {
            const i2 = 4 * t2;
            return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
          }
        }
        Ui.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Ui);
        class ji extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t2, e2);
          }
          emplace(t2, e2, r2) {
            const n2 = 2 * t2;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
          }
        }
        ji.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", ji);
        class qi extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t2) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t2);
          }
          emplace(t2, e2) {
            return this.uint16[1 * t2 + 0] = e2, t2;
          }
        }
        qi.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", qi);
        class Ni extends vi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t2, e2, r2, n2) {
            const i2 = this.length;
            return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
          }
          emplace(t2, e2, r2, n2, i2) {
            const s2 = 4 * t2;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
          }
        }
        Ni.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Ni);
        class Zi extends xi {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new s(this.anchorPointX, this.anchorPointY);
          }
        }
        Zi.prototype.size = 20;
        class Ki extends Vi {
          get(t2) {
            return new Zi(this, t2);
          }
        }
        On("CollisionBoxArray", Ki);
        class Gi extends xi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t2) {
            this._structArray.uint8[this._pos1 + 37] = t2;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t2) {
            this._structArray.uint8[this._pos1 + 38] = t2;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 10] = t2;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        Gi.prototype.size = 48;
        class Ji extends Di {
          get(t2) {
            return new Gi(this, t2);
          }
        }
        On("PlacedSymbolArray", Ji);
        class Xi extends xi {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t2) {
            this._structArray.uint32[this._pos4 + 12] = t2;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        Xi.prototype.size = 64;
        class Hi extends Li {
          get(t2) {
            return new Xi(this, t2);
          }
        }
        On("SymbolInstanceArray", Hi);
        class Yi extends Oi {
          getoffsetX(t2) {
            return this.float32[1 * t2 + 0];
          }
        }
        On("GlyphOffsetArray", Yi);
        class Wi extends Ai {
          getx(t2) {
            return this.int16[3 * t2 + 0];
          }
          gety(t2) {
            return this.int16[3 * t2 + 1];
          }
          gettileUnitDistanceFromAnchor(t2) {
            return this.int16[3 * t2 + 2];
          }
        }
        On("SymbolLineVertexArray", Wi);
        class Qi extends xi {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Qi.prototype.size = 12;
        class ts extends Ri {
          get(t2) {
            return new Qi(this, t2);
          }
        }
        On("TextAnchorOffsetArray", ts);
        class es extends xi {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        es.prototype.size = 8;
        class rs extends Ui {
          get(t2) {
            return new es(this, t2);
          }
        }
        On("FeatureIndexArray", rs);
        class ns extends _i {
        }
        class is extends _i {
        }
        class ss extends _i {
        }
        class as extends ki {
        }
        class os extends Ii {
        }
        class ls extends zi {
        }
        class us extends Mi {
        }
        class cs extends Bi {
        }
        class hs extends Ci {
        }
        class ps extends Pi {
        }
        class fs extends Ei {
        }
        class ds extends Ti {
        }
        class ys extends $i {
        }
        class ms extends ji {
        }
        const gs = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: xs } = gs;
        class vs {
          constructor(t2 = []) {
            this.segments = t2;
          }
          prepareSegment(t2, e2, r2, n2) {
            let i2 = this.segments[this.segments.length - 1];
            return t2 > vs.MAX_VERTEX_ARRAY_LENGTH && A(`Max vertices per segment is ${vs.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > vs.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t2 of this.segments)
              for (const e2 in t2.vaos)
                t2.vaos[e2].destroy();
          }
          static simpleSegment(t2, e2, r2, n2) {
            return new vs([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function bs(t2, e2) {
          return 256 * (t2 = y(Math.floor(t2), 0, 255)) + y(Math.floor(e2), 0, 255);
        }
        vs.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", vs);
        const ws = bi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var _s = { exports: {} }, As = { exports: {} };
        As.exports = function(t2, e2) {
          var r2, n2, i2, s2, a2, o2, l2, u2;
          for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
        var Ss = As.exports, ks = { exports: {} };
        ks.exports = function(t2, e2) {
          for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
        var Is = Ss, zs = ks.exports;
        _s.exports = Is, _s.exports.murmur3 = Is, _s.exports.murmur2 = zs;
        var Ms = r(_s.exports);
        class Bs {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t2, e2, r2, n2) {
            this.ids.push(Cs(t2)), this.positions.push(e2, r2, n2);
          }
          getPositions(t2) {
            if (!this.indexed)
              throw new Error("Trying to get index, but feature positions are not indexed");
            const e2 = Cs(t2);
            let r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              const t3 = r2 + n2 >> 1;
              this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
            }
            const i2 = [];
            for (; this.ids[r2] === e2; )
              i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i2;
          }
          static serialize(t2, e2) {
            const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return Ps(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t2) {
            const e2 = new Bs();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          }
        }
        function Cs(t2) {
          const e2 = +t2;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : Ms(String(t2));
        }
        function Ps(t2, e2, r2, n2) {
          for (; r2 < n2; ) {
            const i2 = t2[r2 + n2 >> 1];
            let s2 = r2 - 1, a2 = n2 + 1;
            for (; ; ) {
              do {
                s2++;
              } while (t2[s2] < i2);
              do {
                a2--;
              } while (t2[a2] > i2);
              if (s2 >= a2)
                break;
              Vs(t2, s2, a2), Vs(e2, 3 * s2, 3 * a2), Vs(e2, 3 * s2 + 1, 3 * a2 + 1), Vs(e2, 3 * s2 + 2, 3 * a2 + 2);
            }
            a2 - r2 < n2 - a2 ? (Ps(t2, e2, r2, a2), r2 = a2 + 1) : (Ps(t2, e2, a2 + 1, n2), n2 = a2);
          }
        }
        function Vs(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        On("FeaturePositionMap", Bs);
        class Es {
          constructor(t2, e2) {
            this.gl = t2.gl, this.location = e2;
          }
        }
        class Fs extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
          }
        }
        class Ts extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
          }
        }
        class $s extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = Jt.transparent;
          }
          set(t2) {
            t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
          }
        }
        const Ds = new Float32Array(16);
        function Ls(t2) {
          return [bs(255 * t2.r, 255 * t2.g), bs(255 * t2.b, 255 * t2.a)];
        }
        class Os {
          constructor(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
          }
          setUniform(t2, e2, r2) {
            t2.set(r2.constantOr(this.value));
          }
          getBinding(t2, e2, r2) {
            return "color" === this.type ? new $s(t2, e2) : new Fs(t2, e2);
          }
        }
        class Rs {
          constructor(t2, e2) {
            this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t2, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
          }
          setUniform(t2, e2, r2, n2) {
            const i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
            i2 && t2.set(i2);
          }
          getBinding(t2, e2, r2) {
            return "u_pattern" === r2.substr(0, 9) ? new Ts(t2, e2) : new Fs(t2, e2);
          }
        }
        class Us {
          constructor(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new ti(0), e2, {}, n2, [], i2);
            this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t2, e2, i2);
          }
          _setPaintValue(t2, e2, r2) {
            if ("color" === this.type) {
              const n2 = Ls(r2);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t2; n2 < e2; n2++)
                this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class js {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
          }
          populatePaintArray(t2, e2, r2, n2, i2) {
            const s2 = this.expression.evaluate(new ti(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new ti(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
          }
          updatePaintArray(t2, e2, r2, n2) {
            const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t2, e2, i2, s2);
          }
          _setPaintValue(t2, e2, r2, n2) {
            if ("color" === this.type) {
              const i2 = Ls(r2), s2 = Ls(n2);
              for (let r3 = t2; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
            } else {
              for (let i2 = t2; i2 < e2; i2++)
                this.paintVertexArray.emplace(i2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t2, e2) {
            const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }
          getBinding(t2, e2, r2) {
            return new Fs(t2, e2);
          }
        }
        class qs {
          constructor(t2, e2, r2, n2, i2, s2) {
            this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          }
          populatePaintArray(t2, e2, r2) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t2, e2, r2, n2, i2) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
          }
          _setPaintValues(t2, e2, r2, n2) {
            if (!n2 || !r2)
              return;
            const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
            if (o2 && l2 && u2)
              for (let r3 = t2; r3 < e2; r3++)
                this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
          }
          upload(t2) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ws.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ws.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Ns {
          constructor(t2, e2, r2) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i2 in t2.paint._values) {
              if (!r2(i2))
                continue;
              const s2 = t2.paint.get(i2);
              if (!(s2 instanceof oi && Sr(s2.property.specification)))
                continue;
              const a2 = Ks(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
              if ("constant" === o2.kind)
                this.binders[i2] = h2 ? new Rs(o2.value, a2) : new Os(o2.value, a2, l2), n2.push(`/u_${i2}`);
              else if ("source" === o2.kind || h2) {
                const r3 = Gs(i2, l2, "source");
                this.binders[i2] = h2 ? new qs(o2, l2, u2, e2, r3, t2.id) : new Us(o2, a2, l2, r3), n2.push(`/a_${i2}`);
              } else {
                const t3 = Gs(i2, l2, "composite");
                this.binders[i2] = new js(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t2) {
            const e2 = this.binders[t2];
            return e2 instanceof Us || e2 instanceof js ? e2.maxValue : 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2) {
            for (const s2 in this.binders) {
              const a2 = this.binders[s2];
              (a2 instanceof Us || a2 instanceof js || a2 instanceof qs) && a2.populatePaintArray(t2, e2, r2, n2, i2);
            }
          }
          setConstantPatternPositions(t2, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof Rs && n2.setConstantPatternPositions(t2, e2);
            }
          }
          updatePaintArrays(t2, e2, r2, n2, i2) {
            let s2 = false;
            for (const a2 in t2) {
              const o2 = e2.getPositions(a2);
              for (const e3 of o2) {
                const o3 = r2.feature(e3.index);
                for (const r3 in this.binders) {
                  const l2 = this.binders[r3];
                  if ((l2 instanceof Us || l2 instanceof js || l2 instanceof qs) && true === l2.expression.isStateDependent) {
                    const u2 = n2.paint.get(r3);
                    l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                  }
                }
              }
            }
            return s2;
          }
          defines() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Os || r2 instanceof Rs) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
            }
            return t2;
          }
          getBinderAttributes() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Us || r2 instanceof js)
                for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                  t2.push(r2.paintVertexAttributes[e3].name);
              else if (r2 instanceof qs)
                for (let e3 = 0; e3 < ws.members.length; e3++)
                  t2.push(ws.members[e3].name);
            }
            return t2;
          }
          getBinderUniforms() {
            const t2 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Os || r2 instanceof Rs || r2 instanceof js)
                for (const e3 of r2.uniformNames)
                  t2.push(e3);
            }
            return t2;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t2, e2) {
            const r2 = [];
            for (const n2 in this.binders) {
              const i2 = this.binders[n2];
              if (i2 instanceof Os || i2 instanceof Rs || i2 instanceof js) {
                for (const s2 of i2.uniformNames)
                  if (e2[s2]) {
                    const a2 = i2.getBinding(t2, e2[s2], s2);
                    r2.push({ name: s2, property: n2, binding: a2 });
                  }
              }
            }
            return r2;
          }
          setUniforms(t2, e2, r2, n2) {
            for (const { name: t3, property: i2, binding: s2 } of e2)
              this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
          }
          updatePaintBuffers(t2) {
            this._buffers = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (t2 && r2 instanceof qs) {
                const e3 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else
                (r2 instanceof Us || r2 instanceof js) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t2) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Us || r2 instanceof js || r2 instanceof qs) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t2 in this.binders) {
              const e2 = this.binders[t2];
              (e2 instanceof Us || e2 instanceof js || e2 instanceof qs) && e2.destroy();
            }
          }
        }
        class Zs {
          constructor(t2, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t2)
              this.programConfigurations[n2.id] = new Ns(n2, e2, r2);
            this.needsUpload = false, this._featureMap = new Bs(), this._bufferOffset = 0;
          }
          populatePaintArrays(t2, e2, r2, n2, i2, s2) {
            for (const r3 in this.programConfigurations)
              this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }
          updatePaintArrays(t2, e2, r2, n2) {
            for (const i2 of r2)
              this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
          }
          get(t2) {
            return this.programConfigurations[t2];
          }
          upload(t2) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations)
                this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t2 in this.programConfigurations)
              this.programConfigurations[t2].destroy();
          }
        }
        function Ks(t2, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        function Gs(t2, e2, r2) {
          const n2 = { color: { source: zi, composite: Ni }, number: { source: Oi, composite: zi } }, i2 = function(t3) {
            return { "line-pattern": { source: us, composite: us }, "fill-pattern": { source: us, composite: us }, "fill-extrusion-pattern": { source: us, composite: us } }[t3];
          }(t2);
          return i2 && i2[r2] || n2[e2][r2];
        }
        On("ConstantBinder", Os), On("CrossFadedConstantBinder", Rs), On("SourceExpressionBinder", Us), On("CrossFadedCompositeBinder", qs), On("CompositeExpressionBinder", js), On("ProgramConfiguration", Ns, { omit: ["_buffers"] }), On("ProgramConfigurationSet", Zs);
        const Js = 8192, Xs = Math.pow(2, 14) - 1, Hs = -Xs - 1;
        function Ys(t2) {
          const e2 = Js / t2.extent, r2 = t2.loadGeometry();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = r2[t3];
            for (let t4 = 0; t4 < n2.length; t4++) {
              const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
              r3.x = y(i2, Hs, Xs), r3.y = y(s2, Hs, Xs), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function Ws(t2, e2) {
          return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ys(t2) : [] };
        }
        function Qs(t2, e2, r2, n2, i2) {
          t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
        }
        class ta {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new is(), this.indexArray = new ys(), this.segments = new vs(), this.programConfigurations = new Zs(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            const n2 = this.layers[0], i2 = [];
            let s2 = null, a2 = false;
            "circle" === n2.type && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
            for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ws(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), u2, r2))
                continue;
              const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ys(e3), patterns: {}, sortKey: c2 };
              i2.push(h2);
            }
            a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of i2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
              this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a3, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, xs), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t2, e2, r2, n2) {
            for (const r3 of e2)
              for (const e3 of r3) {
                const r4 = e3.x, n3 = e3.y;
                if (r4 < 0 || r4 >= Js || n3 < 0 || n3 >= Js)
                  continue;
                const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
                Qs(this.layoutVertexArray, r4, n3, -1, -1), Qs(this.layoutVertexArray, r4, n3, 1, -1), Qs(this.layoutVertexArray, r4, n3, 1, 1), Qs(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
          }
        }
        function ea(t2, e2) {
          for (let r2 = 0; r2 < t2.length; r2++)
            if (ca(e2, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (ca(t2, e2[r2]))
              return true;
          return !!sa(t2, e2);
        }
        function ra(t2, e2, r2) {
          return !!ca(t2, e2) || !!oa(e2, t2, r2);
        }
        function na(t2, e2) {
          if (1 === t2.length)
            return ua(e2, t2[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (ca(t2, n2[e3]))
                return true;
          }
          for (let r2 = 0; r2 < t2.length; r2++)
            if (ua(e2, t2[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (sa(t2, e2[r2]))
              return true;
          return false;
        }
        function ia(t2, e2, r2) {
          if (t2.length > 1) {
            if (sa(t2, e2))
              return true;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (oa(e2[n2], t2, r2))
                return true;
          }
          for (let n2 = 0; n2 < t2.length; n2++)
            if (oa(t2[n2], e2, r2))
              return true;
          return false;
        }
        function sa(t2, e2) {
          if (0 === t2.length || 0 === e2.length)
            return false;
          for (let r2 = 0; r2 < t2.length - 1; r2++) {
            const n2 = t2[r2], i2 = t2[r2 + 1];
            for (let t3 = 0; t3 < e2.length - 1; t3++)
              if (aa(n2, i2, e2[t3], e2[t3 + 1]))
                return true;
          }
          return false;
        }
        function aa(t2, e2, r2, n2) {
          return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
        }
        function oa(t2, e2, r2) {
          const n2 = r2 * r2;
          if (1 === e2.length)
            return t2.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++)
            if (la(t2, e2[r3 - 1], e2[r3]) < n2)
              return true;
          return false;
        }
        function la(t2, e2, r2) {
          const n2 = e2.distSqr(r2);
          if (0 === n2)
            return t2.distSqr(e2);
          const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
          return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
        }
        function ua(t2, e2) {
          let r2, n2, i2, s2 = false;
          for (let a2 = 0; a2 < t2.length; a2++) {
            r2 = t2[a2];
            for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
              n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
          }
          return s2;
        }
        function ca(t2, e2) {
          let r2 = false;
          for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
            const s2 = t2[n2], a2 = t2[i2];
            s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
          }
          return r2;
        }
        function ha(t2, e2, r2) {
          const n2 = r2[0], i2 = r2[2];
          if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
            return false;
          const s2 = S(t2, e2, r2[0]);
          return s2 !== S(t2, e2, r2[1]) || s2 !== S(t2, e2, r2[2]) || s2 !== S(t2, e2, r2[3]);
        }
        function pa(t2, e2, r2) {
          const n2 = e2.paint.get(t2).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
        }
        function fa(t2) {
          return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
        }
        function da(t2, e2, r2, n2, i2) {
          if (!e2[0] && !e2[1])
            return t2;
          const a2 = s.convert(e2)._mult(i2);
          "viewport" === r2 && a2._rotate(-n2);
          const o2 = [];
          for (let e3 = 0; e3 < t2.length; e3++)
            o2.push(t2[e3].sub(a2));
          return o2;
        }
        let ya, ma;
        On("CircleBucket", ta, { omit: ["layers"] });
        var ga = { get paint() {
          return ma = ma || new di({ "circle-radius": new ci(G.paint_circle["circle-radius"]), "circle-color": new ci(G.paint_circle["circle-color"]), "circle-blur": new ci(G.paint_circle["circle-blur"]), "circle-opacity": new ci(G.paint_circle["circle-opacity"]), "circle-translate": new ui(G.paint_circle["circle-translate"]), "circle-translate-anchor": new ui(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ui(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ui(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ci(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ci(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ci(G.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return ya = ya || new di({ "circle-sort-key": new ci(G.layout_circle["circle-sort-key"]) });
        } }, xa = 1e-6, va = "undefined" != typeof Float32Array ? Float32Array : Array;
        function ba(t2) {
          return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }
        function wa(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, e2 = arguments.length; e2--; )
            t2 += arguments[e2] * arguments[e2];
          return Math.sqrt(t2);
        });
        var _a, Aa = wa;
        function Sa(t2, e2, r2) {
          var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
          return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
        }
        _a = new va(4), va != Float32Array && (_a[0] = 0, _a[1] = 0, _a[2] = 0, _a[3] = 0);
        class ka extends mi {
          constructor(t2) {
            super(t2, ga);
          }
          createBucket(t2) {
            return new ta(t2);
          }
          queryRadius(t2) {
            const e2 = t2;
            return pa("circle-radius", this, e2) + pa("circle-stroke-width", this, e2) + fa(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = da(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c2 ? l2 : function(t3, e3) {
              return t3.map((t4) => Ia(t4, e3));
            }(l2, o2), p2 = c2 ? u2 * a2 : u2;
            for (const t3 of n2)
              for (const e3 of t3) {
                const t4 = c2 ? e3 : Ia(e3, o2);
                let r3 = p2;
                const n3 = Sa([], [e3.x, e3.y, 0, 1], o2);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3[3] / s2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= s2.cameraToCenterDistance / n3[3]), ra(h2, t4, r3))
                  return true;
              }
            return false;
          }
        }
        function Ia(t2, e2) {
          const r2 = Sa([], [t2.x, t2.y, 0, 1], e2);
          return new s(r2[0] / r2[3], r2[1] / r2[3]);
        }
        class za extends ta {
        }
        let Ma;
        On("HeatmapBucket", za, { omit: ["layers"] });
        var Ba = { get paint() {
          return Ma = Ma || new di({ "heatmap-radius": new ci(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ci(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ui(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new fi(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ui(G.paint_heatmap["heatmap-opacity"]) });
        } };
        function Ca(t2, { width: e2, height: r2 }, n2, i2) {
          if (i2) {
            if (i2 instanceof Uint8ClampedArray)
              i2 = new Uint8Array(i2.buffer);
            else if (i2.length !== e2 * r2 * n2)
              throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
          } else
            i2 = new Uint8Array(e2 * r2 * n2);
          return t2.width = e2, t2.height = r2, t2.data = i2, t2;
        }
        function Pa(t2, { width: e2, height: r2 }, n2) {
          if (e2 === t2.width && r2 === t2.height)
            return;
          const i2 = Ca({}, { width: e2, height: r2 }, n2);
          Va(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
        }
        function Va(t2, e2, r2, n2, i2, s2) {
          if (0 === i2.width || 0 === i2.height)
            return e2;
          if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a2 = t2.data, o2 = e2.data;
          if (a2 === o2)
            throw new Error("srcData equals dstData, so image is already copied");
          for (let l2 = 0; l2 < i2.height; l2++) {
            const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
            for (let t3 = 0; t3 < i2.width * s2; t3++)
              o2[c2 + t3] = a2[u2 + t3];
          }
          return e2;
        }
        class Ea {
          constructor(t2, e2) {
            Ca(this, t2, 1, e2);
          }
          resize(t2) {
            Pa(this, t2, 1);
          }
          clone() {
            return new Ea({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            Va(t2, e2, r2, n2, i2, 1);
          }
        }
        class Fa {
          constructor(t2, e2) {
            Ca(this, t2, 4, e2);
          }
          resize(t2) {
            Pa(this, t2, 4);
          }
          replace(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }
          clone() {
            return new Fa({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t2, e2, r2, n2, i2) {
            Va(t2, e2, r2, n2, i2, 4);
          }
        }
        function Ta(t2) {
          const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Fa({ width: r2, height: n2 });
          if (Math.log(r2) / Math.LN2 % 1 != 0)
            throw new Error(`width is not a power of 2 - ${r2}`);
          const s2 = (r3, n3, s3) => {
            e2[t2.evaluationKey] = s3;
            const a2 = t2.expression.evaluate(e2);
            i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
          };
          if (t2.clips)
            for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
              for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
                const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
                s2(i3, a2, l2 * (1 - o2) + u2 * o2);
              }
          else
            for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
              s2(0, e3, t3 / (r2 - 1));
          return i2;
        }
        On("AlphaImage", Ea), On("RGBAImage", Fa);
        class $a extends mi {
          createBucket(t2) {
            return new za(t2);
          }
          constructor(t2) {
            super(t2, Ba), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            "heatmap-color" === t2 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Ta({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Da;
        var La = { get paint() {
          return Da = Da || new di({ "hillshade-illumination-direction": new ui(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ui(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ui(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ui(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ui(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ui(G.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Oa extends mi {
          constructor(t2) {
            super(t2, La);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Ra = bi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua } = Ra;
        var ja = { exports: {} };
        function qa(t2, e2, r2) {
          r2 = r2 || 2;
          var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t2.length, p2 = Na(t2, 0, h2, r2, true), f2 = [];
          if (!p2 || p2.next === p2.prev)
            return f2;
          if (c2 && (p2 = function(t3, e3, r3, n3) {
            var i3, s3, a3, o3 = [];
            for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
              (a3 = Na(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(eo(a3));
            for (o3.sort(Ya), i3 = 0; i3 < o3.length; i3++)
              r3 = Wa(o3[i3], r3);
            return r3;
          }(t2, e2, p2, r2)), t2.length > 80 * r2) {
            n2 = s2 = t2[0], i2 = a2 = t2[1];
            for (var d2 = r2; d2 < h2; d2 += r2)
              (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
            u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 32767 / u2 : 0;
          }
          return Ka(p2, f2, r2, n2, i2, u2, 0), f2;
        }
        function Na(t2, e2, r2, n2, i2) {
          var s2, a2;
          if (i2 === yo(t2, e2, r2, n2) > 0)
            for (s2 = e2; s2 < r2; s2 += n2)
              a2 = ho(s2, t2[s2], t2[s2 + 1], a2);
          else
            for (s2 = r2 - n2; s2 >= e2; s2 -= n2)
              a2 = ho(s2, t2[s2], t2[s2 + 1], a2);
          return a2 && so(a2, a2.next) && (po(a2), a2 = a2.next), a2;
        }
        function Za(t2, e2) {
          if (!t2)
            return t2;
          e2 || (e2 = t2);
          var r2, n2 = t2;
          do {
            if (r2 = false, n2.steiner || !so(n2, n2.next) && 0 !== io(n2.prev, n2, n2.next))
              n2 = n2.next;
            else {
              if (po(n2), (n2 = e2 = n2.prev) === n2.next)
                break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function Ka(t2, e2, r2, n2, i2, s2, a2) {
          if (t2) {
            !a2 && s2 && function(t3, e3, r3, n3) {
              var i3 = t3;
              do {
                0 === i3.z && (i3.z = to(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
                do {
                  for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                    for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                      ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                      0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                    r4 = n4;
                  }
                  s3.nextZ = null, u3 *= 2;
                } while (a3 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
              if (o2 = t2.prev, l2 = t2.next, s2 ? Ja(t2, n2, i2, s2) : Ga(t2))
                e2.push(o2.i / r2 | 0), e2.push(t2.i / r2 | 0), e2.push(l2.i / r2 | 0), po(t2), t2 = l2.next, u2 = l2.next;
              else if ((t2 = l2) === u2) {
                a2 ? 1 === a2 ? Ka(t2 = Xa(Za(t2), e2, r2), e2, r2, n2, i2, s2, 2) : 2 === a2 && Ha(t2, e2, r2, n2, i2, s2) : Ka(Za(t2), e2, r2, n2, i2, s2, 1);
                break;
              }
          }
        }
        function Ga(t2) {
          var e2 = t2.prev, r2 = t2, n2 = t2.next;
          if (io(e2, r2, n2) >= 0)
            return false;
          for (var i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && ro(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && io(d2.prev, d2, d2.next) >= 0)
              return false;
            d2 = d2.next;
          }
          return true;
        }
        function Ja(t2, e2, r2, n2) {
          var i2 = t2.prev, s2 = t2, a2 = t2.next;
          if (io(i2, s2, a2) >= 0)
            return false;
          for (var o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = to(f2, d2, e2, r2, n2), x2 = to(y2, m2, e2, r2, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && ro(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && io(v2.prev, v2, v2.next) >= 0)
              return false;
            if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && ro(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && io(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && ro(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && io(v2.prev, v2, v2.next) >= 0)
              return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x2; ) {
            if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && ro(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && io(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function Xa(t2, e2, r2) {
          var n2 = t2;
          do {
            var i2 = n2.prev, s2 = n2.next.next;
            !so(i2, s2) && ao(i2, n2, n2.next, s2) && uo(i2, s2) && uo(s2, i2) && (e2.push(i2.i / r2 | 0), e2.push(n2.i / r2 | 0), e2.push(s2.i / r2 | 0), po(n2), po(n2.next), n2 = t2 = s2), n2 = n2.next;
          } while (n2 !== t2);
          return Za(n2);
        }
        function Ha(t2, e2, r2, n2, i2, s2) {
          var a2 = t2;
          do {
            for (var o2 = a2.next.next; o2 !== a2.prev; ) {
              if (a2.i !== o2.i && no(a2, o2)) {
                var l2 = co(a2, o2);
                return a2 = Za(a2, a2.next), l2 = Za(l2, l2.next), Ka(a2, e2, r2, n2, i2, s2, 0), void Ka(l2, e2, r2, n2, i2, s2, 0);
              }
              o2 = o2.next;
            }
            a2 = a2.next;
          } while (a2 !== t2);
        }
        function Ya(t2, e2) {
          return t2.x - e2.x;
        }
        function Wa(t2, e2) {
          var r2 = function(t3, e3) {
            var r3, n3 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
            do {
              if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i2 && o2 > a2 && (a2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                  return r3;
              }
              n3 = n3.next;
            } while (n3 !== e3);
            if (!r3)
              return null;
            var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
            n3 = r3;
            do {
              i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && ro(s2 < h2 ? i2 : a2, s2, c2, h2, s2 < h2 ? a2 : i2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i2 - n3.x), uo(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && Qa(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
            } while (n3 !== u2);
            return r3;
          }(t2, e2);
          if (!r2)
            return e2;
          var n2 = co(r2, t2);
          return Za(n2, n2.next), Za(r2, r2.next);
        }
        function Qa(t2, e2) {
          return io(t2.prev, t2, e2.prev) < 0 && io(e2.next, t2, t2.next) < 0;
        }
        function to(t2, e2, r2, n2, i2) {
          return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function eo(t2) {
          var e2 = t2, r2 = t2;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t2);
          return r2;
        }
        function ro(t2, e2, r2, n2, i2, s2, a2, o2) {
          return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
        }
        function no(t2, e2) {
          return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
            var r2 = t3;
            do {
              if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && ao(r2, r2.next, t3, e3))
                return true;
              r2 = r2.next;
            } while (r2 !== t3);
            return false;
          }(t2, e2) && (uo(t2, e2) && uo(e2, t2) && function(t3, e3) {
            var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
            do {
              r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t3);
            return n2;
          }(t2, e2) && (io(t2.prev, t2, e2.prev) || io(t2, e2.prev, e2)) || so(t2, e2) && io(t2.prev, t2, t2.next) > 0 && io(e2.prev, e2, e2.next) > 0);
        }
        function io(t2, e2, r2) {
          return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
        }
        function so(t2, e2) {
          return t2.x === e2.x && t2.y === e2.y;
        }
        function ao(t2, e2, r2, n2) {
          var i2 = lo(io(t2, e2, r2)), s2 = lo(io(t2, e2, n2)), a2 = lo(io(r2, n2, t2)), o2 = lo(io(r2, n2, e2));
          return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !oo(t2, r2, e2)) || !(0 !== s2 || !oo(t2, n2, e2)) || !(0 !== a2 || !oo(r2, t2, n2)) || !(0 !== o2 || !oo(r2, e2, n2));
        }
        function oo(t2, e2, r2) {
          return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
        }
        function lo(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }
        function uo(t2, e2) {
          return io(t2.prev, t2, t2.next) < 0 ? io(t2, e2, t2.next) >= 0 && io(t2, t2.prev, e2) >= 0 : io(t2, e2, t2.prev) < 0 || io(t2, t2.next, e2) < 0;
        }
        function co(t2, e2) {
          var r2 = new fo(t2.i, t2.x, t2.y), n2 = new fo(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
          return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
        }
        function ho(t2, e2, r2, n2) {
          var i2 = new fo(t2, e2, r2);
          return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
        }
        function po(t2) {
          t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
        }
        function fo(t2, e2, r2) {
          this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function yo(t2, e2, r2, n2) {
          for (var i2 = 0, s2 = e2, a2 = r2 - n2; s2 < r2; s2 += n2)
            i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
          return i2;
        }
        ja.exports = qa, ja.exports.default = qa, qa.deviation = function(t2, e2, r2, n2) {
          var i2 = e2 && e2.length, s2 = Math.abs(yo(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
          if (i2)
            for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
              s2 -= Math.abs(yo(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
          var l2 = 0;
          for (a2 = 0; a2 < n2.length; a2 += 3) {
            var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h2 = n2[a2 + 2] * r2;
            l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
          }
          return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
        }, qa.flatten = function(t2) {
          for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
            for (var s2 = 0; s2 < t2[i2].length; s2++)
              for (var a2 = 0; a2 < e2; a2++)
                r2.vertices.push(t2[i2][s2][a2]);
            i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
          }
          return r2;
        };
        var mo = r(ja.exports);
        function go(t2, e2, r2, n2, i2) {
          xo(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || bo);
        }
        function xo(t2, e2, r2, n2, i2) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
              xo(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
            }
            var c2 = t2[e2], h2 = r2, p2 = n2;
            for (vo(t2, r2, e2), i2(t2[n2], c2) > 0 && vo(t2, r2, n2); h2 < p2; ) {
              for (vo(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                h2++;
              for (; i2(t2[p2], c2) > 0; )
                p2--;
            }
            0 === i2(t2[r2], c2) ? vo(t2, r2, p2) : vo(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
          }
        }
        function vo(t2, e2, r2) {
          var n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function bo(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function wo(t2, e2) {
          const r2 = t2.length;
          if (r2 <= 1)
            return [t2];
          const n2 = [];
          let i2, s2;
          for (let e3 = 0; e3 < r2; e3++) {
            const r3 = k(t2[e3]);
            0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
          }
          if (i2 && n2.push(i2), e2 > 1)
            for (let t3 = 0; t3 < n2.length; t3++)
              n2[t3].length <= e2 || (go(n2[t3], e2, 1, n2[t3].length - 1, _o), n2[t3] = n2[t3].slice(0, e2));
          return n2;
        }
        function _o(t2, e2) {
          return e2.area - t2.area;
        }
        function Ao(t2, e2, r2) {
          const n2 = r2.patternDependencies;
          let i2 = false;
          for (const r3 of e2) {
            const e3 = r3.paint.get(`${t2}-pattern`);
            e3.isConstant() || (i2 = true);
            const s2 = e3.constantOr(null);
            s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
          }
          return i2;
        }
        function So(t2, e2, r2, n2, i2) {
          const s2 = i2.patternDependencies;
          for (const a2 of e2) {
            const e3 = a2.paint.get(`${t2}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
              t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
            }
          }
          return r2;
        }
        class ko {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new ss(), this.indexArray = new ys(), this.indexArray2 = new ms(), this.programConfigurations = new Zs(t2.layers, t2.zoom), this.segments = new vs(), this.segments2 = new vs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = Ao("fill", this.layers, e2);
            const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ws(a2, t3);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), c2, r2))
                continue;
              const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Ys(a2), patterns: {}, sortKey: h2 };
              s2.push(p2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = So("fill", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, s3, r2, {});
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ua), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            for (const t3 of wo(e2, 500)) {
              let e3 = 0;
              for (const r4 of t3)
                e3 += r4.length;
              const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
              for (const e4 of t3) {
                if (0 === e4.length)
                  continue;
                e4 !== t3[0] && s2.push(i3.length / 2);
                const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
                for (let t4 = 1; t4 < e4.length; t4++)
                  this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
                r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
              }
              const a2 = mo(i3, s2);
              for (let t4 = 0; t4 < a2.length; t4 += 3)
                this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
              r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        let Io, zo;
        On("FillBucket", ko, { omit: ["layers", "patternFeatures"] });
        var Mo = { get paint() {
          return zo = zo || new di({ "fill-antialias": new ui(G.paint_fill["fill-antialias"]), "fill-opacity": new ci(G.paint_fill["fill-opacity"]), "fill-color": new ci(G.paint_fill["fill-color"]), "fill-outline-color": new ci(G.paint_fill["fill-outline-color"]), "fill-translate": new ui(G.paint_fill["fill-translate"]), "fill-translate-anchor": new ui(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new hi(G.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Io = Io || new di({ "fill-sort-key": new ci(G.layout_fill["fill-sort-key"]) });
        } };
        class Bo extends mi {
          constructor(t2) {
            super(t2, Mo);
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t2) {
            return new ko(t2);
          }
          queryRadius() {
            return fa(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
            return na(da(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
          }
          isTileClipped() {
            return true;
          }
        }
        const Co = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Po = bi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Vo } = Co;
        var Eo = {}, Fo = n, To = $o;
        function $o(t2, e2, r2, n2, i2) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Do, this, e2);
        }
        function Do(t2, e2, r2) {
          1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
            for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
              e3.properties[n2] = i2;
            }
          }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
        }
        function Lo(t2) {
          for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
            n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
          return n2;
        }
        $o.types = ["Unknown", "Point", "LineString", "Polygon"], $o.prototype.loadGeometry = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
            if (i2 <= 0) {
              var l2 = t2.readVarint();
              n2 = 7 & l2, i2 = l2 >> 3;
            }
            if (i2--, 1 === n2 || 2 === n2)
              s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e2 && o2.push(e2), e2 = []), e2.push(new Fo(s2, a2));
            else {
              if (7 !== n2)
                throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, $o.prototype.bbox = function() {
          var t2 = this._pbf;
          t2.pos = this._geometry;
          for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
            if (n2 <= 0) {
              var c2 = t2.readVarint();
              r2 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2)
              (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [a2, l2, o2, u2];
        }, $o.prototype.toGeoJSON = function(t2, e2, r2) {
          var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = $o.types[this.type];
          function c2(t3) {
            for (var e3 = 0; e3 < t3.length; e3++) {
              var r3 = t3[e3];
              t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l2.length; n2++)
                h2[n2] = l2[n2][0];
              c2(l2 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++)
                c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t3) {
                var e3 = t3.length;
                if (e3 <= 1)
                  return [t3];
                for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                  var a3 = Lo(t3[s3]);
                  0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
                }
                return r3 && i3.push(r3), i3;
              }(l2), n2 = 0; n2 < l2.length; n2++)
                for (i2 = 0; i2 < l2[n2].length; i2++)
                  c2(l2[n2][i2]);
          }
          1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var Oo = To, Ro = Uo;
        function Uo(t2, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(jo, this, e2), this.length = this._features.length;
        }
        function jo(t2, e2, r2) {
          15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
            for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
              var n2 = t3.readVarint() >> 3;
              e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        Uo.prototype.feature = function(t2) {
          if (t2 < 0 || t2 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t2];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new Oo(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var qo = Ro;
        function No(t2, e2, r2) {
          if (3 === t2) {
            var n2 = new qo(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        Eo.VectorTile = function(t2, e2) {
          this.layers = t2.readFields(No, {}, e2);
        }, Eo.VectorTileFeature = To, Eo.VectorTileLayer = Ro;
        const Zo = Eo.VectorTileFeature.types, Ko = Math.pow(2, 13);
        function Go(t2, e2, r2, n2, i2, s2, a2, o2) {
          t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Ko) + a2, i2 * Ko * 2, s2 * Ko * 2, Math.round(o2));
        }
        class Jo {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new as(), this.centroidVertexArray = new ns(), this.indexArray = new ys(), this.programConfigurations = new Zs(t2.layers, t2.zoom), this.segments = new vs(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.features = [], this.hasPattern = Ao("fill-extrusion", this.layers, e2);
            for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ws(n2, t3);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), o2, r2))
                continue;
              const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Ys(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasPattern ? this.features.push(So("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
            }
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.features) {
              const { geometry: n2 } = t3;
              this.addFeature(t3, n2, t3.index, e2, r2);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Vo), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Po.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t2, e2, r2, n2, i2) {
            const s2 = { x: 0, y: 0, vertexCount: 0 };
            for (const r3 of wo(e2, 500)) {
              let e3 = 0;
              for (const t3 of r3)
                e3 += t3.length;
              let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t3 of r3) {
                if (0 === t3.length)
                  continue;
                if (Ho(t3))
                  continue;
                let e4 = 0;
                for (let r4 = 0; r4 < t3.length; r4++) {
                  const i4 = t3[r4];
                  if (r4 >= 1) {
                    const a3 = t3[r4 - 1];
                    if (!Xo(i4, a3)) {
                      n3.vertexLength + 4 > vs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t4 = i4.sub(a3)._perp()._unit(), r5 = a3.dist(i4);
                      e4 + r5 > 32768 && (e4 = 0), Go(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 0, e4), Go(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 1, e4), s2.x += 2 * i4.x, s2.y += 2 * i4.y, s2.vertexCount += 2, e4 += r5, Go(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 0, e4), Go(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 1, e4), s2.x += 2 * a3.x, s2.y += 2 * a3.y, s2.vertexCount += 2;
                      const o3 = n3.vertexLength;
                      this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n3.vertexLength + e3 > vs.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), "Polygon" !== Zo[t2.type])
                continue;
              const i3 = [], a2 = [], o2 = n3.vertexLength;
              for (const t3 of r3)
                if (0 !== t3.length) {
                  t3 !== r3[0] && a2.push(i3.length / 2);
                  for (let e4 = 0; e4 < t3.length; e4++) {
                    const r4 = t3[e4];
                    Go(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), s2.x += r4.x, s2.y += r4.y, s2.vertexCount += 1, i3.push(r4.x), i3.push(r4.y);
                  }
                }
              const l2 = mo(i3, a2);
              for (let t3 = 0; t3 < l2.length; t3 += 3)
                this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
              n3.primitiveLength += l2.length / 3, n3.vertexLength += e3;
            }
            for (let t3 = 0; t3 < s2.vertexCount; t3++)
              this.centroidVertexArray.emplaceBack(Math.floor(s2.x / s2.vertexCount), Math.floor(s2.y / s2.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
        }
        function Xo(t2, e2) {
          return t2.x === e2.x && (t2.x < 0 || t2.x > Js) || t2.y === e2.y && (t2.y < 0 || t2.y > Js);
        }
        function Ho(t2) {
          return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > Js) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > Js);
        }
        let Yo;
        On("FillExtrusionBucket", Jo, { omit: ["layers", "features"] });
        var Wo = { get paint() {
          return Yo = Yo || new di({ "fill-extrusion-opacity": new ui(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ci(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ui(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ui(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new hi(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ci(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ci(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ui(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Qo extends mi {
          constructor(t2) {
            super(t2, Wo);
          }
          createBucket(t2) {
            return new Jo(t2);
          }
          queryRadius() {
            return fa(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2, l2) {
            const u2 = da(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, o2), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = function(t3, e3, r3, n3) {
              const i3 = [];
              for (const r4 of t3) {
                const t4 = [r4.x, r4.y, 0, 1];
                Sa(t4, t4, e3), i3.push(new s(t4[0] / t4[3], t4[1] / t4[3]));
              }
              return i3;
            }(u2, l2), f2 = function(t3, e3, r3, n3) {
              const i3 = [], a3 = [], o3 = n3[8] * e3, l3 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f3 = n3[10] * r3, d2 = n3[11] * r3;
              for (const e4 of t3) {
                const t4 = [], r4 = [];
                for (const i4 of e4) {
                  const e5 = i4.x, a4 = i4.y, y2 = n3[0] * e5 + n3[4] * a4 + n3[12], m2 = n3[1] * e5 + n3[5] * a4 + n3[13], g2 = n3[2] * e5 + n3[6] * a4 + n3[14], x2 = n3[3] * e5 + n3[7] * a4 + n3[15], v2 = g2 + u3, b2 = x2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f3, S2 = x2 + d2, k2 = new s((y2 + o3) / b2, (m2 + l3) / b2);
                  k2.z = v2 / b2, t4.push(k2);
                  const I2 = new s(w2 / S2, _2 / S2);
                  I2.z = A2 / S2, r4.push(I2);
                }
                i3.push(t4), a3.push(r4);
              }
              return [i3, a3];
            }(n2, h2, c2, l2);
            return function(t3, e3, r3) {
              let n3 = 1 / 0;
              na(r3, e3) && (n3 = el(r3, e3[0]));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const s2 = e3[i3], a3 = t3[i3];
                for (let t4 = 0; t4 < s2.length - 1; t4++) {
                  const e4 = s2[t4], i4 = [e4, s2[t4 + 1], a3[t4 + 1], a3[t4], e4];
                  ea(r3, i4) && (n3 = Math.min(n3, el(r3, i4)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(f2[0], f2[1], p2);
          }
        }
        function tl(t2, e2) {
          return t2.x * e2.x + t2.y * e2.y;
        }
        function el(t2, e2) {
          if (1 === t2.length) {
            let r2 = 0;
            const n2 = e2[r2++];
            let i2;
            for (; !i2 || n2.equals(i2); )
              if (i2 = e2[r2++], !i2)
                return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = tl(o2, o2), h2 = tl(o2, l2), p2 = tl(l2, l2), f2 = tl(u2, o2), d2 = tl(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
              if (isFinite(x2))
                return x2;
            }
            return 1 / 0;
          }
          {
            let t3 = 1 / 0;
            for (const r2 of e2)
              t3 = Math.min(t3, r2.z);
            return t3;
          }
        }
        const rl = bi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: nl } = rl, il = bi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: sl } = il, al = Eo.VectorTileFeature.types, ol = Math.cos(Math.PI / 180 * 37.5), ll = Math.pow(2, 14) / 0.5;
        class ul {
          constructor(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
              this.gradients[t3.id] = {};
            }), this.layoutVertexArray = new os(), this.layoutVertexArray2 = new ls(), this.indexArray = new ys(), this.programConfigurations = new Zs(t2.layers, t2.zoom), this.segments = new vs(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
          }
          populate(t2, e2, r2) {
            this.hasPattern = Ao("line", this.layers, e2);
            const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
            for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
              const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ws(e3, t3);
              if (!this.layers[0]._featureFilter.filter(new ti(this.zoom), u2, r2))
                continue;
              const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ys(e3), patterns: {}, sortKey: c2 };
              s2.push(h2);
            }
            i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
            for (const n3 of s2) {
              const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
              if (this.hasPattern) {
                const t3 = So("line", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t3);
              } else
                this.addFeature(n3, i3, s3, r2, {});
              e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
            }
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t2, e2, r2) {
            for (const t3 of this.patternFeatures)
              this.addFeature(t3, t3.geometry, t3.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, sl)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, nl), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t2) {
            if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
              return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }
          addFeature(t2, e2, r2, n2, i2) {
            const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (const r3 of e2)
              this.addLine(r3, t2, a2, o2, l2, u2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }
          addLine(t2, e2, r2, n2, i2, s2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t2.length - 1; e3++)
                this.totalDistance += t2[e3].dist(t2[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a2 = "Polygon" === al[e2.type];
            let o2 = t2.length;
            for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
              o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
              l2++;
            if (o2 < (a2 ? 3 : 2))
              return;
            "bevel" === r2 && (i2 = 1.05);
            const u2 = this.overscaling <= 16 ? 15 * Js / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h2, p2, f2, d2, y2;
            this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
            for (let e3 = l2; e3 < o2; e3++) {
              if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
                continue;
              y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
              let m2 = d2.add(y2);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < ol && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
              if (w2 && e3 > l2) {
                const t3 = h2.dist(p2);
                if (t3 > 2 * u2) {
                  const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                  this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                }
              }
              const A2 = p2 && f2;
              let S2 = A2 ? r2 : a2 ? "butt" : n2;
              if (A2 && "round" === S2 && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i2 && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === S2)
                m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("flipbevel" === S2) {
                if (v2 > 100)
                  m2 = y2.mult(-1);
                else {
                  const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                  m2._perp()._mult(t3 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), "fakeround" === S2) {
                  const t4 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t4; e5++) {
                    let r4 = e5 / t4;
                    if (0.5 !== r4) {
                      const t5 = r4 - 0.5;
                      r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
              } else if ("butt" === S2)
                this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("square" === S2) {
                const t3 = p2 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t3, t3, c2);
              } else
                "round" === S2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
              if (w2 && e3 < o2 - 1) {
                const t3 = h2.dist(f2);
                if (t3 > 2 * u2) {
                  const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                  this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                }
              }
            }
          }
          addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
            const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > ll / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
          }
          addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
            const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (ll - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }
        }
        let cl, hl;
        On("LineBucket", ul, { omit: ["layers", "patternFeatures"] });
        var pl = { get paint() {
          return hl = hl || new di({ "line-opacity": new ci(G.paint_line["line-opacity"]), "line-color": new ci(G.paint_line["line-color"]), "line-translate": new ui(G.paint_line["line-translate"]), "line-translate-anchor": new ui(G.paint_line["line-translate-anchor"]), "line-width": new ci(G.paint_line["line-width"]), "line-gap-width": new ci(G.paint_line["line-gap-width"]), "line-offset": new ci(G.paint_line["line-offset"]), "line-blur": new ci(G.paint_line["line-blur"]), "line-dasharray": new pi(G.paint_line["line-dasharray"]), "line-pattern": new hi(G.paint_line["line-pattern"]), "line-gradient": new fi(G.paint_line["line-gradient"]) });
        }, get layout() {
          return cl = cl || new di({ "line-cap": new ui(G.layout_line["line-cap"]), "line-join": new ci(G.layout_line["line-join"]), "line-miter-limit": new ui(G.layout_line["line-miter-limit"]), "line-round-limit": new ui(G.layout_line["line-round-limit"]), "line-sort-key": new ci(G.layout_line["line-sort-key"]) });
        } };
        class fl extends ci {
          possiblyEvaluate(t2, e2) {
            return e2 = new ti(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
          }
          evaluate(t2, e2, r2, n2) {
            return e2 = g({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
          }
        }
        let dl;
        class yl extends mi {
          constructor(t2) {
            super(t2, pl), this.gradientVersion = 0, dl || (dl = new fl(pl.paint.properties["line-width"].specification), dl.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t2) {
            if ("line-gradient" === t2) {
              const t3 = this.gradientExpression();
              this.stepInterpolant = !!function(t4) {
                return void 0 !== t4._styleExpression;
              }(t3) && t3._styleExpression.expression instanceof Re, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t2, e2) {
            super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = dl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
          }
          createBucket(t2) {
            return new ul(t2);
          }
          queryRadius(t2) {
            const e2 = t2, r2 = ml(pa("line-width", this, e2), pa("line-gap-width", this, e2)), n2 = pa("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + fa(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2) {
            const l2 = da(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, o2), u2 = o2 / 2 * ml(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), c2 = this.paint.get("line-offset").evaluate(e2, r2);
            return c2 && (n2 = function(t3, e3) {
              const r3 = [];
              for (let n3 = 0; n3 < t3.length; n3++) {
                const i3 = t3[n3], a3 = [];
                for (let t4 = 0; t4 < i3.length; t4++) {
                  const r4 = i3[t4 - 1], n4 = i3[t4], o3 = i3[t4 + 1], l3 = 0 === t4 ? new s(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t4 === i3.length - 1 ? new s(0, 0) : o3.sub(n4)._unit()._perp(), c3 = l3._add(u3)._unit(), h2 = c3.x * u3.x + c3.y * u3.y;
                  0 !== h2 && c3._mult(1 / h2), a3.push(c3._mult(e3)._add(n4));
                }
                r3.push(a3);
              }
              return r3;
            }(n2, c2 * o2)), function(t3, e3, r3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i3 = e3[n3];
                if (t3.length >= 3) {
                  for (let e4 = 0; e4 < i3.length; e4++)
                    if (ca(t3, i3[e4]))
                      return true;
                }
                if (ia(t3, i3, r3))
                  return true;
              }
              return false;
            }(l2, n2, u2);
          }
          isTileClipped() {
            return true;
          }
        }
        function ml(t2, e2) {
          return e2 > 0 ? e2 + 2 * t2 : t2;
        }
        const gl = bi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), xl = bi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        bi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const vl = bi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        bi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const bl = bi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), wl = bi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function _l(t2, e2, r2) {
          return t2.sections.forEach((t3) => {
            t3.text = function(t4, e3, r3) {
              const n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Qn.applyArabicShaping && (t4 = Qn.applyArabicShaping(t4)), t4;
            }(t3.text, e2, r2);
          }), t2;
        }
        bi([{ name: "triangle", components: 3, type: "Uint16" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), bi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), bi([{ type: "Float32", name: "offsetX" }]), bi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), bi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Al = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var Sl = 24, kl = Ml, Il = function(t2, e2, r2, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
          for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
            ;
          if (0 === s2)
            s2 = 1 - u2;
          else {
            if (s2 === l2)
              return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        }, zl = function(t2, e2, r2, n2, i2, s2) {
          var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
            ;
          t2[r2 + f2 - d2] |= 128 * y2;
        };
        function Ml(t2) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Ml.Varint = 0, Ml.Fixed64 = 1, Ml.Bytes = 2, Ml.Fixed32 = 5;
        var Bl = 4294967296, Cl = 1 / Bl, Pl = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Vl(t2) {
          return t2.type === Ml.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
        }
        function El(t2, e2, r2) {
          return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
        }
        function Fl(t2, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i2 = r2.pos - 1; i2 >= t2; i2--)
            r2.buf[i2 + n2] = r2.buf[i2];
        }
        function Tl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeVarint(t2[r2]);
        }
        function $l(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSVarint(t2[r2]);
        }
        function Dl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFloat(t2[r2]);
        }
        function Ll(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeDouble(t2[r2]);
        }
        function Ol(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeBoolean(t2[r2]);
        }
        function Rl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed32(t2[r2]);
        }
        function Ul(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed32(t2[r2]);
        }
        function jl(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeFixed64(t2[r2]);
        }
        function ql(t2, e2) {
          for (var r2 = 0; r2 < t2.length; r2++)
            e2.writeSFixed64(t2[r2]);
        }
        function Nl(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
        }
        function Zl(t2, e2, r2) {
          t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
        }
        function Kl(t2, e2) {
          return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
        }
        Ml.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t2 = Nl(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readSFixed32: function() {
          var t2 = Kl(this.buf, this.pos);
          return this.pos += 4, t2;
        }, readFixed64: function() {
          var t2 = Nl(this.buf, this.pos) + Nl(this.buf, this.pos + 4) * Bl;
          return this.pos += 8, t2;
        }, readSFixed64: function() {
          var t2 = Nl(this.buf, this.pos) + Kl(this.buf, this.pos + 4) * Bl;
          return this.pos += 8, t2;
        }, readFloat: function() {
          var t2 = Il(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        }, readDouble: function() {
          var t2 = Il(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        }, readVarint: function(t2) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n3, i2, s2 = r3.buf;
            if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
              return El(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
              return El(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
              return El(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
              return El(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
              return El(t3, n3, e3);
            if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
              return El(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && Pl ? function(t3, e3, r2) {
            return Pl.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            for (var n2 = "", i2 = e3; i2 < r2; ) {
              var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + c2 > r2)
                break;
              1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e2, t2);
        }, readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        }, readPackedVarint: function(t2, e2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readVarint(e2));
          var r2 = Vl(this);
          for (t2 = t2 || []; this.pos < r2; )
            t2.push(this.readVarint(e2));
          return t2;
        }, readPackedSVarint: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readSVarint());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSVarint());
          return t2;
        }, readPackedBoolean: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readBoolean());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readBoolean());
          return t2;
        }, readPackedFloat: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readFloat());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFloat());
          return t2;
        }, readPackedDouble: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readDouble());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readDouble());
          return t2;
        }, readPackedFixed32: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readFixed32());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed32());
          return t2;
        }, readPackedSFixed32: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readSFixed32());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed32());
          return t2;
        }, readPackedFixed64: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readFixed64());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readFixed64());
          return t2;
        }, readPackedSFixed64: function(t2) {
          if (this.type !== Ml.Bytes)
            return t2.push(this.readSFixed64());
          var e2 = Vl(this);
          for (t2 = t2 || []; this.pos < e2; )
            t2.push(this.readSFixed64());
          return t2;
        }, skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === Ml.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === Ml.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === Ml.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== Ml.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        }, realloc: function(t2) {
          for (var e2 = this.length || 16; e2 < this.pos + t2; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t2) {
          this.realloc(4), Zl(this.buf, t2, this.pos), this.pos += 4;
        }, writeSFixed32: function(t2) {
          this.realloc(4), Zl(this.buf, t2, this.pos), this.pos += 4;
        }, writeFixed64: function(t2) {
          this.realloc(8), Zl(this.buf, -1 & t2, this.pos), Zl(this.buf, Math.floor(t2 * Cl), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t2) {
          this.realloc(8), Zl(this.buf, -1 & t2, this.pos), Zl(this.buf, Math.floor(t2 * Cl), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n2;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        }, writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        }, writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        }, writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
              if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && Fl(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t2) {
          this.realloc(4), zl(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t2) {
          this.realloc(8), zl(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t2[r2];
        }, writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && Fl(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, Ml.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, Tl, e2);
        }, writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, $l, e2);
        }, writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ol, e2);
        }, writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, Dl, e2);
        }, writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ll, e2);
        }, writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Rl, e2);
        }, writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, Ul, e2);
        }, writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, jl, e2);
        }, writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, ql, e2);
        }, writeBytesField: function(t2, e2) {
          this.writeTag(t2, Ml.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t2, e2) {
          this.writeTag(t2, Ml.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t2, e2) {
          this.writeTag(t2, Ml.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t2, e2) {
          this.writeTag(t2, Ml.Bytes), this.writeString(e2);
        }, writeFloatField: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t2, e2) {
          this.writeTag(t2, Ml.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        } };
        var Gl = r(kl);
        const Jl = 3;
        function Xl(t2, e2, r2) {
          1 === t2 && r2.readMessage(Hl, e2);
        }
        function Hl(t2, e2, r2) {
          if (3 === t2) {
            const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Yl, {});
            e2.push({ id: t3, bitmap: new Ea({ width: i2 + 2 * Jl, height: s2 + 2 * Jl }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
          }
        }
        function Yl(t2, e2, r2) {
          1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
        }
        const Wl = Jl;
        function Ql(t2) {
          let e2 = 0, r2 = 0;
          for (const n3 of t2)
            e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t2.sort((t3, e3) => e3.h - t3.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i2 = 0, s2 = 0;
          for (const e3 of t2)
            for (let t3 = n2.length - 1; t3 >= 0; t3--) {
              const r3 = n2[t3];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  const e4 = n2.pop();
                  t3 < n2.length && (n2[t3] = e4);
                } else
                  e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
          return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
        }
        const tu = 1;
        class eu {
          constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
            this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
          }
          get tl() {
            return [this.paddedRect.x + tu, this.paddedRect.y + tu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - tu, this.paddedRect.y + this.paddedRect.h - tu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * tu) / this.pixelRatio, (this.paddedRect.h - 2 * tu) / this.pixelRatio];
          }
        }
        class ru {
          constructor(t2, e2) {
            const r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
            const { w: s2, h: a2 } = Ql(i2), o2 = new Fa({ width: s2 || 1, height: a2 || 1 });
            for (const e3 in t2) {
              const n3 = t2[e3], i3 = r2[e3].paddedRect;
              Fa.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + tu, y: i3.y + tu }, n3.data);
            }
            for (const t3 in e2) {
              const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + tu, a3 = i3.y + tu, l2 = r3.data.width, u2 = r3.data.height;
              Fa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Fa.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Fa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Fa.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Fa.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t2, e2, r2) {
            for (const n2 in t2) {
              const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * tu, h: i2.data.height + 2 * tu };
              r2.push(s2), e2[n2] = new eu(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t2, e2) {
            t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t2.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }
          patchUpdatedImage(t2, e2, r2) {
            if (!t2 || !e2)
              return;
            if (t2.version === e2.version)
              return;
            t2.version = e2.version;
            const [n2, i2] = t2.tl;
            r2.update(e2.data, void 0, { x: n2, y: i2 });
          }
        }
        var nu;
        On("ImagePosition", eu), On("ImageAtlas", ru), t.ah = void 0, (nu = t.ah || (t.ah = {}))[nu.none = 0] = "none", nu[nu.horizontal = 1] = "horizontal", nu[nu.vertical = 2] = "vertical", nu[nu.horizontalOnly = 3] = "horizontalOnly";
        const iu = -17;
        class su {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t2, e2) {
            const r2 = new su();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t2) {
            const e2 = new su();
            return e2.imageName = t2, e2;
          }
        }
        class au {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t2, e2) {
            const r2 = new au();
            for (let n2 = 0; n2 < t2.sections.length; n2++) {
              const i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t2) {
            return this.sections[this.sectionIndex[t2]];
          }
          getSectionIndex(t2) {
            return this.sectionIndex[t2];
          }
          getCharCode(t2) {
            return this.text.charCodeAt(t2);
          }
          verticalizePunctuation() {
            this.text = function(t2) {
              let e2 = "";
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                e2 += n2 && Xn(n2) && !Al[t2[r2 + 1]] || i2 && Xn(i2) && !Al[t2[r2 - 1]] || !Al[t2[r2]] ? t2[r2] : Al[t2[r2]];
              }
              return e2;
            }(this.text);
          }
          trim() {
            let t2 = 0;
            for (let e3 = 0; e3 < this.text.length && lu[this.text.charCodeAt(e3)]; e3++)
              t2++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && lu[this.text.charCodeAt(r2)]; r2--)
              e2--;
            this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
          }
          substring(t2, e2) {
            const r2 = new au();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
          }
          addTextSection(t2, e2) {
            this.text += t2.text, this.sections.push(su.forText(t2.scale, t2.fontStack || e2));
            const r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t2.text.length; ++e3)
              this.sectionIndex.push(r2);
          }
          addImageSection(t2) {
            const e2 = t2.image ? t2.image.name : "";
            if (0 === e2.length)
              return void A("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(su.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function ou(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = au.fromFeature(e2, s2);
          let x2;
          p2 === t.ah.vertical && g2.verticalizePunctuation();
          const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Qn;
          if (v2 && 1 === g2.sections.length) {
            x2 = [];
            const t2 = v2(g2.toString(), yu(g2, c2, a2, r2, i2, d2, y2));
            for (const e3 of t2) {
              const t3 = new au();
              t3.text = e3, t3.sections = g2.sections;
              for (let r3 = 0; r3 < e3.length; r3++)
                t3.sectionIndex.push(0);
              x2.push(t3);
            }
          } else if (b2) {
            x2 = [];
            const t2 = b2(g2.text, g2.sectionIndex, yu(g2, c2, a2, r2, i2, d2, y2));
            for (const e3 of t2) {
              const t3 = new au();
              t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = g2.sections, x2.push(t3);
            }
          } else
            x2 = function(t2, e3) {
              const r3 = [], n3 = t2.text;
              let i3 = 0;
              for (const n4 of e3)
                r3.push(t2.substring(i3, n4)), i3 = n4;
              return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
            }(g2, yu(g2, c2, a2, r2, i2, d2, y2));
          const w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
          return function(e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3, p3) {
            let f3 = 0, d3 = iu, y3 = 0, m3 = 0;
            const g3 = "right" === l3 ? 1 : "left" === l3 ? 0 : 0.5;
            let x3 = 0;
            for (const o4 of s3) {
              o4.trim();
              const s4 = o4.getMaxScale(), l4 = (s4 - 1) * Sl, b4 = { positionedGlyphs: [], lineOffset: 0 };
              e3.positionedLines[x3] = b4;
              const w4 = b4.positionedGlyphs;
              let _4 = 0;
              if (!o4.length()) {
                d3 += a3, ++x3;
                continue;
              }
              for (let a4 = 0; a4 < o4.length(); a4++) {
                const y4 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
                let x4 = 0, b5 = null, A3 = null, S2 = null, k2 = Sl;
                const I2 = !(u3 === t.ah.horizontal || !h3 && !Jn(g4) || h3 && (lu[g4] || (v3 = g4, Nn.Arabic(v3) || Nn["Arabic Supplement"](v3) || Nn["Arabic Extended-A"](v3) || Nn["Arabic Presentation Forms-A"](v3) || Nn["Arabic Presentation Forms-B"](v3))));
                if (y4.imageName) {
                  const t2 = i3[y4.imageName];
                  if (!t2)
                    continue;
                  S2 = y4.imageName, e3.iconsInText = e3.iconsInText || true, A3 = t2.paddedRect;
                  const r4 = t2.displaySize;
                  y4.scale = y4.scale * Sl / p3, b5 = { width: r4[0], height: r4[1], left: tu, top: -Wl, advance: I2 ? r4[1] : r4[0] }, x4 = l4 + (Sl - r4[1] * y4.scale), k2 = b5.advance;
                  const n4 = I2 ? r4[0] * y4.scale - Sl * s4 : r4[1] * y4.scale - Sl * s4;
                  n4 > 0 && n4 > _4 && (_4 = n4);
                } else {
                  const t2 = n3[y4.fontStack], e4 = t2 && t2[g4];
                  if (e4 && e4.rect)
                    A3 = e4.rect, b5 = e4.metrics;
                  else {
                    const t3 = r3[y4.fontStack], e5 = t3 && t3[g4];
                    if (!e5)
                      continue;
                    b5 = e5.metrics;
                  }
                  x4 = (s4 - y4.scale) * Sl;
                }
                I2 ? (e3.verticalizable = true, w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += k2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y4.scale + c3);
              }
              0 !== w4.length && (y3 = Math.max(f3 - c3, y3), gu(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
              const A2 = a3 * s4 + _4;
              b4.lineOffset = Math.max(_4, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
            }
            var v3;
            const b3 = d3 - iu, { horizontalAlign: w3, verticalAlign: _3 } = mu(o3);
            (function(t2, e4, r4, n4, i4, s4, a4, o4, l4) {
              const u4 = (e4 - r4) * i4;
              let c4 = 0;
              c4 = s4 !== a4 ? -o4 * n4 - iu : (-n4 * l4 + 0.5) * a4;
              for (const e5 of t2)
                for (const t3 of e5.positionedGlyphs)
                  t3.x += u4, t3.y += c4;
            })(e3.positionedLines, g3, w3, _3, y3, m3, a3, b3, s3.length), e3.top += -_3 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
          }(_2, r2, n2, i2, x2, o2, l2, u2, p2, c2, f2, m2), !function(t2) {
            for (const e3 of t2)
              if (0 !== e3.positionedGlyphs.length)
                return false;
            return true;
          }(w2) && _2;
        }
        const lu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, uu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function cu(t2, e2, r2, n2, i2, s2) {
          if (e2.imageName) {
            const t3 = n2[e2.imageName];
            return t3 ? t3.displaySize[0] * e2.scale * Sl / s2 + i2 : 0;
          }
          {
            const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
            return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
          }
        }
        function hu(t2, e2, r2, n2) {
          const i2 = Math.pow(t2 - e2, 2);
          return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
        }
        function pu(t2, e2, r2) {
          let n2 = 0;
          return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function fu(t2, e2, r2, n2, i2, s2) {
          let a2 = null, o2 = hu(e2, r2, i2, s2);
          for (const t3 of n2) {
            const n3 = hu(e2 - t3.x, r2, i2, s2) + t3.badness;
            n3 <= o2 && (a2 = t3, o2 = n3);
          }
          return { index: t2, x: e2, priorBreak: a2, badness: o2 };
        }
        function du(t2) {
          return t2 ? du(t2.priorBreak).concat(t2.index) : [];
        }
        function yu(t2, e2, r2, n2, i2, s2, a2) {
          if ("point" !== s2)
            return [];
          if (!t2)
            return [];
          const o2 = [], l2 = function(t3, e3, r3, n3, i3, s3) {
            let a3 = 0;
            for (let r4 = 0; r4 < t3.length(); r4++) {
              const o3 = t3.getSection(r4);
              a3 += cu(t3.getCharCode(r4), o3, n3, i3, e3, s3);
            }
            return a3 / Math.max(1, Math.ceil(a3 / r3));
          }(t2, e2, r2, n2, i2, a2), u2 = t2.text.indexOf("​") >= 0;
          let c2 = 0;
          for (let r3 = 0; r3 < t2.length(); r3++) {
            const s3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
            if (lu[p2] || (c2 += cu(p2, s3, n2, i2, e2, a2)), r3 < t2.length() - 1) {
              const e3 = !((h2 = p2) < 11904 || !(Nn["Bopomofo Extended"](h2) || Nn.Bopomofo(h2) || Nn["CJK Compatibility Forms"](h2) || Nn["CJK Compatibility Ideographs"](h2) || Nn["CJK Compatibility"](h2) || Nn["CJK Radicals Supplement"](h2) || Nn["CJK Strokes"](h2) || Nn["CJK Symbols and Punctuation"](h2) || Nn["CJK Unified Ideographs Extension A"](h2) || Nn["CJK Unified Ideographs"](h2) || Nn["Enclosed CJK Letters and Months"](h2) || Nn["Halfwidth and Fullwidth Forms"](h2) || Nn.Hiragana(h2) || Nn["Ideographic Description Characters"](h2) || Nn["Kangxi Radicals"](h2) || Nn["Katakana Phonetic Extensions"](h2) || Nn.Katakana(h2) || Nn["Vertical Forms"](h2) || Nn["Yi Radicals"](h2) || Nn["Yi Syllables"](h2)));
              (uu[p2] || e3 || s3.imageName) && o2.push(fu(r3 + 1, c2, l2, o2, pu(p2, t2.getCharCode(r3 + 1), e3 && u2), false));
            }
          }
          var h2;
          return du(fu(t2.length(), c2, l2, o2, 0, true));
        }
        function mu(t2) {
          let e2 = 0.5, r2 = 0.5;
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t2) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function gu(t2, e2, r2, n2, i2) {
          if (!n2 && !i2)
            return;
          const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
          for (let n3 = e2; n3 <= r2; n3++)
            t2[n3].x -= a2, t2[n3].y += i2;
        }
        function xu(t2, e2, r2) {
          const { horizontalAlign: n2, verticalAlign: i2 } = mu(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
          return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
        }
        function vu(t2, e2, r2, n2, i2, s2) {
          const a2 = t2.image;
          let o2;
          if (a2.content) {
            const t3 = a2.content, e3 = a2.pixelRatio || 1;
            o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
          }
          const l2 = e2.left * s2, u2 = e2.right * s2;
          let c2, h2, p2, f2;
          "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
          const d2 = e2.top * s2, y2 = e2.bottom * s2;
          return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        const bu = 255, wu = 128, _u = bu * wu;
        function Au(t2, e2) {
          const { expression: r2 } = e2;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new ti(t2 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n2 } = r2;
            let i2 = 0;
            for (; i2 < e3.length && e3[i2] <= t2; )
              i2++;
            i2 = Math.max(0, i2 - 1);
            let s2 = i2;
            for (; s2 < e3.length && e3[s2] < t2 + 1; )
              s2++;
            s2 = Math.min(e3.length - 1, s2);
            const a2 = e3[i2], o2 = e3[s2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new ti(a2)), maxSize: r2.evaluate(new ti(o2)), interpolationType: n2 };
          }
        }
        function Su(t2, e2, r2) {
          let n2 = "never";
          const i2 = t2.get(e2);
          return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
        }
        const ku = Eo.VectorTileFeature.types, Iu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function zu(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const f2 = o2 ? Math.min(_u, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(_u, Math.round(o2[1])) : 0;
          t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function Mu(t2, e2, r2) {
          t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
        }
        function Bu(t2) {
          for (const e2 of t2.sections)
            if (Wn(e2.text))
              return true;
          return false;
        }
        class Cu {
          constructor(t2) {
            this.layoutVertexArray = new cs(), this.indexArray = new ys(), this.programConfigurations = t2, this.segments = new vs(), this.dynamicLayoutVertexArray = new hs(), this.opacityVertexArray = new ps(), this.hasVisibleVertices = false, this.placedSymbolArray = new Ji();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t2, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, gl.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, xl.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Iu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        On("SymbolBuffers", Cu);
        class Pu {
          constructor(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new vs(), this.collisionVertexArray = new ds();
          }
          upload(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, vl.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        On("CollisionBuffers", Pu);
        class Vu {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ba([]), this.placementViewportMatrix = ba([]);
            const r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Au(this.zoom, r2["text-size"]), this.iconSizeData = Au(this.zoom, r2["icon-size"]);
            const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
            this.canOverlap = "never" !== Su(n2, "text-overlap", "text-allow-overlap") || "never" !== Su(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.ah[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new Cu(new Zs(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Cu(new Zs(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Yi(), this.lineVertexArray = new Wi(), this.symbolInstances = new Hi(), this.textAnchorOffsets = new ts();
          }
          calculateGlyphDependencies(t2, e2, r2, n2, i2) {
            for (let s2 = 0; s2 < t2.length; s2++)
              if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
                const r3 = Al[t2.charAt(s2)];
                r3 && (e2[r3.charCodeAt(0)] = true);
              }
          }
          populate(e2, r2, n2) {
            const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Yt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2)
              return;
            const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new ti(this.zoom);
            for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
              const e3 = i2._featureFilter.needGeometry, g2 = Ws(r3, e3);
              if (!i2._featureFilter.filter(y2, g2, n2))
                continue;
              let x2, v2;
              if (e3 || (g2.geometry = Ys(r3)), u2) {
                const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Yt.factory(t2), r4 = this.hasRTLText = this.hasRTLText || Bu(e4);
                (!r4 || "unavailable" === Qn.getRTLTextPluginStatus() || r4 && Qn.isParsed()) && (x2 = _l(e4, i2, g2));
              }
              if (c2) {
                const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t2 instanceof ee ? t2 : ee.fromString(t2);
              }
              if (!x2 && !v2)
                continue;
              const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: ku[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x2) {
                const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ah.vertical) >= 0;
                for (const t2 of x2.sections)
                  if (t2.image)
                    p2[t2.image.name] = true;
                  else {
                    const n3 = Zn(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                    this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                  }
              }
            }
            "line" === s2.get("symbol-placement") && (this.features = function(t2) {
              const e3 = {}, r3 = {}, n3 = [];
              let i3 = 0;
              function s3(e4) {
                n3.push(t2[e4]), i3++;
              }
              function a3(t3, e4, i4) {
                const s4 = r3[t3];
                return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
              }
              function o3(t3, r4, i4) {
                const s4 = e3[r4];
                return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
              }
              function l3(t3, e4, r4) {
                const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t3}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t2.length; u3++) {
                const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  s3(u3);
                  continue;
                }
                const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                  const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                  delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                } else
                  f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
              }
              return n3.filter((t3) => t3.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
          }
          update(t2, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t2, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) {
              let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
              const i2 = {};
              for (let n3 = t2.segment + 1; n3 < e2.length; n3++)
                i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
              for (let r4 = t2.segment || 0; r4 >= 0; r4--)
                i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
              for (let t3 = 0; t3 < e2.length; t3++) {
                const e3 = i2[t3];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
            const f2 = e2.indexArray, d2 = e2.layoutVertexArray, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.ah.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
            for (let t2 = 0; t2 < r2.length; t2++) {
              const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], S2 = y2.vertexLength, k2 = w2[1];
              zu(d2, l2.x, l2.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), zu(d2, l2.x, l2.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), zu(d2, l2.x, l2.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), zu(d2, l2.x, l2.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Mu(e2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(S2, S2 + 1, S2 + 2), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A2]);
            }
            e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
            return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
          }
          addCollisionDebugVertices(t2, e2, r2, n2, i2, a2, o2) {
            const l2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u2 = l2.vertexLength, c2 = i2.layoutVertexArray, h2 = i2.collisionVertexArray, p2 = o2.anchorX, f2 = o2.anchorY;
            this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, n2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, n2)), l2.vertexLength += 4;
            const d2 = i2.indexArray;
            d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t2, e2, r2, n2) {
            for (let i2 = t2; i2 < e2; i2++) {
              const t3 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Pu(fs, bl.members, ms), this.iconCollisionBox = new Pu(fs, bl.members, ms);
            for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
              const e2 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = {};
            for (let n3 = e2; n3 < r2; n3++) {
              const e3 = t2.get(n3);
              u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n2; e3 < i2; e3++) {
              const r3 = t2.get(e3);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = s2; e3 < a2; e3++) {
              const r3 = t2.get(e3);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = o2; e3 < l2; e3++) {
              const r3 = t2.get(e3);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t2) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t2, e2) {
            const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
              t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
            for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
              s2.push(t3);
              const a2 = this.symbolInstances.get(t3);
              n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
            }
            return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
          }
          addToSortKeyRanges(t2, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }
          sortFeatures(t2) {
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t3 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t3);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                  t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Eu, Fu;
        On("SymbolBucket", Vu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Vu.MAX_GLYPHS = 65535, Vu.addDynamicAttributes = Mu;
        var Tu = { get paint() {
          return Fu = Fu || new di({ "icon-opacity": new ci(G.paint_symbol["icon-opacity"]), "icon-color": new ci(G.paint_symbol["icon-color"]), "icon-halo-color": new ci(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new ci(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ci(G.paint_symbol["icon-halo-blur"]), "icon-translate": new ui(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new ui(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new ci(G.paint_symbol["text-opacity"]), "text-color": new ci(G.paint_symbol["text-color"], { runtimeType: ft, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ci(G.paint_symbol["text-halo-color"]), "text-halo-width": new ci(G.paint_symbol["text-halo-width"]), "text-halo-blur": new ci(G.paint_symbol["text-halo-blur"]), "text-translate": new ui(G.paint_symbol["text-translate"]), "text-translate-anchor": new ui(G.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Eu = Eu || new di({ "symbol-placement": new ui(G.layout_symbol["symbol-placement"]), "symbol-spacing": new ui(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ui(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ci(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ui(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ui(G.layout_symbol["icon-allow-overlap"]), "icon-overlap": new ui(G.layout_symbol["icon-overlap"]), "icon-ignore-placement": new ui(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new ui(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ui(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new ci(G.layout_symbol["icon-size"]), "icon-text-fit": new ui(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ui(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new ci(G.layout_symbol["icon-image"]), "icon-rotate": new ci(G.layout_symbol["icon-rotate"]), "icon-padding": new ci(G.layout_symbol["icon-padding"]), "icon-keep-upright": new ui(G.layout_symbol["icon-keep-upright"]), "icon-offset": new ci(G.layout_symbol["icon-offset"]), "icon-anchor": new ci(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ui(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ui(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ui(G.layout_symbol["text-rotation-alignment"]), "text-field": new ci(G.layout_symbol["text-field"]), "text-font": new ci(G.layout_symbol["text-font"]), "text-size": new ci(G.layout_symbol["text-size"]), "text-max-width": new ci(G.layout_symbol["text-max-width"]), "text-line-height": new ui(G.layout_symbol["text-line-height"]), "text-letter-spacing": new ci(G.layout_symbol["text-letter-spacing"]), "text-justify": new ci(G.layout_symbol["text-justify"]), "text-radial-offset": new ci(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ui(G.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new ci(G.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new ci(G.layout_symbol["text-anchor"]), "text-max-angle": new ui(G.layout_symbol["text-max-angle"]), "text-writing-mode": new ui(G.layout_symbol["text-writing-mode"]), "text-rotate": new ci(G.layout_symbol["text-rotate"]), "text-padding": new ui(G.layout_symbol["text-padding"]), "text-keep-upright": new ui(G.layout_symbol["text-keep-upright"]), "text-transform": new ci(G.layout_symbol["text-transform"]), "text-offset": new ci(G.layout_symbol["text-offset"]), "text-allow-overlap": new ui(G.layout_symbol["text-allow-overlap"]), "text-overlap": new ui(G.layout_symbol["text-overlap"]), "text-ignore-placement": new ui(G.layout_symbol["text-ignore-placement"]), "text-optional": new ui(G.layout_symbol["text-optional"]) });
        } };
        class $u {
          constructor(t2) {
            if (void 0 === t2.property.overrides)
              throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ut, this.defaultValue = t2;
          }
          evaluate(t2) {
            if (t2.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection))
                return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        On("FormatSectionOverride", $u, { omit: ["defaultValue"] });
        class Du extends mi {
          constructor(t2) {
            super(t2, Tu);
          }
          recalculate(t2, e2) {
            if (super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t3 = this.layout.get("text-writing-mode");
              if (t3) {
                const e3 = [];
                for (const r2 of t3)
                  e3.indexOf(r2) < 0 && e3.push(r2);
                this.layout._values["text-writing-mode"] = e3;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t2, e2, r2, n2) {
            const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
            return s2.isDataDriven() || Dr(s2.value) || !i2 ? i2 : function(t3, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && r3 in t3 ? String(t3[r3]) : "");
            }(e2.properties, i2);
          }
          createBucket(t2) {
            return new Vu(t2);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t2 of Tu.paint.overridableProperties) {
              if (!Du.hasPaintOverride(this.layout, t2))
                continue;
              const e2 = this.paint.get(t2), r2 = new $u(e2), n2 = new $r(r2, e2.property.specification);
              let i2 = null;
              i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Or("source", n2) : new Rr("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new oi(e2.property, i2, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Du.hasPaintOverride(this.layout, t2);
          }
          static hasPaintOverride(t2, e2) {
            const r2 = t2.get("text-field"), n2 = Tu.paint.properties[e2];
            let i2 = false;
            const s2 = (t3) => {
              for (const e3 of t3)
                if (n2.overrides && n2.overrides.hasOverride(e3))
                  return void (i2 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof Yt)
              s2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t3 = (e4) => {
                i2 || (e4 instanceof ae && ie(e4.value) === gt ? s2(e4.value.sections) : e4 instanceof dr ? s2(e4.sections) : e4.eachChild(t3));
              }, e3 = r2.value;
              e3._styleExpression && t3(e3._styleExpression.expression);
            }
            return i2;
          }
        }
        let Lu;
        var Ou = { get paint() {
          return Lu = Lu || new di({ "background-color": new ui(G.paint_background["background-color"]), "background-pattern": new pi(G.paint_background["background-pattern"]), "background-opacity": new ui(G.paint_background["background-opacity"]) });
        } };
        class Ru extends mi {
          constructor(t2) {
            super(t2, Ou);
          }
        }
        let Uu;
        var ju = { get paint() {
          return Uu = Uu || new di({ "raster-opacity": new ui(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new ui(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ui(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ui(G.paint_raster["raster-brightness-max"]), "raster-saturation": new ui(G.paint_raster["raster-saturation"]), "raster-contrast": new ui(G.paint_raster["raster-contrast"]), "raster-resampling": new ui(G.paint_raster["raster-resampling"]), "raster-fade-duration": new ui(G.paint_raster["raster-fade-duration"]) });
        } };
        class qu extends mi {
          constructor(t2) {
            super(t2, ju);
          }
        }
        class Nu extends mi {
          constructor(t2) {
            super(t2, {}), this.onAdd = (t3) => {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, this.onRemove = (t3) => {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, this.implementation = t2;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Zu {
          constructor(t2) {
            this._methodToThrottle = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Ku = 63710088e-1;
        class Gu {
          constructor(t2, e2) {
            if (isNaN(t2) || isNaN(e2))
              throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Gu(m(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t2) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return Ku * Math.acos(Math.min(i2, 1));
          }
          static convert(t2) {
            if (t2 instanceof Gu)
              return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
              return new Gu(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
              return new Gu(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Ju = 2 * Math.PI * Ku;
        function Xu(t2) {
          return Ju * Math.cos(t2 * Math.PI / 180);
        }
        function Hu(t2) {
          return (180 + t2) / 360;
        }
        function Yu(t2) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
        }
        function Wu(t2, e2) {
          return t2 / Xu(e2);
        }
        function Qu(t2) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
        }
        class tc {
          constructor(t2, e2, r2 = 0) {
            this.x = +t2, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t2, e2 = 0) {
            const r2 = Gu.convert(t2);
            return new tc(Hu(r2.lng), Yu(r2.lat), Wu(e2, r2.lat));
          }
          toLngLat() {
            return new Gu(360 * this.x - 180, Qu(this.y));
          }
          toAltitude() {
            return this.z * Xu(Qu(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Ju * (t2 = Qu(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          }
        }
        function ec(t2, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class rc {
          constructor(t2, e2, r2) {
            if (t2 < 0 || t2 > 25 || r2 < 0 || r2 >= Math.pow(2, t2) || e2 < 0 || e2 >= Math.pow(2, t2))
              throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
            this.z = t2, this.x = e2, this.y = r2, this.key = sc(0, t2, t2, e2, r2);
          }
          equals(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }
          url(t2, e2, r2) {
            const n2 = (s2 = this.y, a2 = this.z, o2 = ec(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = ec(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
            var i2, s2, a2, o2, l2;
            const u2 = function(t3, e3, r3) {
              let n3, i3 = "";
              for (let s3 = t3; s3 > 0; s3--)
                n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
          }
          isChildOf(t2) {
            const e2 = this.z - t2.z;
            return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
          }
          getTilePoint(t2) {
            const e2 = Math.pow(2, this.z);
            return new s((t2.x * e2 - this.x) * Js, (t2.y * e2 - this.y) * Js);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class nc {
          constructor(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = sc(t2, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class ic {
          constructor(t2, e2, r2, n2, i2) {
            if (t2 < r2)
              throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new rc(r2, +n2, +i2), this.key = sc(e2, t2, r2, n2, i2);
          }
          clone() {
            return new ic(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }
          scaledTo(t2) {
            if (t2 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            const e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new ic(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ic(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t2, e2) {
            if (t2 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
            const r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? sc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : sc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t2) {
            if (t2.wrap !== this.wrap)
              return false;
            const e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }
          children(t2) {
            if (this.overscaledZ >= t2)
              return [new ic(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new ic(e2, this.wrap, e2, r2, n2), new ic(e2, this.wrap, e2, r2 + 1, n2), new ic(e2, this.wrap, e2, r2, n2 + 1), new ic(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }
          wrapped() {
            return new ic(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t2) {
            return new ic(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new nc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t2) {
            return this.canonical.getTilePoint(new tc(t2.x - this.wrap, t2.y));
          }
        }
        function sc(t2, e2, r2, n2, i2) {
          (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
          const s2 = 1 << r2;
          return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        On("CanonicalTileID", rc), On("OverscaledTileID", ic, { omit: ["posMatrix"] });
        class ac {
          constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
            if (this.uid = t2, e2.height !== e2.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && !["mapbox", "terrarium", "custom"].includes(r2))
              return void A(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e2.height;
            const o2 = this.dim = e2.height - 2;
            switch (this.data = new Uint32Array(e2.data.buffer), r2) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t3 = 0; t3 < o2; t3++)
              this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t3 = 0; t3 < o2; t3++)
              for (let e3 = 0; e3 < o2; e3++) {
                const r3 = this.get(t3, e3);
                r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
              }
          }
          get(t2, e2) {
            const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
            return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }
          unpack(t2, e2, r2) {
            return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Fa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t2, e2, r2) {
            if (this.dim !== t2.dim)
              throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                s2 = a2 - 1;
                break;
              case 1:
                a2 = s2 + 1;
            }
            const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
            for (let e3 = s2; e3 < a2; e3++)
              for (let r3 = n2; r3 < i2; r3++)
                this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
          }
        }
        On("DEMData", ac);
        class oc {
          constructor(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t2.length; e2++) {
              const r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t2) {
            return this._stringToNumber[t2];
          }
          decode(t2) {
            if (t2 >= this._numberToString.length)
              throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t2];
          }
        }
        class lc {
          constructor(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t2) {
            this._geometry = t2;
          }
          toJSON() {
            const t2 = { geometry: this.geometry };
            for (const e2 in this)
              "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
            return t2;
          }
        }
        class uc {
          constructor(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Dn(Js, 16, 0), this.grid3D = new Dn(Js, 16, 0), this.featureIndexArray = new rs(), this.promoteId = e2;
          }
          insert(t2, e2, r2, n2, i2, s2) {
            const a2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            const o2 = s2 ? this.grid3D : this.grid;
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t4 = 0; t4 < r3.length; t4++) {
                const e3 = r3[t4];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < Js && n3[1] < Js && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Eo.VectorTile(new Gl(this.rawTileData)).layers, this.sourceLayerCoder = new oc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t2, e2, r2, n2) {
            this.loadVTLayers();
            const i2 = t2.params || {}, a2 = Js / t2.tileSize / t2.scale, o2 = Kr(i2.filter), l2 = t2.queryGeometry, u2 = t2.queryPadding * a2, c2 = hc(l2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = hc(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
              for (const s2 of t3)
                if (e4 <= s2.x && r4 <= s2.y && n4 >= s2.x && i4 >= s2.y)
                  return true;
              const a3 = [new s(e4, r4), new s(e4, i4), new s(n4, i4), new s(n4, r4)];
              if (t3.length > 2) {
                for (const e5 of a3)
                  if (ca(t3, e5))
                    return true;
              }
              for (let e5 = 0; e5 < t3.length - 1; e5++)
                if (ha(t3[e5], t3[e5 + 1], a3))
                  return true;
              return false;
            }(t2.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i3 + u2));
            for (const t3 of f2)
              h2.push(t3);
            h2.sort(pc);
            const d2 = {};
            let y2;
            for (let s2 = 0; s2 < h2.length; s2++) {
              const u3 = h2[s2];
              if (u3 === y2)
                continue;
              y2 = u3;
              const c3 = this.featureIndexArray.get(u3);
              let p3 = null;
              this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Ys(e3)), r3.queryIntersectsFeature(l2, e3, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
            }
            return d2;
          }
          loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
            const h2 = this.bucketLayerIDs[e2];
            if (s2 && !function(t3, e3) {
              for (let r3 = 0; r3 < t3.length; r3++)
                if (e3.indexOf(t3[r3]) >= 0)
                  return true;
              return false;
            }(s2, h2))
              return;
            const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
            if (i2.needGeometry) {
              const t3 = Ws(f2, true);
              if (!i2.filter(new ti(this.tileID.overscaledZ), t3, this.tileID.canonical))
                return;
            } else if (!i2.filter(new ti(this.tileID.overscaledZ), f2))
              return;
            const d2 = this.getId(f2, p2);
            for (let e3 = 0; e3 < h2.length; e3++) {
              const r3 = h2[e3];
              if (s2 && s2.indexOf(r3) < 0)
                continue;
              const i3 = o2[r3];
              if (!i3)
                continue;
              let p3 = {};
              d2 && u2 && (p3 = u2.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
              const y2 = g({}, l2[r3]);
              y2.paint = cc(y2.paint, i3.paint, f2, p3, a2), y2.layout = cc(y2.layout, i3.layout, f2, p3, a2);
              const m2 = !c2 || c2(f2, i3, p3);
              if (!m2)
                continue;
              const x2 = new lc(f2, this.z, this.x, this.y, d2);
              x2.layer = y2;
              let v2 = t2[r3];
              void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: m2 });
            }
          }
          lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = Kr(i2);
            for (const i3 of t2)
              this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e2);
            return l2;
          }
          hasLayer(t2) {
            for (const e2 of this.bucketLayerIDs)
              for (const r2 of e2)
                if (t2 === r2)
                  return true;
            return false;
          }
          getId(t2, e2) {
            let r2 = t2.id;
            return this.promoteId && (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
          }
        }
        function cc(t2, e2, r2, n2, i2) {
          return v(t2, (t3, s2) => {
            const a2 = e2 instanceof li ? e2.get(s2) : null;
            return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
          });
        }
        function hc(t2) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
          for (const s2 of t2)
            e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
          return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
        }
        function pc(t2, e2) {
          return e2 - t2;
        }
        function fc(t2, e2, r2, n2, i2) {
          const a2 = [];
          for (let o2 = 0; o2 < t2.length; o2++) {
            const l2 = t2[o2];
            let u2;
            for (let t3 = 0; t3 < l2.length - 1; t3++) {
              let o3 = l2[t3], c2 = l2[t3 + 1];
              o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= i2 && c2.y >= i2 || (o3.y >= i2 ? o3 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round() : c2.y >= i2 && (c2 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
            }
          }
          return a2;
        }
        On("FeatureIndex", uc, { omit: ["rawTileData", "sourceLayerCoder"] });
        class dc extends s {
          constructor(t2, e2, r2, n2) {
            super(t2, e2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
          }
          clone() {
            return new dc(this.x, this.y, this.angle, this.segment);
          }
        }
        function yc(t2, e2, r2, n2, i2) {
          if (void 0 === e2.segment || 0 === r2)
            return true;
          let s2 = e2, a2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (a2--, a2 < 0)
              return false;
            o2 -= t2[a2].dist(s2), s2 = t2[a2];
          }
          o2 += t2[a2].dist(t2[a2 + 1]), a2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t2[a2], r3 = t2[a2 + 1];
            if (!r3)
              return false;
            let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
              u2 -= l2.shift().angleDelta;
            if (u2 > i2)
              return false;
            a2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function mc(t2) {
          let e2 = 0;
          for (let r2 = 0; r2 < t2.length - 1; r2++)
            e2 += t2[r2].dist(t2[r2 + 1]);
          return e2;
        }
        function gc(t2, e2, r2) {
          return t2 ? 0.6 * e2 * r2 : 0;
        }
        function xc(t2, e2) {
          return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function vc(t2, e2, r2, n2, i2, s2) {
          const a2 = gc(r2, i2, s2), o2 = xc(r2, n2) * s2;
          let l2 = 0;
          const u2 = mc(t2) / 2;
          for (let r3 = 0; r3 < t2.length - 1; r3++) {
            const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
            if (l2 + s3 > u2) {
              const c2 = (u2 - l2) / s3, h2 = Ge.number(n3.x, i3.x, c2), p2 = Ge.number(n3.y, i3.y, c2), f2 = new dc(h2, p2, i3.angleTo(n3), r3);
              return f2._round(), !a2 || yc(t2, f2, o2, a2, e2) ? f2 : void 0;
            }
            l2 += s3;
          }
        }
        function bc(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = gc(n2, s2, a2), c2 = xc(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), wc(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
        }
        function wc(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = s2 / 2, c2 = mc(t2);
          let h2 = 0, p2 = e2 - r2, f2 = [];
          for (let e3 = 0; e3 < t2.length - 1; e3++) {
            const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              const m2 = (p2 - h2) / d2, g2 = Ge.number(a3.x, o3.x, m2), x2 = Ge.number(a3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new dc(g2, x2, y2, e3);
                r3._round(), n2 && !yc(t2, r3, s2, n2, i2) || f2.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || a2 || (f2 = wc(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
        }
        On("Anchor", dc);
        const _c = tu;
        function Ac(t2, e2, r2, n2) {
          const i2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2 * _c, u2 = a2.paddedRect.h - 2 * _c, c2 = t2.right - t2.left, h2 = t2.bottom - t2.top, p2 = a2.stretchX || [[0, l2]], f2 = a2.stretchY || [[0, u2]], d2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = p2.reduce(d2, 0), m2 = f2.reduce(d2, 0), g2 = l2 - y2, x2 = u2 - m2;
          let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, S2 = g2, k2 = 0, I2 = x2;
          if (a2.content && n2) {
            const t3 = a2.content;
            v2 = Sc(p2, 0, t3[0]), w2 = Sc(f2, 0, t3[1]), b2 = Sc(p2, t3[0], t3[2]), _2 = Sc(f2, t3[1], t3[3]), A2 = t3[0] - v2, k2 = t3[1] - w2, S2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - _2;
          }
          const z2 = (n3, i3, l3, u3) => {
            const p3 = Ic(n3.stretch - v2, b2, c2, t2.left), f3 = zc(n3.fixed - A2, S2, n3.stretch, y2), d3 = Ic(i3.stretch - w2, _2, h2, t2.top), g3 = zc(i3.fixed - k2, I2, i3.stretch, m2), x3 = Ic(l3.stretch - v2, b2, c2, t2.left), z3 = zc(l3.fixed - A2, S2, l3.stretch, y2), M2 = Ic(u3.stretch - w2, _2, h2, t2.top), B2 = zc(u3.fixed - k2, I2, u3.stretch, m2), C2 = new s(p3, d3), P2 = new s(x3, d3), V2 = new s(x3, M2), E2 = new s(p3, M2), F2 = new s(f3 / o2, g3 / o2), T2 = new s(z3 / o2, B2 / o2), $2 = e2 * Math.PI / 180;
            if ($2) {
              const t3 = Math.sin($2), e3 = Math.cos($2), r3 = [e3, -t3, t3, e3];
              C2._matMult(r3), P2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
            }
            const D2 = n3.stretch + n3.fixed, L2 = i3.stretch + i3.fixed;
            return { tl: C2, tr: P2, bl: E2, br: V2, tex: { x: a2.paddedRect.x + _c + D2, y: a2.paddedRect.y + _c + L2, w: l3.stretch + l3.fixed - D2, h: u3.stretch + u3.fixed - L2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: S2 / o2 / c2, minFontScaleY: I2 / o2 / h2, isSDF: r2 };
          };
          if (n2 && (a2.stretchX || a2.stretchY)) {
            const t3 = kc(p2, g2, y2), e3 = kc(f2, x2, m2);
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n3 = t3[r3], s2 = t3[r3 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++)
                i2.push(z2(n3, e3[t4], s2, e3[t4 + 1]));
            }
          } else
            i2.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return i2;
        }
        function Sc(t2, e2, r2) {
          let n2 = 0;
          for (const i2 of t2)
            n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
          return n2;
        }
        function kc(t2, e2, r2) {
          const n2 = [{ fixed: -_c, stretch: 0 }];
          for (const [e3, r3] of t2) {
            const t3 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + _c, stretch: r2 }), n2;
        }
        function Ic(t2, e2, r2, n2) {
          return t2 / e2 * r2 + n2;
        }
        function zc(t2, e2, r2, n2) {
          return t2 - e2 * r2 / n2;
        }
        class Mc {
          constructor(t2, e2, r2, n2, i2, a2, o2, l2, u2, c2) {
            if (this.boxStartIndex = t2.length, u2) {
              let t3 = a2.top, e3 = a2.bottom;
              const r3 = a2.collisionPadding;
              r3 && (t3 -= r3[1], e3 += r3[3]);
              let n3 = e3 - t3;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              let u3 = a2.top * o2 - l2[0], h2 = a2.bottom * o2 + l2[2], p2 = a2.left * o2 - l2[3], f2 = a2.right * o2 + l2[1];
              const d2 = a2.collisionPadding;
              if (d2 && (p2 -= d2[0] * o2, u3 -= d2[1] * o2, f2 += d2[2] * o2, h2 += d2[3] * o2), c2) {
                const t3 = new s(p2, u3), e3 = new s(f2, u3), r3 = new s(p2, h2), n3 = new s(f2, h2), i3 = c2 * Math.PI / 180;
                t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), u3 = Math.min(t3.y, e3.y, r3.y, n3.y), h2 = Math.max(t3.y, e3.y, r3.y, n3.y);
              }
              t2.emplaceBack(e2.x, e2.y, p2, u3, f2, h2, r2, n2, i2);
            }
            this.boxEndIndex = t2.length;
          }
        }
        class Bc {
          constructor(t2 = [], e2 = Cc) {
            if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
              for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                this._down(t3);
          }
          push(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t2 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
          }
          peek() {
            return this.data[0];
          }
          _up(t2) {
            const { data: e2, compare: r2 } = this, n2 = e2[t2];
            for (; t2 > 0; ) {
              const i2 = t2 - 1 >> 1, s2 = e2[i2];
              if (r2(n2, s2) >= 0)
                break;
              e2[t2] = s2, t2 = i2;
            }
            e2[t2] = n2;
          }
          _down(t2) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
            for (; t2 < n2; ) {
              let n3 = 1 + (t2 << 1), s2 = e2[n3];
              const a2 = n3 + 1;
              if (a2 < this.length && r2(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r2(s2, i2) >= 0)
                break;
              e2[t2] = s2, t2 = n3;
            }
            e2[t2] = i2;
          }
        }
        function Cc(t2, e2) {
          return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
        }
        function Pc(t2, e2 = 1, r2 = false) {
          let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
          const l2 = t2[0];
          for (let t3 = 0; t3 < l2.length; t3++) {
            const e3 = l2[t3];
            (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
          }
          const u2 = Math.min(a2 - n2, o2 - i2);
          let c2 = u2 / 2;
          const h2 = new Bc([], Vc);
          if (0 === u2)
            return new s(n2, i2);
          for (let e3 = n2; e3 < a2; e3 += u2)
            for (let r3 = i2; r3 < o2; r3 += u2)
              h2.push(new Ec(e3 + c2, r3 + c2, c2, t2));
          let p2 = function(t3) {
            let e3 = 0, r3 = 0, n3 = 0;
            const i3 = t3[0];
            for (let t4 = 0, s2 = i3.length, a3 = s2 - 1; t4 < s2; a3 = t4++) {
              const s3 = i3[t4], o3 = i3[a3], l3 = s3.x * o3.y - o3.x * s3.y;
              r3 += (s3.x + o3.x) * l3, n3 += (s3.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new Ec(r3 / e3, n3 / e3, 0, t3);
          }(t2), f2 = h2.length;
          for (; h2.length; ) {
            const n3 = h2.pop();
            (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new Ec(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new Ec(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new Ec(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new Ec(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
          }
          return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
        }
        function Vc(t2, e2) {
          return e2.max - t2.max;
        }
        function Ec(t2, e2, r2, n2) {
          this.p = new s(t2, e2), this.h = r2, this.d = function(t3, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2];
              for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                const i4 = s2[e4], o2 = s2[a2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, la(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        var Fc;
        t.ap = void 0, (Fc = t.ap || (t.ap = {}))[Fc.center = 1] = "center", Fc[Fc.left = 2] = "left", Fc[Fc.right = 3] = "right", Fc[Fc.top = 4] = "top", Fc[Fc.bottom = 5] = "bottom", Fc[Fc["top-left"] = 6] = "top-left", Fc[Fc["top-right"] = 7] = "top-right", Fc[Fc["bottom-left"] = 8] = "bottom-left", Fc[Fc["bottom-right"] = 9] = "bottom-right";
        const Tc = 7, $c = Number.POSITIVE_INFINITY;
        function Dc(t2, e2) {
          return e2[1] !== $c ? function(t3, e3, r2) {
            let n2 = 0, i2 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i2 = r2 - Tc;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i2 = -r2 + Tc;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i2];
          }(t2, e2[0], e2[1]) : function(t3, e3) {
            let r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            const i2 = e3 / Math.SQRT2;
            switch (t3) {
              case "top-right":
              case "top-left":
                n2 = i2 - Tc;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = -i2 + Tc;
                break;
              case "bottom":
                n2 = -e3 + Tc;
                break;
              case "top":
                n2 = e3 - Tc;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                r2 = -i2;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i2;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t2, e2[0]);
        }
        function Lc(t2, e2, r2) {
          var n2;
          const i2 = t2.layout, s2 = null === (n2 = i2.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(e2, {}, r2);
          if (s2) {
            const t3 = s2.values, e3 = [];
            for (let r3 = 0; r3 < t3.length; r3 += 2) {
              const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * Sl);
              n3.startsWith("top") ? i3[1] -= Tc : n3.startsWith("bottom") && (i3[1] += Tc), e3[r3 + 1] = i3;
            }
            return new te(e3);
          }
          const a2 = i2.get("text-variable-anchor");
          if (a2) {
            let n3;
            n3 = void 0 !== t2._unevaluatedLayout.getValue("text-radial-offset") ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * Sl, $c] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * Sl);
            const s3 = [];
            for (const t3 of a2)
              s3.push(t3, Dc(t3, n3));
            return new te(s3);
          }
          return null;
        }
        function Oc(t2) {
          switch (t2) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Rc(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
          let p2 = a2.textMaxSize.evaluate(r2, {});
          void 0 === p2 && (p2 = o2);
          const f2 = e2.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r2, {}, h2), y2 = jc(n2.horizontal), m2 = o2 / 24, g2 = e2.tilePixelRatio * m2, x2 = e2.tilePixelRatio * p2 / 24, v2 = e2.tilePixelRatio * l2, b2 = e2.tilePixelRatio * f2.get("symbol-spacing"), w2 = f2.get("text-padding") * e2.tilePixelRatio, _2 = function(t2, e3, r3, n3 = 1) {
            const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
            return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
          }(f2, r2, h2, e2.tilePixelRatio), S2 = f2.get("text-max-angle") / 180 * Math.PI, k2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), z2 = f2.get("symbol-placement"), M2 = b2 / 2, B2 = f2.get("icon-text-fit");
          let C2;
          i2 && "none" !== B2 && (e2.allowVerticalPlacement && n2.vertical && (C2 = vu(i2, n2.vertical, B2, f2.get("icon-text-fit-padding"), d2, m2)), y2 && (i2 = vu(i2, y2, B2, f2.get("icon-text-fit-padding"), d2, m2)));
          const P2 = (l3, p3) => {
            p3.x < 0 || p3.x >= Js || p3.y < 0 || p3.y >= Js || function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p4, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, S3, k3, I3) {
              const z3 = e3.addToLineVertexArray(r3, n3);
              let M3, B3, C3, P3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, $2 = -1, D2 = -1;
              const L2 = {};
              let O2 = Ms("");
              if (e3.allowVerticalPlacement && i3.vertical) {
                const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3) + 90;
                C3 = new Mc(u3, r3, c3, h3, p4, i3.vertical, f3, d3, y3, t2), o3 && (P3 = new Mc(u3, r3, c3, h3, p4, o3, g3, x3, y3, t2));
              }
              if (s3) {
                const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), a4 = Ac(s3, n4, S3, i4), f4 = o3 ? Ac(o3, n4, S3, i4) : void 0;
                B3 = new Mc(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), V2 = 4 * a4.length;
                const d4 = e3.iconSizeData;
                let y4 = null;
                "source" === d4.kind ? (y4 = [wu * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > _u && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${bu}. Reduce your "icon-size".`)) : "composite" === d4.kind && (y4 = [wu * _3.compositeIconSizes[0].evaluate(w3, {}, k3), wu * _3.compositeIconSizes[1].evaluate(w3, {}, k3)], (y4[0] > _u || y4[1] > _u) && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${bu}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y4, b3, v3, w3, t.ah.none, r3, z3.lineStartIndex, z3.lineLength, -1, k3), $2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v3, w3, t.ah.vertical, r3, z3.lineStartIndex, z3.lineLength, -1, k3), D2 = e3.icon.placedSymbolArray.length - 1);
              }
              const R2 = Object.keys(i3.horizontal);
              for (const n4 of R2) {
                const s4 = i3.horizontal[n4];
                if (!M3) {
                  O2 = Ms(s4.text);
                  const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3);
                  M3 = new Mc(u3, r3, c3, h3, p4, s4, f3, d3, y3, t2);
                }
                const o4 = 1 === s4.positionedLines.length;
                if (F2 += Uc(e3, r3, s4, a3, l4, y3, w3, m3, z3, i3.vertical ? t.ah.horizontal : t.ah.horizontalOnly, o4 ? R2 : [n4], L2, $2, _3, k3), o4)
                  break;
              }
              i3.vertical && (T2 += Uc(e3, r3, i3.vertical, a3, l4, y3, w3, m3, z3, t.ah.vertical, ["vertical"], L2, D2, _3, k3));
              const U2 = M3 ? M3.boxStartIndex : e3.collisionBoxArray.length, j2 = M3 ? M3.boxEndIndex : e3.collisionBoxArray.length, q2 = C3 ? C3.boxStartIndex : e3.collisionBoxArray.length, N2 = C3 ? C3.boxEndIndex : e3.collisionBoxArray.length, Z2 = B3 ? B3.boxStartIndex : e3.collisionBoxArray.length, K2 = B3 ? B3.boxEndIndex : e3.collisionBoxArray.length, G2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, J2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length;
              let X2 = -1;
              const H2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
              X2 = H2(M3, X2), X2 = H2(C3, X2), X2 = H2(B3, X2), X2 = H2(P3, X2);
              const Y2 = X2 > -1 ? 1 : 0;
              Y2 && (X2 *= I3 / Sl), e3.glyphOffsetArray.length >= Vu.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w3.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
              const W2 = Lc(l4, w3, k3), [Q2, tt2] = function(e4, r4) {
                const n4 = e4.length, i4 = null == r4 ? void 0 : r4.values;
                if ((null == i4 ? void 0 : i4.length) > 0)
                  for (let r5 = 0; r5 < i4.length; r5 += 2) {
                    const n5 = i4[r5 + 1];
                    e4.emplaceBack(t.ap[i4[r5]], n5[0], n5[1]);
                  }
                return [n4, e4.length];
              }(e3.textAnchorOffsets, W2);
              e3.symbolInstances.emplaceBack(r3.x, r3.y, L2.right >= 0 ? L2.right : -1, L2.center >= 0 ? L2.center : -1, L2.left >= 0 ? L2.left : -1, L2.vertical || -1, $2, D2, O2, U2, j2, q2, N2, Z2, K2, G2, J2, c3, F2, T2, V2, E2, Y2, 0, f3, X2, Q2, tt2);
            }(e2, p3, l3, n2, i2, s2, C2, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, g2, [w2, w2, w2, w2], k2, u2, v2, _2, I2, d2, r2, a2, c2, h2, o2);
          };
          if ("line" === z2)
            for (const t2 of fc(r2.geometry, 0, 0, Js, Js)) {
              const r3 = bc(t2, b2, S2, n2.vertical || y2, i2, 24, x2, e2.overscaling, Js);
              for (const n3 of r3)
                y2 && qc(e2, y2.text, M2, n3) || P2(t2, n3);
            }
          else if ("line-center" === z2) {
            for (const t2 of r2.geometry)
              if (t2.length > 1) {
                const e3 = vc(t2, S2, n2.vertical || y2, i2, 24, x2);
                e3 && P2(t2, e3);
              }
          } else if ("Polygon" === r2.type)
            for (const t2 of wo(r2.geometry, 0)) {
              const e3 = Pc(t2, 16);
              P2(t2[0], new dc(e3.x, e3.y, 0));
            }
          else if ("LineString" === r2.type)
            for (const t2 of r2.geometry)
              P2(t2, new dc(t2[0].x, t2[0].y, 0));
          else if ("Point" === r2.type)
            for (const t2 of r2.geometry)
              for (const e3 of t2)
                P2([e3], new dc(e3.x, e3.y, 0));
        }
        function Uc(t2, e2, r2, n2, i2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2) {
          const m2 = function(t3, e3, r3, n3, i3, a3, o3, l3) {
            const u3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, c3 = [];
            for (const t4 of e3.positionedLines)
              for (const n4 of t4.positionedGlyphs) {
                if (!n4.rect)
                  continue;
                const a4 = n4.rect || {};
                let h3 = Wl + 1, p3 = true, f3 = 1, d3 = 0;
                const y3 = (i3 || l3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
                if (l3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(Sl - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * Sl)), n4.imageName) {
                  const t5 = o3[n4.imageName];
                  p3 = t5.sdf, f3 = t5.pixelRatio, h3 = tu / f3;
                }
                const g3 = i3 ? [n4.x + m3, n4.y] : [0, 0];
                let x3 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
                y3 && (v2 = x3, x3 = [0, 0]);
                const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x3[0], _2 = (-n4.metrics.top - h3) * n4.scale + x3[1], A2 = w2 + a4.w / b2 * n4.scale / f3, S2 = _2 + a4.h / b2 * n4.scale / f3, k2 = new s(w2, _2), I2 = new s(A2, _2), z2 = new s(w2, S2), M2 = new s(A2, S2);
                if (y3) {
                  const t5 = new s(-m3, m3 - iu), e4 = -Math.PI / 2, r4 = Sl / 2 - m3, i4 = new s(5 - iu - r4, -(n4.imageName ? r4 : 0)), a5 = new s(...v2);
                  k2._rotateAround(e4, t5)._add(i4)._add(a5), I2._rotateAround(e4, t5)._add(i4)._add(a5), z2._rotateAround(e4, t5)._add(i4)._add(a5), M2._rotateAround(e4, t5)._add(i4)._add(a5);
                }
                if (u3) {
                  const t5 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t5, t5, e4];
                  k2._matMult(r4), I2._matMult(r4), z2._matMult(r4), M2._matMult(r4);
                }
                const B2 = new s(0, 0), C2 = new s(0, 0);
                c3.push({ tl: k2, tr: I2, bl: z2, br: M2, tex: a4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: B2, pixelOffsetBR: C2, minFontScaleX: 0, minFontScaleY: 0 });
              }
            return c3;
          }(0, r2, l2, i2, a2, o2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
          let x2 = null;
          "source" === g2.kind ? (x2 = [wu * i2.layout.get("text-size").evaluate(o2, {})], x2[0] > _u && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${bu}. Reduce your "text-size".`)) : "composite" === g2.kind && (x2 = [wu * d2.compositeTextSizes[0].evaluate(o2, {}, y2), wu * d2.compositeTextSizes[1].evaluate(o2, {}, y2)], (x2[0] > _u || x2[1] > _u) && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${bu}. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, l2, a2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y2);
          for (const e3 of h2)
            p2[e3] = t2.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function jc(t2) {
          for (const e2 in t2)
            return t2[e2];
          return null;
        }
        function qc(t2, e2, r2, n2) {
          const i2 = t2.compareText;
          if (e2 in i2) {
            const t3 = i2[e2];
            for (let e3 = t3.length - 1; e3 >= 0; e3--)
              if (n2.dist(t3[e3]) < r2)
                return true;
          } else
            i2[e2] = [];
          return i2[e2].push(n2), false;
        }
        const Nc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Zc {
          static from(t2) {
            if (!(t2 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t2, 0, 2);
            if (219 !== e2)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n2 = r2 >> 4;
            if (1 !== n2)
              throw new Error(`Got v${n2} data when expected v1.`);
            const i2 = Nc[15 & r2];
            if (!i2)
              throw new Error("Unrecognized array type.");
            const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
            return new Zc(a2, s2, i2, t2);
          }
          constructor(t2, e2 = 64, r2 = Float64Array, n2) {
            if (isNaN(t2) || t2 < 0)
              throw new Error(`Unpexpected numItems value: ${t2}.`);
            this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
            const i2 = Nc.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
            if (i2 < 0)
              throw new Error(`Unexpected typed array class: ${r2}.`);
            n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
          }
          add(t2, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t2 = this._pos >> 1;
            if (t2 !== this.numItems)
              throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
            return Kc(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t2, e2, r2, n2) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
            for (; o2.length; ) {
              const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
              if (c2 - h2 <= a2) {
                for (let a3 = h2; a3 <= c2; a3++) {
                  const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                  o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
                }
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
              f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
            }
            return l2;
          }
          within(t2, e2, r2) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
            for (; a2.length; ) {
              const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
              if (c2 - h2 <= s2) {
                for (let r3 = h2; r3 <= c2; r3++)
                  Hc(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
              Hc(f2, d2, t2, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
            }
            return o2;
          }
        }
        function Kc(t2, e2, r2, n2, i2, s2) {
          if (i2 - n2 <= r2)
            return;
          const a2 = n2 + i2 >> 1;
          Gc(t2, e2, a2, n2, i2, s2), Kc(t2, e2, r2, n2, a2 - 1, 1 - s2), Kc(t2, e2, r2, a2 + 1, i2, 1 - s2);
        }
        function Gc(t2, e2, r2, n2, i2, s2) {
          for (; i2 > n2; ) {
            if (i2 - n2 > 600) {
              const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
              Gc(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
            }
            const a2 = e2[2 * r2 + s2];
            let o2 = n2, l2 = i2;
            for (Jc(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && Jc(t2, e2, n2, i2); o2 < l2; ) {
              for (Jc(t2, e2, o2, l2), o2++, l2--; e2[2 * o2 + s2] < a2; )
                o2++;
              for (; e2[2 * l2 + s2] > a2; )
                l2--;
            }
            e2[2 * n2 + s2] === a2 ? Jc(t2, e2, n2, l2) : (l2++, Jc(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
          }
        }
        function Jc(t2, e2, r2, n2) {
          Xc(t2, r2, n2), Xc(e2, 2 * r2, 2 * n2), Xc(e2, 2 * r2 + 1, 2 * n2 + 1);
        }
        function Xc(t2, e2, r2) {
          const n2 = t2[e2];
          t2[e2] = t2[r2], t2[r2] = n2;
        }
        function Hc(t2, e2, r2, n2) {
          const i2 = t2 - r2, s2 = e2 - n2;
          return i2 * i2 + s2 * s2;
        }
        var Yc;
        t.bd = void 0, (Yc = t.bd || (t.bd = {})).create = "create", Yc.load = "load", Yc.fullLoad = "fullLoad";
        let Wc = null, Qc = [];
        const th = 1e3 / 60, eh = "loadTime", rh = "fullLoadTime", nh = { mark(t2) {
          performance.mark(t2);
        }, frame(t2) {
          const e2 = t2;
          null != Wc && Qc.push(e2 - Wc), Wc = e2;
        }, clearMetrics() {
          Wc = null, Qc = [], performance.clearMeasures(eh), performance.clearMeasures(rh);
          for (const e2 in t.bd)
            performance.clearMarks(t.bd[e2]);
        }, getPerformanceMetrics() {
          performance.measure(eh, t.bd.create, t.bd.load), performance.measure(rh, t.bd.create, t.bd.fullLoad);
          const e2 = performance.getEntriesByName(eh)[0].duration, r2 = performance.getEntriesByName(rh)[0].duration, n2 = Qc.length, i2 = 1 / (Qc.reduce((t2, e3) => t2 + e3, 0) / n2 / 1e3), s2 = Qc.filter((t2) => t2 > th).reduce((t2, e3) => t2 + (e3 - th) / th, 0);
          return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
        } };
        t.$ = vs, t.A = va, t.B = function(t2) {
          if (null == z) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            z = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return z;
        }, t.C = class {
          constructor(t2, e2) {
            this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Zu(() => this.process()), this.subscription = function(t3, e3, r2, n2) {
              return t3.addEventListener(e3, r2, false), { unsubscribe: () => {
                t3.removeEventListener(e3, r2, false);
              } };
            }(this.target, "message", (t3) => this.receive(t3)), this.globalScope = I(self) ? t2 : window;
          }
          registerMessageHandler(t2, e2) {
            this.messageHandlers[t2] = e2;
          }
          sendAsync(t2, e2) {
            return new Promise((r2, n2) => {
              const i2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              this.resolveRejects[i2] = { resolve: r2, reject: n2 }, e2 && e2.signal.addEventListener("abort", () => {
                delete this.resolveRejects[i2];
                const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(e3);
              }, { once: true });
              const s2 = [], a2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: Un(t2.data, s2) });
              this.target.postMessage(a2, { transfer: s2 });
            });
          }
          receive(t2) {
            const e2 = t2.data, r2 = e2.id;
            if (!("file://" !== e2.origin && "file://" !== location.origin && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
              if ("<cancel>" === e2.type) {
                delete this.tasks[r2];
                const t3 = this.abortControllers[r2];
                return delete this.abortControllers[r2], void (t3 && t3.abort());
              }
              if (I(self) || e2.mustQueue)
                return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
              this.processTask(r2, e2);
            }
          }
          process() {
            if (0 === this.taskQueue.length)
              return;
            const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
            delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
          }
          processTask(t2, r2) {
            return e(this, void 0, void 0, function* () {
              if ("<response>" === r2.type) {
                const e3 = this.resolveRejects[t2];
                if (delete this.resolveRejects[t2], !e3)
                  return;
                return void (r2.error ? e3.reject(jn(r2.error)) : e3.resolve(jn(r2.data)));
              }
              if (!this.messageHandlers[r2.type])
                return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const e2 = jn(r2.data), n2 = new AbortController();
              this.abortControllers[t2] = n2;
              try {
                const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
                this.completeTask(t2, null, i2);
              } catch (e3) {
                this.completeTask(t2, e3);
              }
            });
          }
          completeTask(t2, e2, r2) {
            const n2 = [];
            delete this.abortControllers[t2];
            const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? Un(e2) : null, data: Un(r2, n2) };
            this.target.postMessage(i2, { transfer: n2 });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, t.D = ui, t.E = K, t.F = function() {
          var t2 = new va(16);
          return va != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }, t.G = D, t.H = function(t2, e2, r2) {
          var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
          return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
        }, t.I = eu, t.J = function(t2, e2, r2) {
          var n2 = r2[0], i2 = r2[1], s2 = r2[2];
          return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.K = wa, t.L = function(t2, e2) {
          const r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            i2 in t2 && (r2[i2] = t2[i2]);
          }
          return r2;
        }, t.M = Gu, t.N = Hu, t.O = Yu, t.P = s, t.Q = ic, t.R = Fa, t.S = h, t.T = ni, t.U = p, t.V = C, t.W = Js, t.X = bi, t.Y = tc, t.Z = class extends Si {
        }, t._ = e, t.a = T, t.a$ = function(t2, e2, r2) {
          return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
        }, t.a0 = rc, t.a1 = st, t.a2 = (t2) => {
          const e2 = window.document.createElement("video");
          return e2.muted = true, new Promise((r2) => {
            e2.onloadstart = () => {
              r2(e2);
            };
            for (const r3 of t2) {
              const t3 = window.document.createElement("source");
              U(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
            }
          });
        }, t.a3 = function() {
          return x++;
        }, t.a4 = Ki, t.a5 = Vu, t.a6 = Kr, t.a7 = Ws, t.a8 = ti, t.a9 = lc, t.aA = w, t.aB = function(t2, e2) {
          if (!t2)
            return [{ command: "setStyle", args: [e2] }];
          let r2 = [];
          try {
            if (!H(t2.version, e2.version))
              return [{ command: "setStyle", args: [e2] }];
            H(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), H(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), H(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), H(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), H(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), H(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), H(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), H(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), H(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), H(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] });
            const n2 = {}, i2 = [];
            !function(t3, e3, r3, n3) {
              let i3;
              for (i3 in e3 = e3 || {}, t3 = t3 || {})
                Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || Q(i3, r3, n3));
              for (i3 in e3)
                Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? H(t3[i3], e3[i3]) || ("geojson" === t3[i3].type && "geojson" === e3[i3].type && et(t3, e3, i3) ? Y(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : tt(i3, e3, r3, n3)) : W(i3, e3, r3));
            }(t2.sources, e2.sources, i2, n2);
            const s2 = [];
            t2.layers && t2.layers.forEach((t3) => {
              "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
            }), r2 = r2.concat(i2), function(t3, e3, r3) {
              e3 = e3 || [];
              const n3 = (t3 = t3 || []).map(nt), i3 = e3.map(nt), s3 = t3.reduce(it, {}), a2 = e3.reduce(it, {}), o2 = n3.slice(), l2 = /* @__PURE__ */ Object.create(null);
              let u2, c2, h2, p2, f2;
              for (let t4 = 0, e4 = 0; t4 < n3.length; t4++)
                u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
              for (let t4 = 0, e4 = 0; t4 < i3.length; t4++)
                u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], Y(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l2[u2] = true);
              for (let t4 = 0; t4 < i3.length; t4++)
                if (u2 = i3[t4], c2 = s3[u2], h2 = a2[u2], !l2[u2] && !H(c2, h2))
                  if (H(c2.source, h2.source) && H(c2["source-layer"], h2["source-layer"]) && H(c2.type, h2.type)) {
                    for (f2 in rt(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), rt(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), H(c2.filter, h2.filter) || Y(r3, { command: "setFilter", args: [u2, h2.filter] }), H(c2.minzoom, h2.minzoom) && H(c2.maxzoom, h2.maxzoom) || Y(r3, { command: "setLayerZoomRange", args: [u2, h2.minzoom, h2.maxzoom] }), c2)
                      Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? rt(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                    for (f2 in h2)
                      Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? rt(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                  } else
                    Y(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], Y(r3, { command: "addLayer", args: [h2, p2] });
            }(s2, e2.layers, r2);
          } catch (t3) {
            console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
          }
          return r2;
        }, t.aC = function(t2) {
          const e2 = [], r2 = t2.id;
          return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.aD = function t2(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length)
              return false;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (!t2(e2[n2], r2[n2]))
                return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2)
              return false;
            if (Object.keys(e2).length !== Object.keys(r2).length)
              return false;
            for (const n2 in e2)
              if (!t2(e2[n2], r2[n2]))
                return false;
            return true;
          }
          return e2 === r2;
        }, t.aE = v, t.aF = b, t.aG = class extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = 0;
          }
          set(t2) {
            this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
          }
        }, t.aH = Fs, t.aI = class extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = Ds;
          }
          set(t2) {
            if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
              return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
            for (let e2 = 1; e2 < 16; e2++)
              if (t2[e2] !== this.current[e2]) {
                this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                break;
              }
          }
        }, t.aJ = Ts, t.aK = class extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
          }
        }, t.aL = class extends Es {
          constructor(t2, e2) {
            super(t2, e2), this.current = [0, 0];
          }
          set(t2) {
            t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
          }
        }, t.aM = $s, t.aN = function(t2, e2, r2, n2, i2, s2, a2) {
          var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
          return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
        }, t.aO = Jt, t.aP = Aa, t.aQ = class extends Fi {
        }, t.aR = wl, t.aS = class extends $i {
        }, t.aT = function(t2) {
          return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
        }, t.aU = Ta, t.aV = ns, t.aW = class extends qi {
        }, t.aX = ys, t.aY = function(t2, e2) {
          return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
        }, t.aZ = function(t2, e2) {
          var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A2 = e2[5], S2 = e2[6], k2 = e2[7], I2 = e2[8], z2 = e2[9], M2 = e2[10], B2 = e2[11], C2 = e2[12], P2 = e2[13], V2 = e2[14], E2 = e2[15];
          return Math.abs(r2 - x2) <= xa * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= xa * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= xa * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - w2) <= xa * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a2 - _2) <= xa * Math.max(1, Math.abs(a2), Math.abs(_2)) && Math.abs(o2 - A2) <= xa * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - S2) <= xa * Math.max(1, Math.abs(l2), Math.abs(S2)) && Math.abs(u2 - k2) <= xa * Math.max(1, Math.abs(u2), Math.abs(k2)) && Math.abs(c2 - I2) <= xa * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h2 - z2) <= xa * Math.max(1, Math.abs(h2), Math.abs(z2)) && Math.abs(p2 - M2) <= xa * Math.max(1, Math.abs(p2), Math.abs(M2)) && Math.abs(f2 - B2) <= xa * Math.max(1, Math.abs(f2), Math.abs(B2)) && Math.abs(d2 - C2) <= xa * Math.max(1, Math.abs(d2), Math.abs(C2)) && Math.abs(y2 - P2) <= xa * Math.max(1, Math.abs(y2), Math.abs(P2)) && Math.abs(m2 - V2) <= xa * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= xa * Math.max(1, Math.abs(g2), Math.abs(E2));
        }, t.a_ = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
        }, t.aa = function(t2) {
          const e2 = {};
          if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
            const s2 = n2 || i2;
            return e2[r2] = !s2 || s2.toLowerCase(), "";
          }), e2["max-age"]) {
            const t3 = parseInt(e2["max-age"], 10);
            isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
          }
          return e2;
        }, t.ab = function(t2, e2) {
          const r2 = [];
          for (const n2 in t2)
            n2 in e2 || r2.push(n2);
          return r2;
        }, t.ac = y, t.ad = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
        }, t.ae = function(t2) {
          var e2 = new va(16);
          return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
        }, t.af = Sa, t.ag = function(t2, e2) {
          let r2 = 0, n2 = 0;
          if ("constant" === t2.kind)
            n2 = t2.layoutSize;
          else if ("source" !== t2.kind) {
            const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y(Je.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
            "camera" === t2.kind ? n2 = Ge.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.ai = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
          return "source" === t2.kind ? n2 / wu : "composite" === t2.kind ? Ge.number(n2 / wu, i2 / wu, r2) : e2;
        }, t.aj = Mu, t.ak = function(t2, e2, r2, n2) {
          const i2 = e2.y - t2.y, a2 = e2.x - t2.x, o2 = n2.y - r2.y, l2 = n2.x - r2.x, u2 = o2 * a2 - l2 * i2;
          if (0 === u2)
            return null;
          const c2 = (l2 * (t2.y - r2.y) - o2 * (t2.x - r2.x)) / u2;
          return new s(t2.x + c2 * a2, t2.y + c2 * i2);
        }, t.al = fc, t.am = ea, t.an = ba, t.ao = Sl, t.aq = Su, t.ar = function(t2, e2) {
          var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, z2 = h2 * m2 - p2 * y2, M2 = h2 * g2 - f2 * y2, B2 = p2 * g2 - f2 * m2, C2 = x2 * B2 - v2 * M2 + b2 * z2 + w2 * I2 - _2 * k2 + A2 * S2;
          return C2 ? (t2[0] = (o2 * B2 - l2 * M2 + u2 * z2) * (C2 = 1 / C2), t2[1] = (i2 * M2 - n2 * B2 - s2 * z2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * I2 - a2 * B2 - u2 * k2) * C2, t2[5] = (r2 * B2 - i2 * I2 + s2 * k2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (a2 * M2 - o2 * I2 + u2 * S2) * C2, t2[9] = (n2 * I2 - r2 * M2 - s2 * S2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * k2 - a2 * z2 - l2 * S2) * C2, t2[13] = (r2 * z2 - n2 * k2 + i2 * S2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
        }, t.as = Oc, t.at = mu, t.au = Zc, t.av = function() {
          const t2 = {}, e2 = G.$version;
          for (const r2 in G.$root) {
            const n2 = G.$root[r2];
            if (n2.required) {
              let i2 = null;
              i2 = "version" === r2 ? e2 : "array" === n2.type ? [] : {}, null != i2 && (t2[r2] = i2);
            }
          }
          return t2;
        }, t.aw = qn, t.ax = O, t.ay = function(t2) {
          t2 = t2.slice();
          const e2 = /* @__PURE__ */ Object.create(null);
          for (let r2 = 0; r2 < t2.length; r2++)
            e2[t2[r2].id] = t2[r2];
          for (let r2 = 0; r2 < t2.length; r2++)
            "ref" in t2[r2] && (t2[r2] = X(t2[r2], e2[t2[r2].ref]));
          return t2;
        }, t.az = function(t2) {
          if ("custom" === t2.type)
            return new Nu(t2);
          switch (t2.type) {
            case "background":
              return new Ru(t2);
            case "circle":
              return new ka(t2);
            case "fill":
              return new Bo(t2);
            case "fill-extrusion":
              return new Qo(t2);
            case "heatmap":
              return new $a(t2);
            case "hillshade":
              return new Oa(t2);
            case "line":
              return new yl(t2);
            case "raster":
              return new qu(t2);
            case "symbol":
              return new Du(t2);
          }
        }, t.b = M, t.b0 = function(t2, e2) {
          return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
        }, t.b1 = m, t.b2 = nc, t.b3 = Wu, t.b4 = function(t2, e2, r2, n2, i2) {
          var s2, a2 = 1 / Math.tan(e2 / 2);
          return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
        }, t.b5 = function(t2, e2, r2) {
          var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
        }, t.b6 = f, t.b7 = d, t.b8 = function(t2) {
          return t2 * Math.PI / 180;
        }, t.b9 = function(t2, e2) {
          return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
        }, t.bA = Qn, t.ba = class extends Ai {
        }, t.bb = Ku, t.bc = nh, t.be = L, t.bf = function(t2, e2) {
          T.REGISTERED_PROTOCOLS[t2] = e2;
        }, t.bg = function(t2) {
          delete T.REGISTERED_PROTOCOLS[t2];
        }, t.bh = function(t2, e2) {
          const r2 = {};
          for (let n3 = 0; n3 < t2.length; n3++) {
            const i2 = e2 && e2[t2[n3].id] || en(t2[n3]);
            e2 && (e2[t2[n3].id] = i2);
            let s2 = r2[i2];
            s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
          }
          const n2 = [];
          for (const t3 in r2)
            n2.push(r2[t3]);
          return n2;
        }, t.bi = On, t.bj = oc, t.bk = uc, t.bl = ru, t.bm = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = Js / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
          const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new ti(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new ti(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new ti(18)) };
          if ("composite" === e2.bucket.textSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
            s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new ti(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new ti(r3), e2.canonical)];
          }
          if ("composite" === e2.bucket.iconSizeData.kind) {
            const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
            s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new ti(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new ti(r3), e2.canonical)];
          }
          const a2 = n2.get("text-line-height") * Sl, o2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
          for (const i3 of e2.bucket.features) {
            const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y2 = i3.text;
            let m2, g2 = [0, 0];
            if (y2) {
              const s3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * Sl, f3 = Kn(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = Lc(r2, i3, e2.canonical);
              if (!x3) {
                const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
                g2 = t2 ? Dc(m3, [t2 * Sl, $c]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * Sl);
              }
              let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
              const b2 = n2.get("symbol-placement"), w2 = "point" === b2 ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * Sl : 0, _2 = () => {
                e2.bucket.allowVerticalPlacement && Zn(s3) && (d2.vertical = ou(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, a2, m3, "left", f3, g2, t.ah.vertical, true, b2, p2, h2));
              };
              if (!o2 && x3) {
                const r3 = /* @__PURE__ */ new Set();
                if ("auto" === v3)
                  for (let t2 = 0; t2 < x3.values.length; t2 += 2)
                    r3.add(Oc(x3.values[t2]));
                else
                  r3.add(v3);
                let n3 = false;
                for (const i4 of r3)
                  if (!d2.horizontal[i4])
                    if (n3)
                      d2.horizontal[i4] = d2.horizontal[0];
                    else {
                      const r4 = ou(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, a2, "center", i4, f3, g2, t.ah.horizontal, false, b2, p2, h2);
                      r4 && (d2.horizontal[i4] = r4, n3 = 1 === r4.positionedLines.length);
                    }
                _2();
              } else {
                "auto" === v3 && (v3 = Oc(m3));
                const r3 = ou(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, a2, m3, v3, f3, g2, t.ah.horizontal, false, b2, p2, h2);
                r3 && (d2.horizontal[v3] = r3), _2(), Zn(s3) && o2 && l2 && (d2.vertical = ou(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, a2, m3, v3, f3, g2, t.ah.vertical, false, b2, p2, h2));
              }
            }
            let x2 = false;
            if (i3.icon && i3.icon.name) {
              const t2 = e2.imageMap[i3.icon.name];
              t2 && (m2 = xu(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
            }
            const v2 = jc(d2.horizontal) || d2.vertical;
            e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && Rc(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g2, x2, e2.canonical);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t.bn = ul, t.bo = ko, t.bp = Jo, t.bq = Eo, t.br = Gl, t.bs = class {
          constructor(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t2 = performance.getEntriesByName(this._marks.measure);
            return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
          }
        }, t.bt = function(t2, r2, n2, i2, s2) {
          return e(this, void 0, void 0, function* () {
            if (p())
              try {
                return yield C(t2, r2, n2, i2, s2);
              } catch (t3) {
              }
            return function(t3, e2, r3, n3, i3) {
              const s3 = t3.width, a2 = t3.height;
              P && V || (P = new OffscreenCanvas(s3, a2), V = P.getContext("2d", { willReadFrequently: true })), P.width = s3, P.height = a2, V.drawImage(t3, 0, 0, s3, a2);
              const o2 = V.getImageData(e2, r3, n3, i3);
              return V.clearRect(0, 0, s3, a2), o2.data;
            }(t2, r2, n2, i2, s2);
          });
        }, t.bu = ac, t.bv = r, t.bw = n, t.bx = kl, t.by = Lr, t.bz = function(t2) {
          return t2.message === E;
        }, t.c = F, t.d = (t2) => e(void 0, void 0, void 0, function* () {
          if (0 === t2.byteLength)
            return createImageBitmap(new ImageData(1, 1));
          const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          try {
            return createImageBitmap(e2);
          } catch (t3) {
            throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), t.e = g, t.f = (t2) => new Promise((e2, r2) => {
          const n2 = new Image();
          n2.onload = () => {
            e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
              n2.src = B;
            });
          }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
          n2.src = t2.byteLength ? URL.createObjectURL(i2) : B;
        }), t.g = $, t.h = (t2, e2) => R(g(t2, { type: "json" }), e2), t.i = I, t.j = Z, t.k = N, t.l = (t2, e2) => R(g(t2, { type: "arrayBuffer" }), e2), t.m = R, t.n = function(t2) {
          return new Gl(t2).readFields(Xl, []);
        }, t.o = Ea, t.p = Ql, t.q = di, t.r = En, t.s = U, t.t = $n, t.u = Nn, t.v = G, t.w = A, t.x = Vn, t.y = function([t2, e2, r2]) {
          return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
        }, t.z = Ge;
      });
      define2("worker", ["./shared"], function(e) {
        "use strict";
        class t {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t2, r2) {
            for (const r3 of t2) {
              this._layerConfigs[r3.id] = r3;
              const t3 = this._layers[r3.id] = e.az(r3);
              t3._featureFilter = e.a6(t3.filter), this.keyCache[r3.id] && delete this.keyCache[r3.id];
            }
            for (const e2 of r2)
              delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const i2 = e.bh(Object.values(this._layerConfigs), this.keyCache);
            for (const e2 of i2) {
              const t3 = e2.map((e3) => this._layers[e3.id]), r3 = t3[0];
              if ("none" === r3.visibility)
                continue;
              const i3 = r3.source || "";
              let o2 = this.familiesBySource[i3];
              o2 || (o2 = this.familiesBySource[i3] = {});
              const s2 = r3.sourceLayer || "_geojsonTileLayer";
              let n2 = o2[s2];
              n2 || (n2 = o2[s2] = []), n2.push(t3);
            }
          }
        }
        class r {
          constructor(t2) {
            const r2 = {}, i2 = [];
            for (const e2 in t2) {
              const o3 = t2[e2], s3 = r2[e2] = {};
              for (const e3 in o3) {
                const t3 = o3[+e3];
                if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                  continue;
                const r3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                i2.push(r3), s3[e3] = { rect: r3, metrics: t3.metrics };
              }
            }
            const { w: o2, h: s2 } = e.p(i2), n2 = new e.o({ width: o2 || 1, height: s2 || 1 });
            for (const i3 in t2) {
              const o3 = t2[i3];
              for (const t3 in o3) {
                const s3 = o3[+t3];
                if (!s3 || 0 === s3.bitmap.width || 0 === s3.bitmap.height)
                  continue;
                const a2 = r2[i3][t3].rect;
                e.o.copy(s3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, s3.bitmap);
              }
            }
            this.image = n2, this.positions = r2;
          }
        }
        e.bi("GlyphAtlas", r);
        class i {
          constructor(t2) {
            this.tileID = new e.Q(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
          }
          parse(t2, i2, s2, n2) {
            return e._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a4();
              const a2 = new e.bj(Object.keys(t2.layers).sort()), l2 = new e.bk(this.tileID, this.promoteId);
              l2.bucketLayerIDs = [];
              const h2 = {}, u2 = { featureIndex: l2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s2 }, c2 = i2.familiesBySource[this.source];
              for (const r2 in c2) {
                const i3 = t2.layers[r2];
                if (!i3)
                  continue;
                1 === i3.version && e.w(`Vector tile source "${this.source}" layer "${r2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n3 = a2.encode(r2), d3 = [];
                for (let e2 = 0; e2 < i3.length; e2++) {
                  const t3 = i3.feature(e2), o2 = l2.getId(t3, r2);
                  d3.push({ feature: t3, id: o2, index: e2, sourceLayerIndex: n3 });
                }
                for (const t3 of c2[r2]) {
                  const r3 = t3[0];
                  r3.source !== this.source && e.w(`layer.source = ${r3.source} does not equal this.source = ${this.source}`), r3.minzoom && this.zoom < Math.floor(r3.minzoom) || r3.maxzoom && this.zoom >= r3.maxzoom || "none" !== r3.visibility && (o(t3, this.zoom, s2), (h2[r3.id] = r3.createBucket({ index: l2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(d3, u2, this.tileID.canonical), l2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
                }
              }
              const d2 = e.aE(u2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
              this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.abort()), this.inFlightDependencies = [];
              let f2 = Promise.resolve({});
              if (Object.keys(d2).length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), f2 = n2.sendAsync({ type: "GG", data: { stacks: d2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
              }
              const p2 = Object.keys(u2.iconDependencies);
              let g2 = Promise.resolve({});
              if (p2.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), g2 = n2.sendAsync({ type: "GI", data: { icons: p2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
              }
              const m2 = Object.keys(u2.patternDependencies);
              let v2 = Promise.resolve({});
              if (m2.length) {
                const e2 = new AbortController();
                this.inFlightDependencies.push(e2), v2 = n2.sendAsync({ type: "GI", data: { icons: m2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
              }
              const [y2, w2, x2] = yield Promise.all([f2, g2, v2]), b2 = new r(y2), S2 = new e.bl(w2, x2);
              for (const t3 in h2) {
                const r2 = h2[t3];
                r2 instanceof e.a5 ? (o(r2.layers, this.zoom, s2), e.bm({ bucket: r2, glyphMap: y2, glyphPositions: b2.positions, imageMap: w2, imagePositions: S2.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : r2.hasPattern && (r2 instanceof e.bn || r2 instanceof e.bo || r2 instanceof e.bp) && (o(r2.layers, this.zoom, s2), r2.addFeatures(u2, this.tileID.canonical, S2.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(h2).filter((e2) => !e2.isEmpty()), featureIndex: l2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b2.image, imageAtlas: S2, glyphMap: this.returnDependencies ? y2 : null, iconMap: this.returnDependencies ? w2 : null, glyphPositions: this.returnDependencies ? b2.positions : null };
            });
          }
        }
        function o(t2, r2, i2) {
          const o2 = new e.a8(r2);
          for (const e2 of t2)
            e2.recalculate(o2, i2);
        }
        class s {
          constructor(e2, t2, r2) {
            this.actor = e2, this.layerIndex = t2, this.availableImages = r2, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(t2, r2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = yield e.l(t2.request, r2);
              try {
                return { vectorTile: new e.bq.VectorTile(new e.br(i2.data)), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
              } catch (e2) {
                const r3 = new Uint8Array(i2.data);
                let o2 = `Unable to parse the tile at ${t2.request.url}, `;
                throw o2 += 31 === r3[0] && 139 === r3[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.messge}`, new Error(o2);
              }
            });
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const r2 = t2.uid, o2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bs(t2.request), s2 = new i(t2);
              this.loading[r2] = s2;
              const n2 = new AbortController();
              s2.abort = n2;
              try {
                const i2 = yield this.loadVectorTile(t2, n2);
                if (delete this.loading[r2], !i2)
                  return null;
                const a2 = i2.rawData, l2 = {};
                i2.expires && (l2.expires = i2.expires), i2.cacheControl && (l2.cacheControl = i2.cacheControl);
                const h2 = {};
                if (o2) {
                  const e2 = o2.finish();
                  e2 && (h2.resourceTiming = JSON.parse(JSON.stringify(e2)));
                }
                s2.vectorTile = i2.vectorTile;
                const u2 = s2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
                this.loaded[r2] = s2, this.fetching[r2] = { rawTileData: a2, cacheControl: l2, resourceTiming: h2 };
                try {
                  const t3 = yield u2;
                  return e.e({ rawTileData: a2.slice(0) }, t3, l2, h2);
                } finally {
                  delete this.fetching[r2];
                }
              } catch (e2) {
                throw delete this.loading[r2], s2.status = "done", this.loaded[r2] = s2, e2;
              }
            });
          }
          reloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const r2 = t2.uid;
              if (!this.loaded || !this.loaded[r2])
                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const i2 = this.loaded[r2];
              if (i2.showCollisionBoxes = t2.showCollisionBoxes, "parsing" === i2.status) {
                const t3 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
                let o2;
                if (this.fetching[r2]) {
                  const { rawTileData: i3, cacheControl: s2, resourceTiming: n2 } = this.fetching[r2];
                  delete this.fetching[r2], o2 = e.e({ rawTileData: i3.slice(0) }, t3, s2, n2);
                } else
                  o2 = t3;
                return o2;
              }
              if ("done" === i2.status && i2.vectorTile)
                return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = this.loading, r2 = t2.uid;
              e2 && e2[r2] && e2[r2].abort && (e2[r2].abort.abort(), delete e2[r2]);
            });
          }
          removeTile(t2) {
            return e._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
            });
          }
        }
        class n {
          constructor() {
            this.loaded = {};
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const { uid: r2, encoding: i2, rawImageData: o2, redFactor: s2, greenFactor: n2, blueFactor: a2, baseShift: l2 } = t2, h2 = o2.width + 2, u2 = o2.height + 2, c2 = e.b(o2) ? new e.R({ width: h2, height: u2 }, yield e.bt(o2, -1, -1, h2, u2)) : o2, d2 = new e.bu(r2, c2, i2, s2, n2, a2, l2);
              return this.loaded = this.loaded || {}, this.loaded[r2] = d2, d2;
            });
          }
          removeTile(e2) {
            const t2 = this.loaded, r2 = e2.uid;
            t2 && t2[r2] && delete t2[r2];
          }
        }
        function a(e2, t2) {
          if (0 !== e2.length) {
            l(e2[0], t2);
            for (var r2 = 1; r2 < e2.length; r2++)
              l(e2[r2], !t2);
          }
        }
        function l(e2, t2) {
          for (var r2 = 0, i2 = 0, o2 = 0, s2 = e2.length, n2 = s2 - 1; o2 < s2; n2 = o2++) {
            var a2 = (e2[o2][0] - e2[n2][0]) * (e2[n2][1] + e2[o2][1]), l2 = r2 + a2;
            i2 += Math.abs(r2) >= Math.abs(a2) ? r2 - l2 + a2 : a2 - l2 + r2, r2 = l2;
          }
          r2 + i2 >= 0 != !!t2 && e2.reverse();
        }
        var h = e.bv(function e2(t2, r2) {
          var i2, o2 = t2 && t2.type;
          if ("FeatureCollection" === o2)
            for (i2 = 0; i2 < t2.features.length; i2++)
              e2(t2.features[i2], r2);
          else if ("GeometryCollection" === o2)
            for (i2 = 0; i2 < t2.geometries.length; i2++)
              e2(t2.geometries[i2], r2);
          else if ("Feature" === o2)
            e2(t2.geometry, r2);
          else if ("Polygon" === o2)
            a(t2.coordinates, r2);
          else if ("MultiPolygon" === o2)
            for (i2 = 0; i2 < t2.coordinates.length; i2++)
              a(t2.coordinates[i2], r2);
          return t2;
        });
        const u = e.bq.VectorTileFeature.prototype.toGeoJSON;
        var c = { exports: {} }, d = e.bw, f = e.bq.VectorTileFeature, p = g;
        function g(e2, t2) {
          this.options = t2 || {}, this.features = e2, this.length = e2.length;
        }
        function m(e2, t2) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
        }
        g.prototype.feature = function(e2) {
          return new m(this.features[e2], this.options.extent);
        }, m.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t2 = 0; t2 < e2.length; t2++) {
            for (var r2 = e2[t2], i2 = [], o2 = 0; o2 < r2.length; o2++)
              i2.push(new d(r2[o2][0], r2[o2][1]));
            this.geometry.push(i2);
          }
          return this.geometry;
        }, m.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, i2 = 1 / 0, o2 = -1 / 0, s2 = 0; s2 < e2.length; s2++)
            for (var n2 = e2[s2], a2 = 0; a2 < n2.length; a2++) {
              var l2 = n2[a2];
              t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), i2 = Math.min(i2, l2.y), o2 = Math.max(o2, l2.y);
            }
          return [t2, i2, r2, o2];
        }, m.prototype.toGeoJSON = f.prototype.toGeoJSON;
        var v = e.bx, y = p;
        function w(e2) {
          var t2 = new v();
          return function(e3, t3) {
            for (var r2 in e3.layers)
              t3.writeMessage(3, x, e3.layers[r2]);
          }(e2, t2), t2.finish();
        }
        function x(e2, t2) {
          var r2;
          t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
          var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r2 = 0; r2 < e2.length; r2++)
            i2.feature = e2.feature(r2), t2.writeMessage(2, b, i2);
          var o2 = i2.keys;
          for (r2 = 0; r2 < o2.length; r2++)
            t2.writeStringField(3, o2[r2]);
          var s2 = i2.values;
          for (r2 = 0; r2 < s2.length; r2++)
            t2.writeMessage(4, P, s2[r2]);
        }
        function b(e2, t2) {
          var r2 = e2.feature;
          void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, I, r2);
        }
        function S(e2, t2) {
          var r2 = e2.feature, i2 = e2.keys, o2 = e2.values, s2 = e2.keycache, n2 = e2.valuecache;
          for (var a2 in r2.properties) {
            var l2 = r2.properties[a2], h2 = s2[a2];
            if (null !== l2) {
              void 0 === h2 && (i2.push(a2), s2[a2] = h2 = i2.length - 1), t2.writeVarint(h2);
              var u2 = typeof l2;
              "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l2 = JSON.stringify(l2));
              var c2 = u2 + ":" + l2, d2 = n2[c2];
              void 0 === d2 && (o2.push(l2), n2[c2] = d2 = o2.length - 1), t2.writeVarint(d2);
            }
          }
        }
        function M(e2, t2) {
          return (t2 << 3) + (7 & e2);
        }
        function _(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function I(e2, t2) {
          for (var r2 = e2.loadGeometry(), i2 = e2.type, o2 = 0, s2 = 0, n2 = r2.length, a2 = 0; a2 < n2; a2++) {
            var l2 = r2[a2], h2 = 1;
            1 === i2 && (h2 = l2.length), t2.writeVarint(M(1, h2));
            for (var u2 = 3 === i2 ? l2.length - 1 : l2.length, c2 = 0; c2 < u2; c2++) {
              1 === c2 && 1 !== i2 && t2.writeVarint(M(2, u2 - 1));
              var d2 = l2[c2].x - o2, f2 = l2[c2].y - s2;
              t2.writeVarint(_(d2)), t2.writeVarint(_(f2)), o2 += d2, s2 += f2;
            }
            3 === i2 && t2.writeVarint(M(7, 1));
          }
        }
        function P(e2, t2) {
          var r2 = typeof e2;
          "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
        }
        c.exports = w, c.exports.fromVectorTileJs = w, c.exports.fromGeojsonVt = function(e2, t2) {
          t2 = t2 || {};
          var r2 = {};
          for (var i2 in e2)
            r2[i2] = new y(e2[i2].features, t2), r2[i2].name = i2, r2[i2].version = t2.version, r2[i2].extent = t2.extent;
          return w({ layers: r2 });
        }, c.exports.GeoJSONWrapper = y;
        var k = e.bv(c.exports);
        const T = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, D = Math.fround || (C = new Float32Array(1), (e2) => (C[0] = +e2, C[0]));
        var C;
        const L = 3, O = 5, F = 6;
        class z {
          constructor(e2) {
            this.options = Object.assign(Object.create(T), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t2, minZoom: r2, maxZoom: i2 } = this.options;
            t2 && console.time("total time");
            const o2 = `prepare ${e2.length} points`;
            t2 && console.time(o2), this.points = e2;
            const s2 = [];
            for (let t3 = 0; t3 < e2.length; t3++) {
              const r3 = e2[t3];
              if (!r3.geometry)
                continue;
              const [i3, o3] = r3.geometry.coordinates, n3 = D(j(i3)), a2 = D(G(o3));
              s2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && s2.push(0);
            }
            let n2 = this.trees[i2 + 1] = this._createTree(s2);
            t2 && console.timeEnd(o2);
            for (let e3 = i2; e3 >= r2; e3--) {
              const r3 = +Date.now();
              n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - r3);
            }
            return t2 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t2) {
            let r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const i2 = Math.max(-90, Math.min(90, e2[1]));
            let o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const s2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360)
              r2 = -180, o2 = 180;
            else if (r2 > o2) {
              const e3 = this.getClusters([r2, i2, 180, s2], t2), n3 = this.getClusters([-180, i2, o2, s2], t2);
              return e3.concat(n3);
            }
            const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(j(r2), G(s2), j(o2), G(i2)), l2 = n2.data, h2 = [];
            for (const e3 of a2) {
              const t3 = this.stride * e3;
              h2.push(l2[t3 + O] > 1 ? A(l2, t3, this.clusterProps) : this.points[l2[t3 + L]]);
            }
            return h2;
          }
          getChildren(e2) {
            const t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[r2];
            if (!o2)
              throw new Error(i2);
            const s2 = o2.data;
            if (t2 * this.stride >= s2.length)
              throw new Error(i2);
            const n2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = o2.within(s2[t2 * this.stride], s2[t2 * this.stride + 1], n2), l2 = [];
            for (const t3 of a2) {
              const r3 = t3 * this.stride;
              s2[r3 + 4] === e2 && l2.push(s2[r3 + O] > 1 ? A(s2, r3, this.clusterProps) : this.points[s2[r3 + L]]);
            }
            if (0 === l2.length)
              throw new Error(i2);
            return l2;
          }
          getLeaves(e2, t2, r2) {
            const i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), i2;
          }
          getTile(e2, t2, r2) {
            const i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), { extent: s2, radius: n2 } = this.options, a2 = n2 / s2, l2 = (r2 - a2) / o2, h2 = (r2 + 1 + a2) / o2, u2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / o2, l2, (t2 + 1 + a2) / o2, h2), i2.data, t2, r2, o2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / o2, l2, 1, h2), i2.data, o2, r2, o2, u2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / o2, h2), i2.data, -1, r2, o2, u2), u2.features.length ? u2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t2 = this._getOriginZoom(e2) - 1;
            for (; t2 <= this.options.maxZoom; ) {
              const r2 = this.getChildren(e2);
              if (t2++, 1 !== r2.length)
                break;
              e2 = r2[0].properties.cluster_id;
            }
            return t2;
          }
          _appendLeaves(e2, t2, r2, i2, o2) {
            const s2 = this.getChildren(t2);
            for (const t3 of s2) {
              const s3 = t3.properties;
              if (s3 && s3.cluster ? o2 + s3.point_count <= i2 ? o2 += s3.point_count : o2 = this._appendLeaves(e2, s3.cluster_id, r2, i2, o2) : o2 < i2 ? o2++ : e2.push(t3), e2.length === r2)
                break;
            }
            return o2;
          }
          _createTree(t2) {
            const r2 = new e.au(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t2.length; e2 += this.stride)
              r2.add(t2[e2], t2[e2 + 1]);
            return r2.finish(), r2.data = t2, r2;
          }
          _addTileFeatures(e2, t2, r2, i2, o2, s2) {
            for (const n2 of e2) {
              const e3 = n2 * this.stride, a2 = t2[e3 + O] > 1;
              let l2, h2, u2;
              if (a2)
                l2 = E(t2, e3, this.clusterProps), h2 = t2[e3], u2 = t2[e3 + 1];
              else {
                const r3 = this.points[t2[e3 + L]];
                l2 = r3.properties;
                const [i3, o3] = r3.geometry.coordinates;
                h2 = j(i3), u2 = G(o3);
              }
              const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (h2 * o2 - r2)), Math.round(this.options.extent * (u2 * o2 - i2))]], tags: l2 };
              let d2;
              d2 = a2 || this.options.generateId ? t2[e3 + L] : this.points[t2[e3 + L]].id, void 0 !== d2 && (c2.id = d2), s2.features.push(c2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t2) {
            const { radius: r2, extent: i2, reduce: o2, minPoints: s2 } = this.options, n2 = r2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], h2 = this.stride;
            for (let r3 = 0; r3 < a2.length; r3 += h2) {
              if (a2[r3 + 2] <= t2)
                continue;
              a2[r3 + 2] = t2;
              const i3 = a2[r3], u2 = a2[r3 + 1], c2 = e2.within(a2[r3], a2[r3 + 1], n2), d2 = a2[r3 + O];
              let f2 = d2;
              for (const e3 of c2) {
                const r4 = e3 * h2;
                a2[r4 + 2] > t2 && (f2 += a2[r4 + O]);
              }
              if (f2 > d2 && f2 >= s2) {
                let e3, s3 = i3 * d2, n3 = u2 * d2, p2 = -1;
                const g2 = ((r3 / h2 | 0) << 5) + (t2 + 1) + this.points.length;
                for (const i4 of c2) {
                  const l3 = i4 * h2;
                  if (a2[l3 + 2] <= t2)
                    continue;
                  a2[l3 + 2] = t2;
                  const u3 = a2[l3 + O];
                  s3 += a2[l3] * u3, n3 += a2[l3 + 1] * u3, a2[l3 + 4] = g2, o2 && (e3 || (e3 = this._map(a2, r3, true), p2 = this.clusterProps.length, this.clusterProps.push(e3)), o2(e3, this._map(a2, l3)));
                }
                a2[r3 + 4] = g2, l2.push(s3 / f2, n3 / f2, 1 / 0, g2, -1, f2), o2 && l2.push(p2);
              } else {
                for (let e3 = 0; e3 < h2; e3++)
                  l2.push(a2[r3 + e3]);
                if (f2 > 1)
                  for (const e3 of c2) {
                    const r4 = e3 * h2;
                    if (!(a2[r4 + 2] <= t2)) {
                      a2[r4 + 2] = t2;
                      for (let e4 = 0; e4 < h2; e4++)
                        l2.push(a2[r4 + e4]);
                    }
                  }
              }
            }
            return l2;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t2, r2) {
            if (e2[t2 + O] > 1) {
              const i3 = this.clusterProps[e2[t2 + F]];
              return r2 ? Object.assign({}, i3) : i3;
            }
            const i2 = this.points[e2[t2 + L]].properties, o2 = this.options.map(i2);
            return r2 && o2 === i2 ? Object.assign({}, o2) : o2;
          }
        }
        function A(e2, t2, r2) {
          return { type: "Feature", id: e2[t2 + L], properties: E(e2, t2, r2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), R(e2[t2 + 1])] } };
          var i2;
        }
        function E(e2, t2, r2) {
          const i2 = e2[t2 + O], o2 = i2 >= 1e4 ? `${Math.round(i2 / 1e3)}k` : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, s2 = e2[t2 + F], n2 = -1 === s2 ? {} : Object.assign({}, r2[s2]);
          return Object.assign(n2, { cluster: true, cluster_id: e2[t2 + L], point_count: i2, point_count_abbreviated: o2 });
        }
        function j(e2) {
          return e2 / 360 + 0.5;
        }
        function G(e2) {
          const t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function R(e2) {
          const t2 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
        }
        function Z(e2, t2, r2, i2) {
          for (var o2, s2 = i2, n2 = r2 - t2 >> 1, a2 = r2 - t2, l2 = e2[t2], h2 = e2[t2 + 1], u2 = e2[r2], c2 = e2[r2 + 1], d2 = t2 + 3; d2 < r2; d2 += 3) {
            var f2 = N(e2[d2], e2[d2 + 1], l2, h2, u2, c2);
            if (f2 > s2)
              o2 = d2, s2 = f2;
            else if (f2 === s2) {
              var p2 = Math.abs(d2 - n2);
              p2 < a2 && (o2 = d2, a2 = p2);
            }
          }
          s2 > i2 && (o2 - t2 > 3 && Z(e2, t2, o2, i2), e2[o2 + 2] = s2, r2 - o2 > 3 && Z(e2, o2, r2, i2));
        }
        function N(e2, t2, r2, i2, o2, s2) {
          var n2 = o2 - r2, a2 = s2 - i2;
          if (0 !== n2 || 0 !== a2) {
            var l2 = ((e2 - r2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
            l2 > 1 ? (r2 = o2, i2 = s2) : l2 > 0 && (r2 += n2 * l2, i2 += a2 * l2);
          }
          return (n2 = e2 - r2) * n2 + (a2 = t2 - i2) * a2;
        }
        function W(e2, t2, r2, i2) {
          var o2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t3 = e3.geometry, r3 = e3.type;
            if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
              J(e3, t3);
            else if ("Polygon" === r3 || "MultiLineString" === r3)
              for (var i3 = 0; i3 < t3.length; i3++)
                J(e3, t3[i3]);
            else if ("MultiPolygon" === r3)
              for (i3 = 0; i3 < t3.length; i3++)
                for (var o3 = 0; o3 < t3[i3].length; o3++)
                  J(e3, t3[i3][o3]);
          }(o2), o2;
        }
        function J(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2 += 3)
            e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
        }
        function Y(e2, t2, r2, i2) {
          if (t2.geometry) {
            var o2 = t2.geometry.coordinates, s2 = t2.geometry.type, n2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), a2 = [], l2 = t2.id;
            if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = i2 || 0), "Point" === s2)
              q(o2, a2);
            else if ("MultiPoint" === s2)
              for (var h2 = 0; h2 < o2.length; h2++)
                q(o2[h2], a2);
            else if ("LineString" === s2)
              V(o2, a2, n2, false);
            else if ("MultiLineString" === s2) {
              if (r2.lineMetrics) {
                for (h2 = 0; h2 < o2.length; h2++)
                  V(o2[h2], a2 = [], n2, false), e2.push(W(l2, "LineString", a2, t2.properties));
                return;
              }
              X(o2, a2, n2, false);
            } else if ("Polygon" === s2)
              X(o2, a2, n2, true);
            else {
              if ("MultiPolygon" !== s2) {
                if ("GeometryCollection" === s2) {
                  for (h2 = 0; h2 < t2.geometry.geometries.length; h2++)
                    Y(e2, { id: l2, geometry: t2.geometry.geometries[h2], properties: t2.properties }, r2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (h2 = 0; h2 < o2.length; h2++) {
                var u2 = [];
                X(o2[h2], u2, n2, true), a2.push(u2);
              }
            }
            e2.push(W(l2, s2, a2, t2.properties));
          }
        }
        function q(e2, t2) {
          t2.push(H(e2[0])), t2.push(B(e2[1])), t2.push(0);
        }
        function V(e2, t2, r2, i2) {
          for (var o2, s2, n2 = 0, a2 = 0; a2 < e2.length; a2++) {
            var l2 = H(e2[a2][0]), h2 = B(e2[a2][1]);
            t2.push(l2), t2.push(h2), t2.push(0), a2 > 0 && (n2 += i2 ? (o2 * h2 - l2 * s2) / 2 : Math.sqrt(Math.pow(l2 - o2, 2) + Math.pow(h2 - s2, 2))), o2 = l2, s2 = h2;
          }
          var u2 = t2.length - 3;
          t2[2] = 1, Z(t2, 0, u2, r2), t2[u2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
        }
        function X(e2, t2, r2, i2) {
          for (var o2 = 0; o2 < e2.length; o2++) {
            var s2 = [];
            V(e2[o2], s2, r2, i2), t2.push(s2);
          }
        }
        function H(e2) {
          return e2 / 360 + 0.5;
        }
        function B(e2) {
          var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function U(e2, t2, r2, i2, o2, s2, n2, a2) {
          if (i2 /= t2, s2 >= (r2 /= t2) && n2 < i2)
            return e2;
          if (n2 < r2 || s2 >= i2)
            return null;
          for (var l2 = [], h2 = 0; h2 < e2.length; h2++) {
            var u2 = e2[h2], c2 = u2.geometry, d2 = u2.type, f2 = 0 === o2 ? u2.minX : u2.minY, p2 = 0 === o2 ? u2.maxX : u2.maxY;
            if (f2 >= r2 && p2 < i2)
              l2.push(u2);
            else if (!(p2 < r2 || f2 >= i2)) {
              var g2 = [];
              if ("Point" === d2 || "MultiPoint" === d2)
                $(c2, g2, r2, i2, o2);
              else if ("LineString" === d2)
                Q(c2, g2, r2, i2, o2, false, a2.lineMetrics);
              else if ("MultiLineString" === d2)
                ee(c2, g2, r2, i2, o2, false);
              else if ("Polygon" === d2)
                ee(c2, g2, r2, i2, o2, true);
              else if ("MultiPolygon" === d2)
                for (var m2 = 0; m2 < c2.length; m2++) {
                  var v2 = [];
                  ee(c2[m2], v2, r2, i2, o2, true), v2.length && g2.push(v2);
                }
              if (g2.length) {
                if (a2.lineMetrics && "LineString" === d2) {
                  for (m2 = 0; m2 < g2.length; m2++)
                    l2.push(W(u2.id, d2, g2[m2], u2.tags));
                  continue;
                }
                "LineString" !== d2 && "MultiLineString" !== d2 || (1 === g2.length ? (d2 = "LineString", g2 = g2[0]) : d2 = "MultiLineString"), "Point" !== d2 && "MultiPoint" !== d2 || (d2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(W(u2.id, d2, g2, u2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function $(e2, t2, r2, i2, o2) {
          for (var s2 = 0; s2 < e2.length; s2 += 3) {
            var n2 = e2[s2 + o2];
            n2 >= r2 && n2 <= i2 && (t2.push(e2[s2]), t2.push(e2[s2 + 1]), t2.push(e2[s2 + 2]));
          }
        }
        function Q(e2, t2, r2, i2, o2, s2, n2) {
          for (var a2, l2, h2 = K(e2), u2 = 0 === o2 ? re : ie, c2 = e2.start, d2 = 0; d2 < e2.length - 3; d2 += 3) {
            var f2 = e2[d2], p2 = e2[d2 + 1], g2 = e2[d2 + 2], m2 = e2[d2 + 3], v2 = e2[d2 + 4], y2 = 0 === o2 ? f2 : p2, w2 = 0 === o2 ? m2 : v2, x2 = false;
            n2 && (a2 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(p2 - v2, 2))), y2 < r2 ? w2 > r2 && (l2 = u2(h2, f2, p2, m2, v2, r2), n2 && (h2.start = c2 + a2 * l2)) : y2 > i2 ? w2 < i2 && (l2 = u2(h2, f2, p2, m2, v2, i2), n2 && (h2.start = c2 + a2 * l2)) : te(h2, f2, p2, g2), w2 < r2 && y2 >= r2 && (l2 = u2(h2, f2, p2, m2, v2, r2), x2 = true), w2 > i2 && y2 <= i2 && (l2 = u2(h2, f2, p2, m2, v2, i2), x2 = true), !s2 && x2 && (n2 && (h2.end = c2 + a2 * l2), t2.push(h2), h2 = K(e2)), n2 && (c2 += a2);
          }
          var b2 = e2.length - 3;
          f2 = e2[b2], p2 = e2[b2 + 1], g2 = e2[b2 + 2], (y2 = 0 === o2 ? f2 : p2) >= r2 && y2 <= i2 && te(h2, f2, p2, g2), b2 = h2.length - 3, s2 && b2 >= 3 && (h2[b2] !== h2[0] || h2[b2 + 1] !== h2[1]) && te(h2, h2[0], h2[1], h2[2]), h2.length && t2.push(h2);
        }
        function K(e2) {
          var t2 = [];
          return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
        }
        function ee(e2, t2, r2, i2, o2, s2) {
          for (var n2 = 0; n2 < e2.length; n2++)
            Q(e2[n2], t2, r2, i2, o2, s2, false);
        }
        function te(e2, t2, r2, i2) {
          e2.push(t2), e2.push(r2), e2.push(i2);
        }
        function re(e2, t2, r2, i2, o2, s2) {
          var n2 = (s2 - t2) / (i2 - t2);
          return e2.push(s2), e2.push(r2 + (o2 - r2) * n2), e2.push(1), n2;
        }
        function ie(e2, t2, r2, i2, o2, s2) {
          var n2 = (s2 - r2) / (o2 - r2);
          return e2.push(t2 + (i2 - t2) * n2), e2.push(s2), e2.push(1), n2;
        }
        function oe(e2, t2) {
          for (var r2 = [], i2 = 0; i2 < e2.length; i2++) {
            var o2, s2 = e2[i2], n2 = s2.type;
            if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2)
              o2 = se(s2.geometry, t2);
            else if ("MultiLineString" === n2 || "Polygon" === n2) {
              o2 = [];
              for (var a2 = 0; a2 < s2.geometry.length; a2++)
                o2.push(se(s2.geometry[a2], t2));
            } else if ("MultiPolygon" === n2)
              for (o2 = [], a2 = 0; a2 < s2.geometry.length; a2++) {
                for (var l2 = [], h2 = 0; h2 < s2.geometry[a2].length; h2++)
                  l2.push(se(s2.geometry[a2][h2], t2));
                o2.push(l2);
              }
            r2.push(W(s2.id, n2, o2, s2.tags));
          }
          return r2;
        }
        function se(e2, t2) {
          var r2 = [];
          r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
          for (var i2 = 0; i2 < e2.length; i2 += 3)
            r2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
          return r2;
        }
        function ne(e2, t2) {
          if (e2.transformed)
            return e2;
          var r2, i2, o2, s2 = 1 << e2.z, n2 = e2.x, a2 = e2.y;
          for (r2 = 0; r2 < e2.features.length; r2++) {
            var l2 = e2.features[r2], h2 = l2.geometry, u2 = l2.type;
            if (l2.geometry = [], 1 === u2)
              for (i2 = 0; i2 < h2.length; i2 += 2)
                l2.geometry.push(ae(h2[i2], h2[i2 + 1], t2, s2, n2, a2));
            else
              for (i2 = 0; i2 < h2.length; i2++) {
                var c2 = [];
                for (o2 = 0; o2 < h2[i2].length; o2 += 2)
                  c2.push(ae(h2[i2][o2], h2[i2][o2 + 1], t2, s2, n2, a2));
                l2.geometry.push(c2);
              }
          }
          return e2.transformed = true, e2;
        }
        function ae(e2, t2, r2, i2, o2, s2) {
          return [Math.round(r2 * (e2 * i2 - o2)), Math.round(r2 * (t2 * i2 - s2))];
        }
        function le(e2, t2, r2, i2, o2) {
          for (var s2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
            n2.numFeatures++, he(n2, e2[a2], s2, o2);
            var l2 = e2[a2].minX, h2 = e2[a2].minY, u2 = e2[a2].maxX, c2 = e2[a2].maxY;
            l2 < n2.minX && (n2.minX = l2), h2 < n2.minY && (n2.minY = h2), u2 > n2.maxX && (n2.maxX = u2), c2 > n2.maxY && (n2.maxY = c2);
          }
          return n2;
        }
        function he(e2, t2, r2, i2) {
          var o2 = t2.geometry, s2 = t2.type, n2 = [];
          if ("Point" === s2 || "MultiPoint" === s2)
            for (var a2 = 0; a2 < o2.length; a2 += 3)
              n2.push(o2[a2]), n2.push(o2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === s2)
            ue(n2, o2, e2, r2, false, false);
          else if ("MultiLineString" === s2 || "Polygon" === s2)
            for (a2 = 0; a2 < o2.length; a2++)
              ue(n2, o2[a2], e2, r2, "Polygon" === s2, 0 === a2);
          else if ("MultiPolygon" === s2)
            for (var l2 = 0; l2 < o2.length; l2++) {
              var h2 = o2[l2];
              for (a2 = 0; a2 < h2.length; a2++)
                ue(n2, h2[a2], e2, r2, true, 0 === a2);
            }
          if (n2.length) {
            var u2 = t2.tags || null;
            if ("LineString" === s2 && i2.lineMetrics) {
              for (var c2 in u2 = {}, t2.tags)
                u2[c2] = t2.tags[c2];
              u2.mapbox_clip_start = o2.start / o2.size, u2.mapbox_clip_end = o2.end / o2.size;
            }
            var d2 = { geometry: n2, type: "Polygon" === s2 || "MultiPolygon" === s2 ? 3 : "LineString" === s2 || "MultiLineString" === s2 ? 2 : 1, tags: u2 };
            null !== t2.id && (d2.id = t2.id), e2.features.push(d2);
          }
        }
        function ue(e2, t2, r2, i2, o2, s2) {
          var n2 = i2 * i2;
          if (i2 > 0 && t2.size < (o2 ? n2 : i2))
            r2.numPoints += t2.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
              (0 === i2 || t2[l2 + 2] > n2) && (r2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r2.numPoints++;
            o2 && function(e3, t3) {
              for (var r3 = 0, i3 = 0, o3 = e3.length, s3 = o3 - 2; i3 < o3; s3 = i3, i3 += 2)
                r3 += (e3[i3] - e3[s3]) * (e3[i3 + 1] + e3[s3 + 1]);
              if (r3 > 0 === t3)
                for (i3 = 0, o3 = e3.length; i3 < o3 / 2; i3 += 2) {
                  var n3 = e3[i3], a3 = e3[i3 + 1];
                  e3[i3] = e3[o3 - 2 - i3], e3[i3 + 1] = e3[o3 - 1 - i3], e3[o3 - 2 - i3] = n3, e3[o3 - 1 - i3] = a3;
                }
            }(a2, s2), e2.push(a2);
          }
        }
        function ce(e2, t2) {
          var r2 = (t2 = this.options = function(e3, t3) {
            for (var r3 in t3)
              e3[r3] = t3[r3];
            return e3;
          }(Object.create(this.options), t2)).debug;
          if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i2 = function(e3, t3) {
            var r3 = [];
            if ("FeatureCollection" === e3.type)
              for (var i3 = 0; i3 < e3.features.length; i3++)
                Y(r3, e3.features[i3], t3, i3);
            else
              Y(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
            return r3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
            var r3 = t3.buffer / t3.extent, i3 = e3, o2 = U(e3, 1, -1 - r3, r3, 0, -1, 2, t3), s2 = U(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
            return (o2 || s2) && (i3 = U(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], o2 && (i3 = oe(o2, 1).concat(i3)), s2 && (i3 = i3.concat(oe(s2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), r2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function de(e2, t2, r2) {
          return 32 * ((1 << e2) * r2 + t2) + e2;
        }
        function fe(e2, t2) {
          return t2 ? e2.properties[t2] : e2.id;
        }
        function pe(e2, t2) {
          if (null == e2)
            return true;
          if ("Feature" === e2.type)
            return null != fe(e2, t2);
          if ("FeatureCollection" === e2.type) {
            const r2 = /* @__PURE__ */ new Set();
            for (const i2 of e2.features) {
              const e3 = fe(i2, t2);
              if (null == e3)
                return false;
              if (r2.has(e3))
                return false;
              r2.add(e3);
            }
            return true;
          }
          return false;
        }
        function ge(e2, t2) {
          const r2 = /* @__PURE__ */ new Map();
          if (null == e2)
            ;
          else if ("Feature" === e2.type)
            r2.set(fe(e2, t2), e2);
          else
            for (const i2 of e2.features)
              r2.set(fe(i2, t2), i2);
          return r2;
        }
        ce.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ce.prototype.splitTile = function(e2, t2, r2, i2, o2, s2, n2) {
          for (var a2 = [e2, t2, r2, i2], l2 = this.options, h2 = l2.debug; a2.length; ) {
            i2 = a2.pop(), r2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            var u2 = 1 << t2, c2 = de(t2, r2, i2), d2 = this.tiles[c2];
            if (!d2 && (h2 > 1 && console.time("creation"), d2 = this.tiles[c2] = le(e2, t2, r2, i2, l2), this.tileCoords.push({ z: t2, x: r2, y: i2 }), h2)) {
              h2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t2;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (d2.source = e2, o2) {
              if (t2 === l2.maxZoom || t2 === o2)
                continue;
              var p2 = 1 << o2 - t2;
              if (r2 !== Math.floor(s2 / p2) || i2 !== Math.floor(n2 / p2))
                continue;
            } else if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints)
              continue;
            if (d2.source = null, 0 !== e2.length) {
              h2 > 1 && console.time("clipping");
              var g2, m2, v2, y2, w2, x2, b2 = 0.5 * l2.buffer / l2.extent, S2 = 0.5 - b2, M2 = 0.5 + b2, _2 = 1 + b2;
              g2 = m2 = v2 = y2 = null, w2 = U(e2, u2, r2 - b2, r2 + M2, 0, d2.minX, d2.maxX, l2), x2 = U(e2, u2, r2 + S2, r2 + _2, 0, d2.minX, d2.maxX, l2), e2 = null, w2 && (g2 = U(w2, u2, i2 - b2, i2 + M2, 1, d2.minY, d2.maxY, l2), m2 = U(w2, u2, i2 + S2, i2 + _2, 1, d2.minY, d2.maxY, l2), w2 = null), x2 && (v2 = U(x2, u2, i2 - b2, i2 + M2, 1, d2.minY, d2.maxY, l2), y2 = U(x2, u2, i2 + S2, i2 + _2, 1, d2.minY, d2.maxY, l2), x2 = null), h2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t2 + 1, 2 * r2, 2 * i2), a2.push(m2 || [], t2 + 1, 2 * r2, 2 * i2 + 1), a2.push(v2 || [], t2 + 1, 2 * r2 + 1, 2 * i2), a2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * i2 + 1);
            }
          }
        }, ce.prototype.getTile = function(e2, t2, r2) {
          var i2 = this.options, o2 = i2.extent, s2 = i2.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var n2 = 1 << e2, a2 = de(e2, t2 = (t2 % n2 + n2) % n2, r2);
          if (this.tiles[a2])
            return ne(this.tiles[a2], o2);
          s2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
          for (var l2, h2 = e2, u2 = t2, c2 = r2; !l2 && h2 > 0; )
            h2--, u2 = Math.floor(u2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[de(h2, u2, c2)];
          return l2 && l2.source ? (s2 > 1 && console.log("found parent tile z%d-%d-%d", h2, u2, c2), s2 > 1 && console.time("drilling down"), this.splitTile(l2.source, h2, u2, c2, e2, t2, r2), s2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ne(this.tiles[a2], o2) : null) : null;
        };
        class me extends s {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(t2, r2) {
            return e._(this, void 0, void 0, function* () {
              const r3 = t2.tileID.canonical;
              if (!this._geoJSONIndex)
                throw new Error("Unable to parse the data into a cluster or geojson");
              const i2 = this._geoJSONIndex.getTile(r3.z, r3.x, r3.y);
              if (!i2)
                return null;
              const o2 = new class {
                constructor(t3) {
                  this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.W, this.length = t3.length, this._features = t3;
                }
                feature(t3) {
                  return new class {
                    constructor(t4) {
                      this._feature = t4, this.extent = e.W, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const t4 = [];
                        for (const r4 of this._feature.geometry)
                          t4.push([new e.P(r4[0], r4[1])]);
                        return t4;
                      }
                      {
                        const t4 = [];
                        for (const r4 of this._feature.geometry) {
                          const i3 = [];
                          for (const t5 of r4)
                            i3.push(new e.P(t5[0], t5[1]));
                          t4.push(i3);
                        }
                        return t4;
                      }
                    }
                    toGeoJSON(e2, t4, r4) {
                      return u.call(this, e2, t4, r4);
                    }
                  }(this._features[t3]);
                }
              }(i2.features);
              let s2 = k(o2);
              return 0 === s2.byteOffset && s2.byteLength === s2.buffer.byteLength || (s2 = new Uint8Array(s2)), { vectorTile: o2, rawData: s2.buffer };
            });
          }
          loadData(t2) {
            return e._(this, void 0, void 0, function* () {
              var r2;
              null === (r2 = this._pendingRequest) || void 0 === r2 || r2.abort();
              const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bs(t2.request);
              this._pendingRequest = new AbortController();
              try {
                let r3 = yield this.loadGeoJSON(t2, this._pendingRequest);
                if (delete this._pendingRequest, "object" != typeof r3)
                  throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
                if (h(r3, true), t2.filter) {
                  const i3 = e.by(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === i3.result)
                    throw new Error(i3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const o3 = r3.features.filter((e2) => i3.value.evaluate({ zoom: 0 }, e2));
                  r3 = { type: "FeatureCollection", features: o3 };
                }
                this._geoJSONIndex = t2.cluster ? new z(function({ superclusterOptions: t3, clusterProperties: r4 }) {
                  if (!r4 || !t3)
                    return t3;
                  const i3 = {}, o3 = {}, s2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(r4);
                  for (const t4 of a2) {
                    const [s3, n3] = r4[t4], a3 = e.by(n3), l2 = e.by("string" == typeof s3 ? [s3, ["accumulated"], ["get", t4]] : s3);
                    i3[t4] = a3.value, o3[t4] = l2.value;
                  }
                  return t3.map = (e2) => {
                    n2.properties = e2;
                    const t4 = {};
                    for (const e3 of a2)
                      t4[e3] = i3[e3].evaluate(s2, n2);
                    return t4;
                  }, t3.reduce = (e2, t4) => {
                    n2.properties = t4;
                    for (const t5 of a2)
                      s2.accumulated = e2[t5], e2[t5] = o3[t5].evaluate(s2, n2);
                  }, t3;
                }(t2)).load(r3.features) : function(e2, t3) {
                  return new ce(e2, t3);
                }(r3, t2.geojsonVtOptions), this.loaded = {};
                const o2 = {};
                if (i2) {
                  const e2 = i2.finish();
                  e2 && (o2.resourceTiming = {}, o2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
                }
                return o2;
              } catch (t3) {
                if (delete this._pendingRequest, e.bz(t3))
                  return { abandoned: true };
                throw t3;
              }
            });
          }
          reloadTile(e2) {
            const t2 = this.loaded;
            return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
          }
          loadGeoJSON(t2, r2) {
            return e._(this, void 0, void 0, function* () {
              const { promoteId: i2 } = t2;
              if (t2.request) {
                const o2 = yield e.h(t2.request, r2);
                return this._dataUpdateable = pe(o2.data, i2) ? ge(o2.data, i2) : void 0, o2.data;
              }
              if ("string" == typeof t2.data)
                try {
                  const e2 = JSON.parse(t2.data);
                  return this._dataUpdateable = pe(e2, i2) ? ge(e2, i2) : void 0, e2;
                } catch (e2) {
                  throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
                }
              if (!t2.dataDiff)
                throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable)
                throw new Error(`Cannot update existing geojson data in ${t2.source}`);
              return function(e2, t3, r3) {
                var i3, o2, s2, n2;
                if (t3.removeAll && e2.clear(), t3.remove)
                  for (const r4 of t3.remove)
                    e2.delete(r4);
                if (t3.add)
                  for (const i4 of t3.add) {
                    const t4 = fe(i4, r3);
                    null != t4 && e2.set(t4, i4);
                  }
                if (t3.update)
                  for (const r4 of t3.update) {
                    let t4 = e2.get(r4.id);
                    if (null == t4)
                      continue;
                    const a2 = !r4.removeAllProperties && ((null === (i3 = r4.removeProperties) || void 0 === i3 ? void 0 : i3.length) > 0 || (null === (o2 = r4.addOrUpdateProperties) || void 0 === o2 ? void 0 : o2.length) > 0);
                    if ((r4.newGeometry || r4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(r4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), r4.newGeometry && (t4.geometry = r4.newGeometry), r4.removeAllProperties)
                      t4.properties = {};
                    else if ((null === (s2 = r4.removeProperties) || void 0 === s2 ? void 0 : s2.length) > 0)
                      for (const e3 of r4.removeProperties)
                        Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                    if ((null === (n2 = r4.addOrUpdateProperties) || void 0 === n2 ? void 0 : n2.length) > 0)
                      for (const { key: e3, value: i4 } of r4.addOrUpdateProperties)
                        t4.properties[e3] = i4;
                  }
              }(this._dataUpdateable, t2.dataDiff, i2), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(t2) {
            return e._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(e2) {
            return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
          }
          getClusterChildren(e2) {
            return this._geoJSONIndex.getChildren(e2.clusterId);
          }
          getClusterLeaves(e2) {
            return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
          }
        }
        class ve {
          constructor(t2) {
            this.self = t2, this.actor = new e.C(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
              if (this.externalWorkerSourceTypes[e2])
                throw new Error(`Worker source with name "${e2}" already registered.`);
              this.externalWorkerSourceTypes[e2] = t3;
            }, this.self.addProtocol = e.bf, this.self.removeProtocol = e.bg, this.self.registerRTLTextPlugin = (t3) => {
              if (e.bA.isParsed())
                throw new Error("RTL text plugin already registered.");
              e.bA.setMethods(t3);
            }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, r2) => e._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(t3, r2.source).removeTile(r2);
            })), this.actor.registerMessageHandler("GCEZ", (t3, r2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, r2.type, r2.source).getClusterExpansionZoom(r2);
            })), this.actor.registerMessageHandler("GCC", (t3, r2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, r2.type, r2.source).getClusterChildren(r2);
            })), this.actor.registerMessageHandler("GCL", (t3, r2) => e._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t3, r2.type, r2.source).getClusterLeaves(r2);
            })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, r2) => e._(this, void 0, void 0, function* () {
              if (!this.workerSources[t3] || !this.workerSources[t3][r2.type] || !this.workerSources[t3][r2.type][r2.source])
                return;
              const e2 = this.workerSources[t3][r2.type][r2.source];
              delete this.workerSources[t3][r2.type][r2.source], void 0 !== e2.removeSource && e2.removeSource(r2);
            })), this.actor.registerMessageHandler("RM", (t3) => e._(this, void 0, void 0, function* () {
              delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
            })), this.actor.registerMessageHandler("SR", (t3, r2) => e._(this, void 0, void 0, function* () {
              this.referrer = r2;
            })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, r2) => e._(this, void 0, void 0, function* () {
              this.self.importScripts(r2);
            })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, r2) => e._(this, void 0, void 0, function* () {
              this._getLayerIndex(t3).update(r2.layers, r2.removedIds);
            })), this.actor.registerMessageHandler("SL", (t3, r2) => e._(this, void 0, void 0, function* () {
              this._getLayerIndex(t3).replace(r2);
            }));
          }
          _setImages(t2, r2) {
            return e._(this, void 0, void 0, function* () {
              this.availableImages[t2] = r2;
              for (const e2 in this.workerSources[t2]) {
                const i2 = this.workerSources[t2][e2];
                for (const e3 in i2)
                  i2[e3].availableImages = r2;
              }
            });
          }
          _syncRTLPluginState(t2, r2) {
            return e._(this, void 0, void 0, function* () {
              if (e.bA.isParsed())
                return e.bA.getState();
              if ("loading" !== r2.pluginStatus)
                return e.bA.setState(r2), r2;
              const t3 = r2.pluginURL;
              if (this.self.importScripts(t3), e.bA.isParsed()) {
                const r3 = { pluginStatus: "loaded", pluginURL: t3 };
                return e.bA.setState(r3), r3;
              }
              throw e.bA.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${t3}`);
            });
          }
          _getAvailableImages(e2) {
            let t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }
          _getLayerIndex(e2) {
            let r2 = this.layerIndexes[e2];
            return r2 || (r2 = this.layerIndexes[e2] = new t()), r2;
          }
          _getWorkerSource(e2, t2, r2) {
            if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][r2]) {
              const i2 = { sendAsync: (t3, r3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, r3)) };
              switch (t2) {
                case "vector":
                  this.workerSources[e2][t2][r2] = new s(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                case "geojson":
                  this.workerSources[e2][t2][r2] = new me(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                  break;
                default:
                  this.workerSources[e2][t2][r2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
              }
            }
            return this.workerSources[e2][t2][r2];
          }
          _getDEMWorkerSource(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
          }
        }
        return e.i(self) && (self.worker = new ve(self)), ve;
      });
      define2("index", ["exports", "./shared"], function(t, e) {
        "use strict";
        var i = "4.1.3";
        let s, a;
        const o = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (t2) => new Promise((i2, s2) => {
          const a2 = requestAnimationFrame(i2);
          t2.signal.addEventListener("abort", () => {
            cancelAnimationFrame(a2), s2(e.c());
          });
        }), getImageData(t2, e2 = 0) {
          return this.getImageCanvasContext(t2).getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
        }, getImageCanvasContext(t2) {
          const e2 = window.document.createElement("canvas"), i2 = e2.getContext("2d", { willReadFrequently: true });
          if (!i2)
            throw new Error("failed to create canvas 2d context");
          return e2.width = t2.width, e2.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height), i2;
        }, resolveURL: (t2) => (s || (s = document.createElement("a")), s.href = t2, s.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == a && (a = matchMedia("(prefers-reduced-motion: reduce)")), a.matches);
        } };
        class r {
          static testProp(t2) {
            if (!r.docStyle)
              return t2[0];
            for (let e2 = 0; e2 < t2.length; e2++)
              if (t2[e2] in r.docStyle)
                return t2[e2];
            return t2[0];
          }
          static create(t2, e2, i2) {
            const s2 = window.document.createElement(t2);
            return void 0 !== e2 && (s2.className = e2), i2 && i2.appendChild(s2), s2;
          }
          static createNS(t2, e2) {
            return window.document.createElementNS(t2, e2);
          }
          static disableDrag() {
            r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
          }
          static enableDrag() {
            r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
          }
          static setTransform(t2, e2) {
            t2.style[r.transformProp] = e2;
          }
          static addEventListener(t2, e2, i2, s2 = {}) {
            t2.addEventListener(e2, i2, "passive" in s2 ? s2 : s2.capture);
          }
          static removeEventListener(t2, e2, i2, s2 = {}) {
            t2.removeEventListener(e2, i2, "passive" in s2 ? s2 : s2.capture);
          }
          static suppressClickInternal(t2) {
            t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", r.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", r.suppressClickInternal, true);
            }, 0);
          }
          static getScale(t2) {
            const e2 = t2.getBoundingClientRect();
            return { x: e2.width / t2.offsetWidth || 1, y: e2.height / t2.offsetHeight || 1, boundingClientRect: e2 };
          }
          static getPoint(t2, i2, s2) {
            const a2 = i2.boundingClientRect;
            return new e.P((s2.clientX - a2.left) / i2.x - t2.clientLeft, (s2.clientY - a2.top) / i2.y - t2.clientTop);
          }
          static mousePos(t2, e2) {
            const i2 = r.getScale(t2);
            return r.getPoint(t2, i2, e2);
          }
          static touchPos(t2, e2) {
            const i2 = [], s2 = r.getScale(t2);
            for (let a2 = 0; a2 < e2.length; a2++)
              i2.push(r.getPoint(t2, s2, e2[a2]));
            return i2;
          }
          static mouseButton(t2) {
            return t2.button;
          }
          static remove(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
        }
        r.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, r.selectProp = r.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
        const n = { supported: false, testSupport: function(t2) {
          !c && h && (u ? d(t2) : l = t2);
        } };
        let l, h, c = false, u = false;
        function d(t2) {
          const e2 = t2.createTexture();
          t2.bindTexture(t2.TEXTURE_2D, e2);
          try {
            if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, h), t2.isContextLost())
              return;
            n.supported = true;
          } catch (t3) {
          }
          t2.deleteTexture(e2), c = true;
        }
        var _;
        "undefined" != typeof document && (h = document.createElement("img"), h.onload = function() {
          l && d(l), l = null, u = true;
        }, h.onerror = function() {
          c = true, l = null;
        }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(t2) {
          let i2, s2, a2, o2;
          t2.resetRequestQueue = () => {
            i2 = [], s2 = 0, a2 = 0, o2 = {};
          }, t2.addThrottleControl = (t3) => {
            const e2 = a2++;
            return o2[e2] = t3, e2;
          }, t2.removeThrottleControl = (t3) => {
            delete o2[t3], l2();
          }, t2.getImage = (t3, s3, a3 = true) => new Promise((o3, r3) => {
            n.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), e.e(t3, { type: "image" }), i2.push({ abortController: s3, requestParameters: t3, supportImageRefresh: a3, state: "queued", onError: (t4) => {
              r3(t4);
            }, onSuccess: (t4) => {
              o3(t4);
            } }), l2();
          });
          const r2 = (t3) => e._(this, void 0, void 0, function* () {
            t3.state = "running";
            const { requestParameters: i3, supportImageRefresh: a3, onError: o3, onSuccess: r3, abortController: n2 } = t3, c2 = false === a3 && !e.i(self) && !e.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((t4, e2) => t4 && "accept" === e2, true));
            s2++;
            const u2 = c2 ? h2(i3, n2) : e.m(i3, n2);
            try {
              const i4 = yield u2;
              delete t3.abortController, t3.state = "completed", i4.data instanceof HTMLImageElement || e.b(i4.data) ? r3(i4) : i4.data && r3({ data: yield (d2 = i4.data, "function" == typeof createImageBitmap ? e.d(d2) : e.f(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
            } catch (e2) {
              delete t3.abortController, o3(e2);
            } finally {
              s2--, l2();
            }
            var d2;
          }), l2 = () => {
            const t3 = (() => {
              for (const t4 of Object.keys(o2))
                if (o2[t4]())
                  return true;
              return false;
            })() ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let e2 = s2; e2 < t3 && i2.length > 0; e2++) {
              const t4 = i2.shift();
              t4.abortController.signal.aborted ? e2-- : r2(t4);
            }
          }, h2 = (t3, i3) => new Promise((s3, a3) => {
            const o3 = new Image(), r3 = t3.url, n2 = t3.credentials;
            n2 && "include" === n2 ? o3.crossOrigin = "use-credentials" : (n2 && "same-origin" === n2 || !e.s(r3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
              o3.src = "", a3(e.c());
            }), o3.fetchPriority = "high", o3.onload = () => {
              o3.onerror = o3.onload = null, s3({ data: o3 });
            }, o3.onerror = () => {
              o3.onerror = o3.onload = null, i3.signal.aborted || a3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, o3.src = r3;
          });
        }(_ || (_ = {})), _.resetRequestQueue();
        class p {
          constructor(t2) {
            this._transformRequestFn = t2;
          }
          transformRequest(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }
          normalizeSpriteURL(t2, e2, i2) {
            const s2 = function(t3) {
              const e3 = t3.match(m);
              if (!e3)
                throw new Error(`Unable to parse URL "${t3}"`);
              return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
            }(t2);
            return s2.path += `${e2}${i2}`, function(t3) {
              const e3 = t3.params.length ? `?${t3.params.join("&")}` : "";
              return `${t3.protocol}://${t3.authority}${t3.path}${e3}`;
            }(s2);
          }
          setTransformRequest(t2) {
            this._transformRequestFn = t2;
          }
        }
        const m = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function f(t2) {
          var i2 = new e.A(3);
          return i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2], i2;
        }
        var g, v = function(t2, e2, i2) {
          return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
        };
        g = new e.A(3), e.A != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0);
        var x = function(t2) {
          var e2 = t2[0], i2 = t2[1];
          return e2 * e2 + i2 * i2;
        };
        function y(t2) {
          const e2 = [];
          if ("string" == typeof t2)
            e2.push({ id: "default", url: t2 });
          else if (t2 && t2.length > 0) {
            const i2 = [];
            for (const { id: s2, url: a2 } of t2) {
              const t3 = `${s2}${a2}`;
              -1 === i2.indexOf(t3) && (i2.push(t3), e2.push({ id: s2, url: a2 }));
            }
          }
          return e2;
        }
        !function() {
          var t2 = new e.A(2);
          e.A != Float32Array && (t2[0] = 0, t2[1] = 0);
        }();
        class b {
          constructor(t2, e2, i2, s2) {
            this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, s2);
          }
          update(t2, i2, s2) {
            const { width: a2, height: o2 } = t2, r2 = !(this.size && this.size[0] === a2 && this.size[1] === o2 || s2), { context: n2 } = this, { gl: l2 } = n2;
            if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || false !== i2.premultiply)), r2)
              this.size = [a2, o2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, t2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, o2, 0, this.format, l2.UNSIGNED_BYTE, t2.data);
            else {
              const { x: i3, y: r3 } = s2 || { x: 0, y: 0 };
              t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, l2.RGBA, l2.UNSIGNED_BYTE, t2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, a2, o2, l2.RGBA, l2.UNSIGNED_BYTE, t2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
          }
          bind(t2, e2, i2) {
            const { context: s2 } = this, { gl: a2 } = s2;
            a2.bindTexture(a2.TEXTURE_2D, this.texture), i2 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = a2.LINEAR), t2 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t2 } = this.context;
            t2.deleteTexture(this.texture), this.texture = null;
          }
        }
        function w(t2) {
          const { userImage: e2 } = t2;
          return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
        }
        class T extends e.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t2) {
            if (this.loaded !== t2 && (this.loaded = t2, t2)) {
              for (const { ids: t3, promiseResolve: e2 } of this.requestors)
                e2(this._getImagesForIds(t3));
              this.requestors = [];
            }
          }
          getImage(t2) {
            const i2 = this.images[t2];
            if (i2 && !i2.data && i2.spriteData) {
              const t3 = i2.spriteData;
              i2.data = new e.R({ width: t3.width, height: t3.height }, t3.context.getImageData(t3.x, t3.y, t3.width, t3.height).data), i2.spriteData = null;
            }
            return i2;
          }
          addImage(t2, e2) {
            if (this.images[t2])
              throw new Error(`Image id ${t2} already exist, use updateImage instead`);
            this._validate(t2, e2) && (this.images[t2] = e2);
          }
          _validate(t2, i2) {
            let s2 = true;
            const a2 = i2.data || i2.spriteData;
            return this._validateStretch(i2.stretchX, a2 && a2.width) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchX" value`))), s2 = false), this._validateStretch(i2.stretchY, a2 && a2.height) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchY" value`))), s2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "content" value`))), s2 = false), s2;
          }
          _validateStretch(t2, e2) {
            if (!t2)
              return true;
            let i2 = 0;
            for (const s2 of t2) {
              if (s2[0] < i2 || s2[1] < s2[0] || e2 < s2[1])
                return false;
              i2 = s2[1];
            }
            return true;
          }
          _validateContent(t2, e2) {
            if (!t2)
              return true;
            if (4 !== t2.length)
              return false;
            const i2 = e2.spriteData, s2 = i2 && i2.width || e2.data.width, a2 = i2 && i2.height || e2.data.height;
            return !(t2[0] < 0 || s2 < t2[0] || t2[1] < 0 || a2 < t2[1] || t2[2] < 0 || s2 < t2[2] || t2[3] < 0 || a2 < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]);
          }
          updateImage(t2, e2, i2 = true) {
            const s2 = this.getImage(t2);
            if (i2 && (s2.data.width !== e2.data.width || s2.data.height !== e2.data.height))
              throw new Error(`size mismatch between old image (${s2.data.width}x${s2.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
            e2.version = s2.version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
          }
          removeImage(t2) {
            const e2 = this.images[t2];
            delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t2) {
            return new Promise((e2, i2) => {
              let s2 = true;
              if (!this.isLoaded())
                for (const e3 of t2)
                  this.images[e3] || (s2 = false);
              this.isLoaded() || s2 ? e2(this._getImagesForIds(t2)) : this.requestors.push({ ids: t2, promiseResolve: e2 });
            });
          }
          _getImagesForIds(t2) {
            const i2 = {};
            for (const s2 of t2) {
              let t3 = this.getImage(s2);
              t3 || (this.fire(new e.k("styleimagemissing", { id: s2 })), t3 = this.getImage(s2)), t3 ? i2[s2] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.w(`Image "${s2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return i2;
          }
          getPixelSize() {
            const { width: t2, height: e2 } = this.atlasImage;
            return { width: t2, height: e2 };
          }
          getPattern(t2) {
            const i2 = this.patterns[t2], s2 = this.getImage(t2);
            if (!s2)
              return null;
            if (i2 && i2.position.version === s2.version)
              return i2.position;
            if (i2)
              i2.position.version = s2.version;
            else {
              const i3 = { w: s2.data.width + 2, h: s2.data.height + 2, x: 0, y: 0 }, a2 = new e.I(i3, s2);
              this.patterns[t2] = { bin: i3, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[t2].position;
          }
          bind(t2) {
            const e2 = t2.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new b(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t2 = [];
            for (const e2 in this.patterns)
              t2.push(this.patterns[e2].bin);
            const { w: i2, h: s2 } = e.p(t2), a2 = this.atlasImage;
            a2.resize({ width: i2 || 1, height: s2 || 1 });
            for (const t3 in this.patterns) {
              const { bin: i3 } = this.patterns[t3], s3 = i3.x + 1, o2 = i3.y + 1, r2 = this.getImage(t3).data, n2 = r2.width, l2 = r2.height;
              e.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3, y: o2 }, { width: n2, height: l2 }), e.R.copy(r2, a2, { x: 0, y: l2 - 1 }, { x: s3, y: o2 - 1 }, { width: n2, height: 1 }), e.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3, y: o2 + l2 }, { width: n2, height: 1 }), e.R.copy(r2, a2, { x: n2 - 1, y: 0 }, { x: s3 - 1, y: o2 }, { width: 1, height: l2 }), e.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3 + n2, y: o2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t2) {
            for (const i2 of t2) {
              if (this.callbackDispatchedThisFrame[i2])
                continue;
              this.callbackDispatchedThisFrame[i2] = true;
              const t3 = this.getImage(i2);
              t3 || e.w(`Image with ID: "${i2}" was not found`), w(t3) && this.updateImage(i2, t3);
            }
          }
        }
        const I = 1e20;
        function E(t2, e2, i2, s2, a2, o2, r2, n2, l2) {
          for (let h2 = e2; h2 < e2 + s2; h2++)
            C(t2, i2 * o2 + h2, o2, a2, r2, n2, l2);
          for (let h2 = i2; h2 < i2 + a2; h2++)
            C(t2, h2 * o2 + e2, 1, s2, r2, n2, l2);
        }
        function C(t2, e2, i2, s2, a2, o2, r2) {
          o2[0] = 0, r2[0] = -I, r2[1] = I, a2[0] = t2[e2];
          for (let n2 = 1, l2 = 0, h2 = 0; n2 < s2; n2++) {
            a2[n2] = t2[e2 + n2 * i2];
            const s3 = n2 * n2;
            do {
              const t3 = o2[l2];
              h2 = (a2[n2] - a2[t3] + s3 - t3 * t3) / (n2 - t3) / 2;
            } while (h2 <= r2[l2] && --l2 > -1);
            l2++, o2[l2] = n2, r2[l2] = h2, r2[l2 + 1] = I;
          }
          for (let n2 = 0, l2 = 0; n2 < s2; n2++) {
            for (; r2[l2 + 1] < n2; )
              l2++;
            const s3 = o2[l2], h2 = n2 - s3;
            t2[e2 + n2 * i2] = a2[s3] + h2 * h2;
          }
        }
        class S {
          constructor(t2, e2) {
            this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
          }
          setURL(t2) {
            this.url = t2;
          }
          getGlyphs(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = [];
              for (const i3 in t2)
                for (const s3 of t2[i3])
                  e2.push(this._getAndCacheGlyphsPromise(i3, s3));
              const i2 = yield Promise.all(e2), s2 = {};
              for (const { stack: t3, id: e3, glyph: a2 } of i2)
                s2[t3] || (s2[t3] = {}), s2[t3][e3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
              return s2;
            });
          }
          _getAndCacheGlyphsPromise(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              let e2 = this.entries[t2];
              e2 || (e2 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
              let s2 = e2.glyphs[i2];
              if (void 0 !== s2)
                return { stack: t2, id: i2, glyph: s2 };
              if (s2 = this._tinySDF(e2, t2, i2), s2)
                return e2.glyphs[i2] = s2, { stack: t2, id: i2, glyph: s2 };
              const a2 = Math.floor(i2 / 256);
              if (256 * a2 > 65535)
                throw new Error("glyphs > 65535 not supported");
              if (e2.ranges[a2])
                return { stack: t2, id: i2, glyph: s2 };
              if (!this.url)
                throw new Error("glyphsUrl is not set");
              if (!e2.requests[a2]) {
                const i3 = S.loadGlyphRange(t2, a2, this.url, this.requestManager);
                e2.requests[a2] = i3;
              }
              const o2 = yield e2.requests[a2];
              for (const t3 in o2)
                this._doesCharSupportLocalGlyph(+t3) || (e2.glyphs[+t3] = o2[+t3]);
              return e2.ranges[a2] = true, { stack: t2, id: i2, glyph: o2[i2] || null };
            });
          }
          _doesCharSupportLocalGlyph(t2) {
            return !!this.localIdeographFontFamily && (e.u["CJK Unified Ideographs"](t2) || e.u["Hangul Syllables"](t2) || e.u.Hiragana(t2) || e.u.Katakana(t2));
          }
          _tinySDF(t2, i2, s2) {
            const a2 = this.localIdeographFontFamily;
            if (!a2)
              return;
            if (!this._doesCharSupportLocalGlyph(s2))
              return;
            let o2 = t2.tinySDF;
            if (!o2) {
              let e2 = "400";
              /bold/i.test(i2) ? e2 = "900" : /medium/i.test(i2) ? e2 = "500" : /light/i.test(i2) && (e2 = "200"), o2 = t2.tinySDF = new S.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a2, fontWeight: e2 });
            }
            const r2 = o2.draw(String.fromCharCode(s2));
            return { id: s2, bitmap: new e.o({ width: r2.width || 60, height: r2.height || 60 }, r2.data), metrics: { width: r2.glyphWidth / 2 || 24, height: r2.glyphHeight / 2 || 24, left: r2.glyphLeft / 2 + 0.5 || 0, top: r2.glyphTop / 2 - 27.5 || -8, advance: r2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        S.loadGlyphRange = function(t2, i2, s2, a2) {
          return e._(this, void 0, void 0, function* () {
            const o2 = 256 * i2, r2 = o2 + 255, n2 = a2.transformRequest(s2.replace("{fontstack}", t2).replace("{range}", `${o2}-${r2}`), "Glyphs"), l2 = yield e.l(n2, new AbortController());
            if (!l2 || !l2.data)
              throw new Error(`Could not load glyph range. range: ${i2}, ${o2}-${r2}`);
            const h2 = {};
            for (const t3 of e.n(l2.data))
              h2[t3.id] = t3;
            return h2;
          });
        }, S.TinySDF = class {
          constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: i2 = 8, cutoff: s2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: r2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = s2, this.radius = i2;
            const n2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(n2), h2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            h2.font = `${r2} ${o2} ${t2}px ${a2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
          }
          _createCanvas(t2) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t2, e2;
          }
          draw(t2) {
            const { width: e2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: s2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: o2 } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - a2))), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(s2)), h2 = n2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, u2 = Math.max(h2 * c2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: h2, height: c2, glyphWidth: n2, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === n2 || 0 === l2)
              return _2;
            const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
            p2.clearRect(m2, m2, n2, l2), p2.fillText(t2, m2, m2 + r2);
            const v2 = p2.getImageData(m2, m2, n2, l2);
            g2.fill(I, 0, u2), f2.fill(0, 0, u2);
            for (let t3 = 0; t3 < l2; t3++)
              for (let e3 = 0; e3 < n2; e3++) {
                const i3 = v2.data[4 * (t3 * n2 + e3) + 3] / 255;
                if (0 === i3)
                  continue;
                const s3 = (t3 + m2) * h2 + e3 + m2;
                if (1 === i3)
                  g2[s3] = 0, f2[s3] = I;
                else {
                  const t4 = 0.5 - i3;
                  g2[s3] = t4 > 0 ? t4 * t4 : 0, f2[s3] = t4 < 0 ? t4 * t4 : 0;
                }
              }
            E(g2, 0, 0, h2, c2, h2, this.f, this.v, this.z), E(f2, m2, m2, n2, l2, h2, this.f, this.v, this.z);
            for (let t3 = 0; t3 < u2; t3++) {
              const e3 = Math.sqrt(g2[t3]) - Math.sqrt(f2[t3]);
              d2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return _2;
          }
        };
        class P {
          constructor() {
            this.specification = e.v.light.position;
          }
          possiblyEvaluate(t2, i2) {
            return e.y(t2.expression.evaluate(i2));
          }
          interpolate(t2, i2, s2) {
            return { x: e.z.number(t2.x, i2.x, s2), y: e.z.number(t2.y, i2.y, s2), z: e.z.number(t2.z, i2.z, s2) };
          }
        }
        let D;
        class z extends e.E {
          constructor(t2) {
            super(), D = D || new e.q({ anchor: new e.D(e.v.light.anchor), position: new P(), color: new e.D(e.v.light.color), intensity: new e.D(e.v.light.intensity) }), this._transitionable = new e.T(D), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t2, i2 = {}) {
            if (!this._validate(e.r, t2, i2))
              for (const e2 in t2) {
                const i3 = t2[e2];
                e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
              }
          }
          updateTransitions(t2) {
            this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t2) {
            this.properties = this._transitioning.possiblyEvaluate(t2);
          }
          _validate(t2, i2, s2) {
            return (!s2 || false !== s2.validate) && e.t(this, t2.call(e.x, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v }));
          }
        }
        class M {
          constructor(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t2, e2) {
            const i2 = t2.join(",") + String(e2);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
          }
          getDashRanges(t2, e2, i2) {
            const s2 = [];
            let a2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, o2 = t2[0] * i2, r2 = true;
            s2.push({ left: a2, right: o2, isDash: r2, zeroLength: 0 === t2[0] });
            let n2 = t2[0];
            for (let e3 = 1; e3 < t2.length; e3++) {
              r2 = !r2;
              const l2 = t2[e3];
              a2 = n2 * i2, n2 += l2, o2 = n2 * i2, s2.push({ left: a2, right: o2, isDash: r2, zeroLength: 0 === l2 });
            }
            return s2;
          }
          addRoundDash(t2, e2, i2) {
            const s2 = e2 / 2;
            for (let e3 = -i2; e3 <= i2; e3++) {
              const a2 = this.width * (this.nextRow + i2 + e3);
              let o2 = 0, r2 = t2[o2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / r2.right > 1 && (r2 = t2[++o2]);
                const l2 = Math.abs(n2 - r2.left), h2 = Math.abs(n2 - r2.right), c2 = Math.min(l2, h2);
                let u2;
                const d2 = e3 / i2 * (s2 + 1);
                if (r2.isDash) {
                  const t3 = s2 - Math.abs(d2);
                  u2 = Math.sqrt(c2 * c2 + t3 * t3);
                } else
                  u2 = s2 - Math.sqrt(c2 * c2 + d2 * d2);
                this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(t2) {
            for (let e3 = t2.length - 1; e3 >= 0; --e3) {
              const i3 = t2[e3], s3 = t2[e3 + 1];
              i3.zeroLength ? t2.splice(e3, 1) : s3 && s3.isDash === i3.isDash && (s3.left = i3.left, t2.splice(e3, 1));
            }
            const e2 = t2[0], i2 = t2[t2.length - 1];
            e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
            const s2 = this.width * this.nextRow;
            let a2 = 0, o2 = t2[a2];
            for (let e3 = 0; e3 < this.width; e3++) {
              e3 / o2.right > 1 && (o2 = t2[++a2]);
              const i3 = Math.abs(e3 - o2.left), r2 = Math.abs(e3 - o2.right), n2 = Math.min(i3, r2);
              this.data[s2 + e3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(t2, i2) {
            const s2 = i2 ? 7 : 0, a2 = 2 * s2 + 1;
            if (this.nextRow + a2 > this.height)
              return e.w("LineAtlas out of space"), null;
            let o2 = 0;
            for (let e2 = 0; e2 < t2.length; e2++)
              o2 += t2[e2];
            if (0 !== o2) {
              const e2 = this.width / o2, a3 = this.getDashRanges(t2, this.width, e2);
              i2 ? this.addRoundDash(a3, e2, s2) : this.addRegularDash(a3);
            }
            const r2 = { y: (this.nextRow + s2 + 0.5) / this.height, height: 2 * s2 / this.height, width: o2 };
            return this.nextRow += a2, this.dirty = true, r2;
          }
          bind(t2) {
            const e2 = t2.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          }
        }
        const A = "maplibre_preloaded_worker_pool";
        class R {
          constructor() {
            this.active = {};
          }
          acquire(t2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < R.workerCount; )
                this.workers.push(new Worker(e.a.WORKER_URL));
            return this.active[t2] = true, this.workers.slice();
          }
          release(t2) {
            delete this.active[t2], 0 === this.numActive() && (this.workers.forEach((t3) => {
              t3.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[A];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const L = Math.floor(o.hardwareConcurrency / 2);
        let k, F;
        function B() {
          return k || (k = new R()), k;
        }
        R.workerCount = e.B(globalThis) ? Math.max(Math.min(L, 3), 1) : 1;
        class O {
          constructor(t2, i2) {
            this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = i2;
            const s2 = this.workerPool.acquire(i2);
            for (let t3 = 0; t3 < s2.length; t3++) {
              const a2 = new e.C(s2[t3], i2);
              a2.name = `Worker ${t3}`, this.actors.push(a2);
            }
            if (!this.actors.length)
              throw new Error("No actors found");
          }
          broadcast(t2, e2) {
            const i2 = [];
            for (const s2 of this.actors)
              i2.push(s2.sendAsync({ type: t2, data: e2 }));
            return Promise.all(i2);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t2 = true) {
            this.actors.forEach((t3) => {
              t3.remove();
            }), this.actors = [], t2 && this.workerPool.release(this.id);
          }
          registerMessageHandler(t2, e2) {
            for (const i2 of this.actors)
              i2.registerMessageHandler(t2, e2);
          }
        }
        function N() {
          return F || (F = new O(B(), e.G), F.registerMessageHandler("GR", (t2, i2, s2) => e.m(i2, s2))), F;
        }
        function U(t2, i2) {
          const s2 = e.F();
          return e.H(s2, s2, [1, 1, 0]), e.J(s2, s2, [0.5 * t2.width, 0.5 * t2.height, 1]), e.K(s2, s2, t2.calculatePosMatrix(i2.toUnwrapped()));
        }
        function Z(t2, e2, i2, s2, a2, o2) {
          const r2 = function(t3, e3, i3) {
            if (t3)
              for (const s3 of t3) {
                const t4 = e3[s3];
                if (t4 && t4.source === i3 && "fill-extrusion" === t4.type)
                  return true;
              }
            else
              for (const t4 in e3) {
                const s3 = e3[t4];
                if (s3.source === i3 && "fill-extrusion" === s3.type)
                  return true;
              }
            return false;
          }(a2 && a2.layers, e2, t2.id), n2 = o2.maxPitchScaleFactor(), l2 = t2.tilesIn(s2, n2, r2);
          l2.sort(G);
          const h2 = [];
          for (const s3 of l2)
            h2.push({ wrappedTileID: s3.tileID.wrapped().key, queryResults: s3.tile.queryRenderedFeatures(e2, i2, t2._state, s3.queryGeometry, s3.cameraQueryGeometry, s3.scale, a2, o2, n2, U(t2.transform, s3.tileID)) });
          const c2 = function(t3) {
            const e3 = {}, i3 = {};
            for (const s3 of t3) {
              const t4 = s3.queryResults, a3 = s3.wrappedTileID, o3 = i3[a3] = i3[a3] || {};
              for (const i4 in t4) {
                const s4 = t4[i4], a4 = o3[i4] = o3[i4] || {}, r3 = e3[i4] = e3[i4] || [];
                for (const t5 of s4)
                  a4[t5.featureIndex] || (a4[t5.featureIndex] = true, r3.push(t5));
              }
            }
            return e3;
          }(h2);
          for (const e3 in c2)
            c2[e3].forEach((e4) => {
              const i3 = e4.feature, s3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
              i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = s3;
            });
          return c2;
        }
        function G(t2, e2) {
          const i2 = t2.tileID, s2 = e2.tileID;
          return i2.overscaledZ - s2.overscaledZ || i2.canonical.y - s2.canonical.y || i2.wrap - s2.wrap || i2.canonical.x - s2.canonical.x;
        }
        function q(t2, i2, s2) {
          return e._(this, void 0, void 0, function* () {
            let a2 = t2;
            if (t2.url ? a2 = (yield e.h(i2.transformRequest(t2.url, "Source"), s2)).data : yield o.frameAsync(s2), !a2)
              return null;
            const r2 = e.L(e.e(a2, t2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in a2 && a2.vector_layers && (r2.vectorLayerIds = a2.vector_layers.map((t3) => t3.id)), r2;
          });
        }
        class j {
          constructor(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : Array.isArray(t2) && (4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1])));
          }
          setNorthEast(t2) {
            return this._ne = t2 instanceof e.M ? new e.M(t2.lng, t2.lat) : e.M.convert(t2), this;
          }
          setSouthWest(t2) {
            return this._sw = t2 instanceof e.M ? new e.M(t2.lng, t2.lat) : e.M.convert(t2), this;
          }
          extend(t2) {
            const i2 = this._sw, s2 = this._ne;
            let a2, o2;
            if (t2 instanceof e.M)
              a2 = t2, o2 = t2;
            else {
              if (!(t2 instanceof j))
                return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(j.convert(t2)) : this.extend(e.M.convert(t2)) : t2 && ("lng" in t2 || "lon" in t2) && "lat" in t2 ? this.extend(e.M.convert(t2)) : this;
              if (a2 = t2._sw, o2 = t2._ne, !a2 || !o2)
                return this;
            }
            return i2 || s2 ? (i2.lng = Math.min(a2.lng, i2.lng), i2.lat = Math.min(a2.lat, i2.lat), s2.lng = Math.max(o2.lng, s2.lng), s2.lat = Math.max(o2.lat, s2.lat)) : (this._sw = new e.M(a2.lng, a2.lat), this._ne = new e.M(o2.lng, o2.lat)), this;
          }
          getCenter() {
            return new e.M((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new e.M(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new e.M(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t2) {
            const { lng: i2, lat: s2 } = e.M.convert(t2);
            let a2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (a2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= s2 && s2 <= this._ne.lat && a2;
          }
          static convert(t2) {
            return t2 instanceof j ? t2 : t2 ? new j(t2) : t2;
          }
          static fromLngLat(t2, i2 = 0) {
            const s2 = 360 * i2 / 40075017, a2 = s2 / Math.cos(Math.PI / 180 * t2.lat);
            return new j(new e.M(t2.lng - a2, t2.lat - s2), new e.M(t2.lng + a2, t2.lat + s2));
          }
        }
        class V {
          constructor(t2, e2, i2) {
            this.bounds = j.convert(this.validateBounds(t2)), this.minzoom = e2 || 0, this.maxzoom = i2 || 24;
          }
          validateBounds(t2) {
            return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
          }
          contains(t2) {
            const i2 = Math.pow(2, t2.z), s2 = Math.floor(e.N(this.bounds.getWest()) * i2), a2 = Math.floor(e.O(this.bounds.getNorth()) * i2), o2 = Math.ceil(e.N(this.bounds.getEast()) * i2), r2 = Math.ceil(e.O(this.bounds.getSouth()) * i2);
            return t2.x >= s2 && t2.x < o2 && t2.y >= a2 && t2.y < r2;
          }
        }
        class H extends e.E {
          constructor(t2, i2, s2, a2) {
            if (super(), this.id = t2, this.dispatcher = s2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.e(this, e.L(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t2 = yield q(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new V(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t2) {
                this._tileJSONRequest = null, this.fire(new e.j(t2));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return e.e({}, this._options);
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(e2, "Tile"), uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              i2.request.collectResourceTiming = this._collectResourceTiming;
              let s2 = "RT";
              if (t2.actor && "expired" !== t2.state) {
                if ("loading" === t2.state)
                  return new Promise((e3, i3) => {
                    t2.reloadPromise = { resolve: e3, reject: i3 };
                  });
              } else
                t2.actor = this.dispatcher.getActor(), s2 = "LT";
              t2.abortController = new AbortController();
              try {
                const e3 = yield t2.actor.sendAsync({ type: s2, data: i2 }, t2.abortController);
                if (delete t2.abortController, t2.aborted)
                  return;
                this._afterTileLoadWorkerResponse(t2, e3);
              } catch (e3) {
                if (delete t2.abortController, t2.aborted)
                  return;
                if (e3 && 404 !== e3.status)
                  throw e3;
                this._afterTileLoadWorkerResponse(t2, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(t2, e2) {
            if (e2 && e2.resourceTiming && (t2.resourceTiming = e2.resourceTiming), e2 && this.map._refreshExpiredTiles && t2.setExpiryData(e2), t2.loadVectorData(e2, this.map.painter), t2.reloadPromise) {
              const e3 = t2.reloadPromise;
              t2.reloadPromise = null, this.loadTile(t2).then(e3.resolve).catch(e3.reject);
            }
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.actor && (yield t2.actor.sendAsync({ type: "AT", data: { uid: t2.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.unloadVectorData(), t2.actor && (yield t2.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return false;
          }
        }
        class W extends e.E {
          constructor(t2, i2, s2, a2) {
            super(), this.id = t2, this.dispatcher = s2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.e({ type: "raster" }, i2), e.e(this, e.L(i2, ["url", "scheme", "tileSize"]));
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t2 = yield q(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new V(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t2) {
                this._tileJSONRequest = null, this.fire(new e.j(t2));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t2) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t2(), this.load();
          }
          setTiles(t2) {
            return this.setSourceProperty(() => {
              this._options.tiles = t2;
            }), this;
          }
          setUrl(t2) {
            return this.setSourceProperty(() => {
              this.url = t2, this._options.url = t2;
            }), this;
          }
          serialize() {
            return e.e({}, this._options);
          }
          hasTile(t2) {
            return !this.tileBounds || this.tileBounds.contains(t2.canonical);
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t2.abortController = new AbortController();
              try {
                const i2 = yield _.getImage(this.map._requestManager.transformRequest(e2, "Tile"), t2.abortController, this.map._refreshExpiredTiles);
                if (delete t2.abortController, t2.aborted)
                  return void (t2.state = "unloaded");
                if (i2 && i2.data) {
                  this.map._refreshExpiredTiles && i2.cacheControl && i2.expires && t2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                  const e3 = this.map.painter.context, s2 = e3.gl, a2 = i2.data;
                  t2.texture = this.map.painter.getTileTexture(a2.width), t2.texture ? t2.texture.update(a2, { useMipmap: true }) : (t2.texture = new b(e3, a2, s2.RGBA, { useMipmap: true }), t2.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), e3.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, e3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e3.extTextureFilterAnisotropicMax)), t2.state = "loaded";
                }
              } catch (e3) {
                if (delete t2.abortController, t2.aborted)
                  t2.state = "unloaded";
                else if (e3)
                  throw t2.state = "errored", e3;
              }
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController);
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.texture && this.map.painter.saveTileTexture(t2.texture);
            });
          }
          hasTransition() {
            return false;
          }
        }
        class $ extends W {
          constructor(t2, i2, s2, a2) {
            super(t2, i2, s2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s2 = this.map._requestManager.transformRequest(i2, "Tile");
              t2.neighboringTiles = this._getNeighboringTiles(t2.tileID), t2.abortController = new AbortController();
              try {
                const i3 = yield _.getImage(s2, t2.abortController, this.map._refreshExpiredTiles);
                if (delete t2.abortController, t2.aborted)
                  return void (t2.state = "unloaded");
                if (i3 && i3.data) {
                  const s3 = i3.data;
                  this.map._refreshExpiredTiles && i3.cacheControl && i3.expires && t2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                  const a2 = e.b(s3) && e.S() ? s3 : yield this.readImageNow(s3), o2 = { type: this.type, uid: t2.uid, source: this.id, rawImageData: a2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t2.actor || "expired" === t2.state) {
                    t2.actor = this.dispatcher.getActor();
                    const e2 = yield t2.actor.sendAsync({ type: "LDT", data: o2 });
                    t2.dem = e2, t2.needsHillshadePrepare = true, t2.needsTerrainPrepare = true, t2.state = "loaded";
                  }
                }
              } catch (e2) {
                if (delete t2.abortController, t2.aborted)
                  t2.state = "unloaded";
                else if (e2)
                  throw t2.state = "errored", e2;
              }
            });
          }
          readImageNow(t2) {
            return e._(this, void 0, void 0, function* () {
              if ("undefined" != typeof VideoFrame && e.U()) {
                const i2 = t2.width + 2, s2 = t2.height + 2;
                try {
                  return new e.R({ width: i2, height: s2 }, yield e.V(t2, -1, -1, i2, s2));
                } catch (t3) {
                }
              }
              return o.getImageData(t2, 1);
            });
          }
          _getNeighboringTiles(t2) {
            const i2 = t2.canonical, s2 = Math.pow(2, i2.z), a2 = (i2.x - 1 + s2) % s2, o2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, r2 = (i2.x + 1 + s2) % s2, n2 = i2.x + 1 === s2 ? t2.wrap + 1 : t2.wrap, l2 = {};
            return l2[new e.Q(t2.overscaledZ, o2, i2.z, a2, i2.y).key] = { backfilled: false }, l2[new e.Q(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.Q(t2.overscaledZ, o2, i2.z, a2, i2.y - 1).key] = { backfilled: false }, l2[new e.Q(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.Q(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < s2 && (l2[new e.Q(t2.overscaledZ, o2, i2.z, a2, i2.y + 1).key] = { backfilled: false }, l2[new e.Q(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.Q(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && (yield t2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t2.uid, source: this.id } }));
            });
          }
        }
        class X extends e.E {
          constructor(t2, i2, s2, a2) {
            super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s2.getActor(), this.setEventedParent(a2), this._data = i2.data, this._options = e.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
            const o2 = e.W / this.tileSize;
            this.workerOptions = e.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * o2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * o2, extent: e.W, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.W, radius: (i2.clusterRadius || 50) * o2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          setData(t2) {
            return this._data = t2, this._updateWorkerData(), this;
          }
          updateData(t2) {
            return this._updateWorkerData(t2), this;
          }
          setClusterOptions(t2) {
            return this.workerOptions.cluster = t2.cluster, t2 && (void 0 !== t2.clusterRadius && (this.workerOptions.superclusterOptions.radius = t2.clusterRadius), void 0 !== t2.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t2.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t2) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t2, source: this.id } });
          }
          getClusterChildren(t2) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t2, source: this.id } });
          }
          getClusterLeaves(t2, e2, i2) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t2, limit: e2, offset: i2 } });
          }
          _updateWorkerData(t2) {
            return e._(this, void 0, void 0, function* () {
              const i2 = e.e({ type: this.type }, this.workerOptions);
              t2 ? i2.dataDiff = t2 : "string" == typeof this._data ? (i2.request = this.map._requestManager.transformRequest(o.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new e.k("dataloading", { dataType: "source" }));
              try {
                const t3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
                if (this._pendingLoads--, this._removed || t3.abandoned)
                  return void this.fire(new e.k("dataabort", { dataType: "source" }));
                let s2 = null;
                t3.resourceTiming && t3.resourceTiming[this.id] && (s2 = t3.resourceTiming[this.id].slice(0));
                const a2 = { dataType: "source" };
                this._collectResourceTiming && s2 && s2.length > 0 && e.e(a2, { resourceTiming: s2 }), this.fire(new e.k("data", Object.assign(Object.assign({}, a2), { sourceDataType: "metadata" }))), this.fire(new e.k("data", Object.assign(Object.assign({}, a2), { sourceDataType: "content" })));
              } catch (t3) {
                if (this._pendingLoads--, this._removed)
                  return void this.fire(new e.k("dataabort", { dataType: "source" }));
                this.fire(new e.j(t3));
              }
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = t2.actor ? "RT" : "LT";
              t2.actor = this.actor;
              const i2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t2.abortController = new AbortController();
              const s2 = yield this.actor.sendAsync({ type: e2, data: i2 }, t2.abortController);
              delete t2.abortController, t2.unloadVectorData(), t2.aborted || t2.loadVectorData(s2, this.map.painter, "RT" === e2);
            });
          }
          abortTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.aborted = true;
            });
          }
          unloadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              t2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return e.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        var K = e.X([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Y extends e.E {
          constructor(t2, e2, i2, s2) {
            super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(s2), this.options = e2;
          }
          load(t2) {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const e2 = yield _.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, e2 && e2.data && (this.image = e2.data, t2 && (this.coordinates = t2), this._finishLoading());
              } catch (t3) {
                this._request = null, this._loaded = true, this.fire(new e.j(t3));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t2) {
            return t2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t2.url, this.load(t2.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t2) {
            this.map = t2, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t2) {
            this.coordinates = t2;
            const i2 = t2.map(e.Y.fromLngLat);
            this.tileID = function(t3) {
              let i3 = 1 / 0, s3 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
              for (const e2 of t3)
                i3 = Math.min(i3, e2.x), s3 = Math.min(s3, e2.y), a2 = Math.max(a2, e2.x), o2 = Math.max(o2, e2.y);
              const r2 = Math.max(a2 - i3, o2 - s3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
              return new e.a0(n2, Math.floor((i3 + a2) / 2 * l2), Math.floor((s3 + o2) / 2 * l2));
            }(i2), this.minzoom = this.maxzoom = this.tileID.z;
            const s2 = i2.map((t3) => this.tileID.getTilePoint(t3)._round());
            return this._boundsArray = new e.Z(), this._boundsArray.emplaceBack(s2[0].x, s2[0].y, 0, 0), this._boundsArray.emplaceBack(s2[1].x, s2[1].y, e.W, 0), this._boundsArray.emplaceBack(s2[3].x, s2[3].y, 0, e.W), this._boundsArray.emplaceBack(s2[2].x, s2[2].y, e.W, e.W), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image)
              return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, K.members)), this.boundsSegments || (this.boundsSegments = e.$.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new b(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let s2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, s2 = true);
            }
            s2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t2) {
            return e._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}) : t2.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        class J extends Y {
          constructor(t2, e2, i2, s2) {
            super(t2, e2, i2, s2), this.roundZoom = true, this.type = "video", this.options = e2;
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = false;
              const t2 = this.options;
              this.urls = [];
              for (const e2 of t2.urls)
                this.urls.push(this.map._requestManager.transformRequest(e2, "Source").url);
              try {
                const t3 = yield e.a2(this.urls);
                if (this._loaded = true, !t3)
                  return;
                this.video = t3, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (t3) {
                this.fire(new e.j(t3));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t2) {
            if (this.video) {
              const i2 = this.video.seekable;
              t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.j(new e.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t2) {
            this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const t2 = this.map.painter.context, i2 = t2.gl;
            this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, K.members)), this.boundsSegments || (this.boundsSegments = e.$.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new b(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
            let s2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, s2 = true);
            }
            s2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Q extends Y {
          constructor(t2, i2, s2, a2) {
            super(t2, i2, s2, a2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((t3) => !Array.isArray(t3) || 2 !== t3.length || t3.some((t4) => "number" != typeof t4)) || this.fire(new e.j(new e.a1(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.j(new e.a1(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.j(new e.a1(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.j(new e.a1(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.j(new e.a1(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
          }
          load() {
            return e._(this, void 0, void 0, function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t2) {
            this.map = t2, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t2 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i2 = this.map.painter.context, s2 = i2.gl;
            this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, K.members)), this.boundsSegments || (this.boundsSegments = e.$.simpleSegment(0, 0, 4, 2)), this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new b(i2, this.canvas, s2.RGBA, { premultiply: true });
            let a2 = false;
            for (const t3 in this.tiles) {
              const e2 = this.tiles[t3];
              "loaded" !== e2.state && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
            }
            a2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t2 of [this.canvas.width, this.canvas.height])
              if (isNaN(t2) || t2 <= 0)
                return true;
            return false;
          }
        }
        const tt = {}, et = (t2) => {
          switch (t2) {
            case "geojson":
              return X;
            case "image":
              return Y;
            case "raster":
              return W;
            case "raster-dem":
              return $;
            case "vector":
              return H;
            case "video":
              return J;
            case "canvas":
              return Q;
          }
          return tt[t2];
        }, it = "RTLPluginLoaded";
        class st extends e.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = N();
          }
          _syncState(t2) {
            return this.status = t2, this.dispatcher.broadcast("SRPS", { pluginStatus: t2, pluginURL: this.url }).catch((t3) => {
              throw this.status = "error", t3;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(t2) {
            return e._(this, arguments, void 0, function* (t3, e2 = false) {
              if (this.url)
                throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = o.resolveURL(t3), !this.url)
                throw new Error(`requested url ${t3} is invalid`);
              if ("unavailable" === this.status) {
                if (!e2)
                  return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if ("requested" === this.status)
                return this._requestImport();
            });
          }
          _requestImport() {
            return e._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new e.k(it));
            });
          }
          lazyLoad() {
            "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
          }
        }
        let at = null;
        function ot() {
          return at || (at = new st()), at;
        }
        class rt {
          constructor(t2, i2) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t2, this.uid = e.a3(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(t2) {
            const e2 = t2 + this.timeAdded;
            e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(t2) {
            this.demTexture && t2.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t2, i2, s2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
              t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e2) {
                const i3 = {};
                if (!e2)
                  return i3;
                for (const s3 of t3) {
                  const t4 = s3.layerIds.map((t5) => e2.getLayer(t5)).filter(Boolean);
                  if (0 !== t4.length) {
                    s3.layers = t4, s3.stateDependentLayerIds && (s3.stateDependentLayers = s3.stateDependentLayerIds.map((e3) => t4.filter((t5) => t5.id === e3)[0]));
                    for (const e3 of t4)
                      i3[e3.id] = s3;
                  }
                }
                return i3;
              }(t2.buckets, i2.style), this.hasSymbolBuckets = false;
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.a5) {
                  if (this.hasSymbolBuckets = true, !s2)
                    break;
                  i3.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t3 in this.buckets) {
                  const i3 = this.buckets[t3];
                  if (i3 instanceof e.a5 && i3.hasRTLText) {
                    this.hasRTLText = true, ot().lazyLoad();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t3 in this.buckets) {
                const e2 = this.buckets[t3];
                this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t3).queryRadius(e2));
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
            } else
              this.collisionBoxArray = new e.a4();
          }
          unloadVectorData() {
            for (const t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t2) {
            return this.buckets[t2.id];
          }
          upload(t2) {
            for (const e3 in this.buckets) {
              const i2 = this.buckets[e3];
              i2.uploadPending() && i2.upload(t2);
            }
            const e2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new b(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new b(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t2, e2, i2, s2, a2, o2, r2, n2, l2, h2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s2, cameraQueryGeometry: a2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: h2, transform: n2, params: r2, queryPadding: this.queryPadding * l2 }, t2, e2, i2) : {};
          }
          querySourceFeatures(t2, i2) {
            const s2 = this.latestFeatureIndex;
            if (!s2 || !s2.rawTileData)
              return;
            const a2 = s2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", r2 = a2._geojsonTileLayer || a2[o2];
            if (!r2)
              return;
            const n2 = e.a6(i2 && i2.filter), { z: l2, x: h2, y: c2 } = this.tileID.canonical, u2 = { z: l2, x: h2, y: c2 };
            for (let i3 = 0; i3 < r2.length; i3++) {
              const a3 = r2.feature(i3);
              if (n2.needGeometry) {
                const t3 = e.a7(a3, true);
                if (!n2.filter(new e.a8(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  continue;
              } else if (!n2.filter(new e.a8(this.tileID.overscaledZ), a3))
                continue;
              const d2 = s2.getId(a3, o2), _2 = new e.a9(a3, l2, h2, c2, d2);
              _2.tile = u2, t2.push(_2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t2) {
            const i2 = this.expirationTime;
            if (t2.cacheControl) {
              const i3 = e.aa(t2.cacheControl);
              i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
            } else
              t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              const t3 = Date.now();
              let e2 = false;
              if (this.expirationTime > t3)
                e2 = false;
              else if (i2)
                if (this.expirationTime < i2)
                  e2 = true;
                else {
                  const s2 = this.expirationTime - i2;
                  s2 ? this.expirationTime = t3 + Math.max(s2, 3e4) : e2 = true;
                }
              else
                e2 = true;
              e2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t2, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length)
              return;
            const i2 = this.latestFeatureIndex.loadVTLayers();
            for (const s2 in this.buckets) {
              if (!e2.style.hasLayer(s2))
                continue;
              const a2 = this.buckets[s2], o2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[o2], n2 = t2[o2];
              if (!r2 || !n2 || 0 === Object.keys(n2).length)
                continue;
              a2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l2 = e2 && e2.style && e2.style.getLayer(s2);
              l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t2) {
            this.symbolFadeHoldUntil = o.now() + t2;
          }
          setDependencies(t2, e2) {
            const i2 = {};
            for (const t3 of e2)
              i2[t3] = true;
            this.dependencies[t2] = i2;
          }
          hasDependency(t2, e2) {
            for (const i2 of t2) {
              const t3 = this.dependencies[i2];
              if (t3) {
                for (const i3 of e2)
                  if (t3[i3])
                    return true;
              }
            }
            return false;
          }
        }
        class nt {
          constructor(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t2 in this.data)
              for (const e2 of this.data[t2])
                e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t2, e2, i2) {
            const s2 = t2.wrapped().key;
            void 0 === this.data[s2] && (this.data[s2] = []);
            const a2 = { value: e2, timeout: void 0 };
            if (void 0 !== i2 && (a2.timeout = setTimeout(() => {
              this.remove(t2, a2);
            }, i2)), this.data[s2].push(a2), this.order.push(s2), this.order.length > this.max) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          has(t2) {
            return t2.wrapped().key in this.data;
          }
          getAndRemove(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }
          _getAndRemoveByKey(t2) {
            const e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }
          getByKey(t2) {
            const e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }
          get(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }
          remove(t2, e2) {
            if (!this.has(t2))
              return this;
            const i2 = t2.wrapped().key, s2 = void 0 === e2 ? 0 : this.data[i2].indexOf(e2), a2 = this.data[i2][s2];
            return this.data[i2].splice(s2, 1), a2.timeout && clearTimeout(a2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }
          setMaxSize(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              const t3 = this._getAndRemoveByKey(this.order[0]);
              t3 && this.onRemove(t3);
            }
            return this;
          }
          filter(t2) {
            const e2 = [];
            for (const i2 in this.data)
              for (const s2 of this.data[i2])
                t2(s2.value) || e2.push(s2);
            for (const t3 of e2)
              this.remove(t3.value.tileID, t3);
          }
        }
        class lt {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t2, i2, s2) {
            const a2 = String(i2);
            if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][a2] = this.stateChanges[t2][a2] || {}, e.e(this.stateChanges[t2][a2], s2), null === this.deletedStates[t2]) {
              this.deletedStates[t2] = {};
              for (const e2 in this.state[t2])
                e2 !== a2 && (this.deletedStates[t2][e2] = null);
            } else if (this.deletedStates[t2] && null === this.deletedStates[t2][a2]) {
              this.deletedStates[t2][a2] = {};
              for (const e2 in this.state[t2][a2])
                s2[e2] || (this.deletedStates[t2][a2][e2] = null);
            } else
              for (const e2 in s2)
                this.deletedStates[t2] && this.deletedStates[t2][a2] && null === this.deletedStates[t2][a2][e2] && delete this.deletedStates[t2][a2][e2];
          }
          removeFeatureState(t2, e2, i2) {
            if (null === this.deletedStates[t2])
              return;
            const s2 = String(e2);
            if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && void 0 !== e2)
              null !== this.deletedStates[t2][s2] && (this.deletedStates[t2][s2] = this.deletedStates[t2][s2] || {}, this.deletedStates[t2][s2][i2] = null);
            else if (void 0 !== e2)
              if (this.stateChanges[t2] && this.stateChanges[t2][s2])
                for (i2 in this.deletedStates[t2][s2] = {}, this.stateChanges[t2][s2])
                  this.deletedStates[t2][s2][i2] = null;
              else
                this.deletedStates[t2][s2] = null;
            else
              this.deletedStates[t2] = null;
          }
          getState(t2, i2) {
            const s2 = String(i2), a2 = e.e({}, (this.state[t2] || {})[s2], (this.stateChanges[t2] || {})[s2]);
            if (null === this.deletedStates[t2])
              return {};
            if (this.deletedStates[t2]) {
              const e2 = this.deletedStates[t2][i2];
              if (null === e2)
                return {};
              for (const t3 in e2)
                delete a2[t3];
            }
            return a2;
          }
          initializeTileState(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }
          coalesceChanges(t2, i2) {
            const s2 = {};
            for (const t3 in this.stateChanges) {
              this.state[t3] = this.state[t3] || {};
              const i3 = {};
              for (const s3 in this.stateChanges[t3])
                this.state[t3][s3] || (this.state[t3][s3] = {}), e.e(this.state[t3][s3], this.stateChanges[t3][s3]), i3[s3] = this.state[t3][s3];
              s2[t3] = i3;
            }
            for (const t3 in this.deletedStates) {
              this.state[t3] = this.state[t3] || {};
              const i3 = {};
              if (null === this.deletedStates[t3])
                for (const e2 in this.state[t3])
                  i3[e2] = {}, this.state[t3][e2] = {};
              else
                for (const e2 in this.deletedStates[t3]) {
                  if (null === this.deletedStates[t3][e2])
                    this.state[t3][e2] = {};
                  else
                    for (const i4 of Object.keys(this.deletedStates[t3][e2]))
                      delete this.state[t3][e2][i4];
                  i3[e2] = this.state[t3][e2];
                }
              s2[t3] = s2[t3] || {}, e.e(s2[t3], i3);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s2).length)
              for (const e2 in t2)
                t2[e2].setFeatureState(s2, i2);
          }
        }
        class ht extends e.E {
          constructor(t2, e2, i2) {
            super(), this.id = t2, this.dispatcher = i2, this.on("data", (t3) => this._dataHandler(t3)), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((t3, e3, i3, s2) => {
              const a2 = new (et(e3.type))(t3, e3, i3, s2);
              if (a2.id !== t3)
                throw new Error(`Expected Source id to be ${t3} instead of ${a2.id}`);
              return a2;
            })(t2, e2, i2, this), this._tiles = {}, this._cache = new nt(0, (t3) => this._unloadTile(t3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new lt(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t2) {
            this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t2 ? t2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t2);
          }
          onRemove(t2) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
              return true;
            if (!this._updated)
              return false;
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if ("loaded" !== e2.state && "errored" !== e2.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t2 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t2, i2, s2) {
            return e._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(t2), this._tileLoaded(t2, i2, s2);
              } catch (i3) {
                t2.state = "errored", 404 !== i3.status ? this._source.fire(new e.j(i3, { tile: t2 })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(t2) {
            this._source.unloadTile && this._source.unloadTile(t2);
          }
          _abortTile(t2) {
            this._source.abortTile && this._source.abortTile(t2), this._source.fire(new e.k("dataabort", { tile: t2, coord: t2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t2) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const i2 = this._tiles[e2];
              i2.upload(t2), i2.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t2) => t2.tileID).sort(ct).map((t2) => t2.key);
          }
          getRenderableIds(t2) {
            const i2 = [];
            for (const e2 in this._tiles)
              this._isIdRenderable(e2, t2) && i2.push(this._tiles[e2]);
            return t2 ? i2.sort((t3, i3) => {
              const s2 = t3.tileID, a2 = i3.tileID, o2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle), r2 = new e.P(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
              return s2.overscaledZ - a2.overscaledZ || r2.y - o2.y || r2.x - o2.x;
            }).map((t3) => t3.tileID.key) : i2.map((t3) => t3.tileID).sort(ct).map((t3) => t3.key);
          }
          hasRenderableParent(t2) {
            const e2 = this.findLoadedParent(t2, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t2, e2) {
            return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t2 in this._tiles)
                "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
            }
          }
          _reloadTile(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const e2 = this._tiles[t2];
              e2 && ("loading" !== e2.state && (e2.state = i2), yield this._loadTile(e2, t2, i2));
            });
          }
          _tileLoaded(t2, i2, s2) {
            t2.timeAdded = o.now(), "expired" === s2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), "raster-dem" === this.getSource().type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), t2.aborted || this._source.fire(new e.k("data", { dataType: "source", tile: t2, coord: t2.tileID }));
          }
          _backfillDEM(t2) {
            const e2 = this.getRenderableIds();
            for (let s2 = 0; s2 < e2.length; s2++) {
              const a2 = e2[s2];
              if (t2.neighboringTiles && t2.neighboringTiles[a2]) {
                const e3 = this.getTileByID(a2);
                i2(t2, e3), i2(e3, t2);
              }
            }
            function i2(t3, e3) {
              t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
              let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
              const s2 = e3.tileID.canonical.y - t3.tileID.canonical.y, a2 = Math.pow(2, t3.tileID.canonical.z), o2 = e3.tileID.key;
              0 === i3 && 0 === s2 || Math.abs(s2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + a2) ? i3 += a2 : 1 === Math.abs(i3 - a2) && (i3 -= a2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, s2), t3.neighboringTiles && t3.neighboringTiles[o2] && (t3.neighboringTiles[o2].backfilled = true)));
            }
          }
          getTile(t2) {
            return this.getTileByID(t2.key);
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          _retainLoadedChildren(t2, e2, i2, s2) {
            for (const a2 in this._tiles) {
              let o2 = this._tiles[a2];
              if (s2[a2] || !o2.hasData() || o2.tileID.overscaledZ <= e2 || o2.tileID.overscaledZ > i2)
                continue;
              let r2 = o2.tileID;
              for (; o2 && o2.tileID.overscaledZ > e2 + 1; ) {
                const t3 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
                o2 = this._tiles[t3.key], o2 && o2.hasData() && (r2 = t3);
              }
              let n2 = r2;
              for (; n2.overscaledZ > e2; )
                if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                  s2[r2.key] = r2;
                  break;
                }
            }
          }
          findLoadedParent(t2, e2) {
            if (t2.key in this._loadedParentTiles) {
              const i2 = this._loadedParentTiles[t2.key];
              return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
            }
            for (let i2 = t2.overscaledZ - 1; i2 >= e2; i2--) {
              const e3 = t2.scaledTo(i2), s2 = this._getLoadedTile(e3);
              if (s2)
                return s2;
            }
          }
          _getLoadedTile(t2) {
            const e2 = this._tiles[t2.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
          }
          updateCacheSize(t2) {
            const i2 = Math.ceil(t2.width / this._source.tileSize) + 1, s2 = Math.ceil(t2.height / this._source.tileSize) + 1, a2 = Math.floor(i2 * s2 * (null === this._maxTileCacheZoomLevels ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a2) : a2;
            this._cache.setMaxSize(o2);
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
            if (this._prevLng = t2, e2) {
              const t3 = {};
              for (const i2 in this._tiles) {
                const s2 = this._tiles[i2];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e2), t3[s2.tileID.key] = s2;
              }
              this._tiles = t3;
              for (const t4 in this._timers)
                clearTimeout(this._timers[t4]), delete this._timers[t4];
              for (const t4 in this._tiles)
                this._setTileReloadTimer(t4, this._tiles[t4]);
            }
          }
          update(t2, i2) {
            if (!this._sourceLoaded || this._paused)
              return;
            let s2;
            this.transform = t2, this.terrain = i2, this.updateCacheSize(t2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.Q(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (s2 = t2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (s2 = s2.filter((t3) => this._source.hasTile(t3)))) : s2 = [];
            const a2 = t2.coveringZoomLevel(this._source), r2 = Math.max(a2 - ht.maxOverzooming, this._source.minzoom), n2 = Math.max(a2 + ht.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const t3 = {};
              for (const e2 of s2)
                if (e2.canonical.z > this._source.minzoom) {
                  const i3 = e2.scaledTo(e2.canonical.z - 1);
                  t3[i3.key] = i3;
                  const s3 = e2.scaledTo(Math.max(this._source.minzoom, Math.min(e2.canonical.z, 5)));
                  t3[s3.key] = s3;
                }
              s2 = s2.concat(Object.values(t3));
            }
            const l2 = 0 === s2.length && !this._updated && this._didEmitContent;
            this._updated = true, l2 && this.fire(new e.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const h2 = this._updateRetainedTiles(s2, a2);
            if (ut(this._source.type)) {
              const t3 = {}, e2 = {}, l3 = Object.keys(h2), c3 = o.now();
              for (const i3 of l3) {
                const s3 = h2[i3], a3 = this._tiles[i3];
                if (!a3 || 0 !== a3.fadeEndTime && a3.fadeEndTime <= c3)
                  continue;
                const o2 = this.findLoadedParent(s3, r2);
                o2 && (this._addTile(o2.tileID), t3[o2.tileID.key] = o2.tileID), e2[i3] = s3;
              }
              this._retainLoadedChildren(e2, a2, n2, h2);
              for (const e3 in t3)
                h2[e3] || (this._coveredTiles[e3] = true, h2[e3] = t3[e3]);
              if (i2) {
                const t4 = {}, e3 = {};
                for (const i3 of s2)
                  this._tiles[i3.key].hasData() ? t4[i3.key] = i3 : e3[i3.key] = i3;
                for (const i3 in e3) {
                  const s3 = e3[i3].children(this._source.maxzoom);
                  this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (t4[s3[0].key] = h2[s3[0].key] = s3[0], t4[s3[1].key] = h2[s3[1].key] = s3[1], t4[s3[2].key] = h2[s3[2].key] = s3[2], t4[s3[3].key] = h2[s3[3].key] = s3[3], delete e3[i3]);
                }
                for (const i3 in e3) {
                  const s3 = this.findLoadedParent(e3[i3], this._source.minzoom);
                  if (s3) {
                    t4[s3.tileID.key] = h2[s3.tileID.key] = s3.tileID;
                    for (const e4 in t4)
                      t4[e4].isChildOf(s3.tileID) && delete t4[e4];
                  }
                }
                for (const e4 in this._tiles)
                  t4[e4] || (this._coveredTiles[e4] = true);
              }
            }
            for (const t3 in h2)
              this._tiles[t3].clearFadeHold();
            const c2 = e.ab(this._tiles, h2);
            for (const t3 of c2) {
              const e2 = this._tiles[t3];
              e2.hasSymbolBuckets && !e2.holdingForFade() ? e2.setHoldDuration(this.map._fadeDuration) : e2.hasSymbolBuckets && !e2.symbolFadeFinished() || this._removeTile(t3);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t2 in this._tiles)
              this._tiles[t2].holdingForFade() && this._removeTile(t2);
          }
          _updateRetainedTiles(t2, e2) {
            const i2 = {}, s2 = {}, a2 = Math.max(e2 - ht.maxOverzooming, this._source.minzoom), o2 = Math.max(e2 + ht.maxUnderzooming, this._source.minzoom), r2 = {};
            for (const s3 of t2) {
              const t3 = this._addTile(s3);
              i2[s3.key] = s3, t3.hasData() || e2 < this._source.maxzoom && (r2[s3.key] = s3);
            }
            this._retainLoadedChildren(r2, e2, o2, i2);
            for (const o3 of t2) {
              let t3 = this._tiles[o3.key];
              if (t3.hasData())
                continue;
              if (e2 + 1 > this._source.maxzoom) {
                const t4 = o3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
                if (e3 && e3.hasData()) {
                  i2[t4.key] = t4;
                  continue;
                }
              } else {
                const t4 = o3.children(this._source.maxzoom);
                if (i2[t4[0].key] && i2[t4[1].key] && i2[t4[2].key] && i2[t4[3].key])
                  continue;
              }
              let r3 = t3.wasRequested();
              for (let e3 = o3.overscaledZ - 1; e3 >= a2; --e3) {
                const a3 = o3.scaledTo(e3);
                if (s2[a3.key])
                  break;
                if (s2[a3.key] = true, t3 = this.getTile(a3), !t3 && r3 && (t3 = this._addTile(a3)), t3) {
                  const e4 = t3.hasData();
                  if ((r3 || e4) && (i2[a3.key] = a3), r3 = t3.wasRequested(), e4)
                    break;
                }
              }
            }
            return i2;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t2 in this._tiles) {
              const e2 = [];
              let i2, s2 = this._tiles[t2].tileID;
              for (; s2.overscaledZ > 0; ) {
                if (s2.key in this._loadedParentTiles) {
                  i2 = this._loadedParentTiles[s2.key];
                  break;
                }
                e2.push(s2.key);
                const t3 = s2.scaledTo(s2.overscaledZ - 1);
                if (i2 = this._getLoadedTile(t3), i2)
                  break;
                s2 = t3;
              }
              for (const t3 of e2)
                this._loadedParentTiles[t3] = i2;
            }
          }
          _addTile(t2) {
            let i2 = this._tiles[t2.key];
            if (i2)
              return i2;
            i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
            const s2 = i2;
            return i2 || (i2 = new rt(t2, this._source.tileSize * t2.overscaleFactor()), this._loadTile(i2, t2.key, i2.state)), i2.uses++, this._tiles[t2.key] = i2, s2 || this._source.fire(new e.k("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
          }
          _setTileReloadTimer(t2, e2) {
            t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
            const i2 = e2.getExpiryTimeout();
            i2 && (this._timers[t2] = setTimeout(() => {
              this._reloadTile(t2, "expired"), delete this._timers[t2];
            }, i2));
          }
          _removeTile(t2) {
            const e2 = this._tiles[t2];
            e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          _dataHandler(t2) {
            const e2 = t2.sourceDataType;
            "source" === t2.dataType && "metadata" === e2 && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t2.dataType && "content" === e2 && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t2 in this._tiles)
              this._removeTile(t2);
            this._cache.reset();
          }
          tilesIn(t2, i2, s2) {
            const a2 = [], o2 = this.transform;
            if (!o2)
              return a2;
            const r2 = s2 ? o2.getCameraQueryGeometry(t2) : t2, n2 = t2.map((t3) => o2.pointCoordinate(t3, this.terrain)), l2 = r2.map((t3) => o2.pointCoordinate(t3, this.terrain)), h2 = this.getIds();
            let c2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
            for (const t3 of l2)
              c2 = Math.min(c2, t3.x), u2 = Math.min(u2, t3.y), d2 = Math.max(d2, t3.x), _2 = Math.max(_2, t3.y);
            for (let t3 = 0; t3 < h2.length; t3++) {
              const s3 = this._tiles[h2[t3]];
              if (s3.holdingForFade())
                continue;
              const r3 = s3.tileID, p2 = Math.pow(2, o2.zoom - s3.tileID.overscaledZ), m2 = i2 * s3.queryPadding * e.W / s3.tileSize / p2, f2 = [r3.getTilePoint(new e.Y(c2, u2)), r3.getTilePoint(new e.Y(d2, _2))];
              if (f2[0].x - m2 < e.W && f2[0].y - m2 < e.W && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
                const t4 = n2.map((t5) => r3.getTilePoint(t5)), e2 = l2.map((t5) => r3.getTilePoint(t5));
                a2.push({ tile: s3, tileID: r3, queryGeometry: t4, cameraQueryGeometry: e2, scale: p2 });
              }
            }
            return a2;
          }
          getVisibleCoordinates(t2) {
            const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
            for (const t3 of e2)
              t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (ut(this._source.type)) {
              const t2 = o.now();
              for (const e2 in this._tiles)
                if (this._tiles[e2].fadeEndTime >= t2)
                  return true;
            }
            return false;
          }
          setFeatureState(t2, e2, i2) {
            this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          removeFeatureState(t2, e2, i2) {
            this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
          }
          getFeatureState(t2, e2) {
            return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
          }
          setDependencies(t2, e2, i2) {
            const s2 = this._tiles[t2];
            s2 && s2.setDependencies(e2, i2);
          }
          reloadTilesForDependencies(t2, e2) {
            for (const i2 in this._tiles)
              this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
            this._cache.filter((i2) => !i2.hasDependency(t2, e2));
          }
        }
        function ct(t2, e2) {
          const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), s2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t2.overscaledZ - e2.overscaledZ || s2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
        }
        function ut(t2) {
          return "raster" === t2 || "image" === t2 || "video" === t2;
        }
        ht.maxOverzooming = 10, ht.maxUnderzooming = 3;
        class dt {
          constructor(t2, e2) {
            this.reset(t2, e2);
          }
          reset(t2, e2) {
            this.points = t2 || [], this._distances = [0];
            for (let t3 = 1; t3 < this.points.length; t3++)
              this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t2) {
            if (1 === this.points.length)
              return this.points[0];
            t2 = e.ac(t2, 0, 1);
            let i2 = 1, s2 = this._distances[i2];
            const a2 = t2 * this.paddedLength + this.padding;
            for (; s2 < a2 && i2 < this._distances.length; )
              s2 = this._distances[++i2];
            const o2 = i2 - 1, r2 = this._distances[o2], n2 = s2 - r2, l2 = n2 > 0 ? (a2 - r2) / n2 : 0;
            return this.points[o2].mult(1 - l2).add(this.points[i2].mult(l2));
          }
        }
        function _t(t2, e2) {
          let i2 = true;
          return "always" === t2 || "never" !== t2 && "never" !== e2 || (i2 = false), i2;
        }
        class pt {
          constructor(t2, e2, i2) {
            const s2 = this.boxCells = [], a2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
            for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
              s2.push([]), a2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t2, e2, i2, s2, a2) {
            this._forEachCell(e2, i2, s2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(s2), this.bboxes.push(a2);
          }
          insertCircle(t2, e2, i2, s2) {
            this._forEachCell(e2 - s2, i2 - s2, e2 + s2, i2 + s2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(s2);
          }
          _insertBoxCell(t2, e2, i2, s2, a2, o2) {
            this.boxCells[a2].push(o2);
          }
          _insertCircleCell(t2, e2, i2, s2, a2, o2) {
            this.circleCells[a2].push(o2);
          }
          _query(t2, e2, i2, s2, a2, o2, r2) {
            if (i2 < 0 || t2 > this.width || s2 < 0 || e2 > this.height)
              return [];
            const n2 = [];
            if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= s2) {
              if (a2)
                return [{ key: null, x1: t2, y1: e2, x2: i2, y2: s2 }];
              for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
              for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], s3 = this.circles[3 * t3 + 2];
                n2.push({ key: this.circleKeys[t3], x1: e3 - s3, y1: i3 - s3, x2: e3 + s3, y2: i3 + s3 });
              }
            } else
              this._forEachCell(t2, e2, i2, s2, this._queryCell, n2, { hitTest: a2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
            return n2;
          }
          query(t2, e2, i2, s2) {
            return this._query(t2, e2, i2, s2, false, null);
          }
          hitTest(t2, e2, i2, s2, a2, o2) {
            return this._query(t2, e2, i2, s2, true, a2, o2).length > 0;
          }
          hitTestCircle(t2, e2, i2, s2, a2) {
            const o2 = t2 - i2, r2 = t2 + i2, n2 = e2 - i2, l2 = e2 + i2;
            if (r2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height)
              return false;
            const h2 = [];
            return this._forEachCell(o2, n2, r2, l2, this._queryCellCircle, h2, { hitTest: true, overlapMode: s2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, a2), h2.length > 0;
          }
          _queryCell(t2, e2, i2, s2, a2, o2, r2, n2) {
            const { seenUids: l2, hitTest: h2, overlapMode: c2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const a3 = this.bboxes;
              for (const r3 of u2)
                if (!l2.box[r3]) {
                  l2.box[r3] = true;
                  const u3 = 4 * r3, d3 = this.boxKeys[r3];
                  if (t2 <= a3[u3 + 2] && e2 <= a3[u3 + 3] && i2 >= a3[u3 + 0] && s2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!h2 || !_t(c2, d3.overlapMode)) && (o2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), h2))
                    return true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const a3 = this.circles;
              for (const r3 of d2)
                if (!l2.circle[r3]) {
                  l2.circle[r3] = true;
                  const u3 = 3 * r3, d3 = this.circleKeys[r3];
                  if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t2, e2, i2, s2) && (!n2 || n2(d3)) && (!h2 || !_t(c2, d3.overlapMode))) {
                    const t3 = a3[u3], e3 = a3[u3 + 1], i3 = a3[u3 + 2];
                    if (o2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), h2)
                      return true;
                  }
                }
            }
            return false;
          }
          _queryCellCircle(t2, e2, i2, s2, a2, o2, r2, n2) {
            const { circle: l2, seenUids: h2, overlapMode: c2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const t3 = this.bboxes;
              for (const e3 of u2)
                if (!h2.box[e3]) {
                  h2.box[e3] = true;
                  const i3 = 4 * e3, s3 = this.boxKeys[e3];
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(s3)) && !_t(c2, s3.overlapMode))
                    return o2.push(true), true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const t3 = this.circles;
              for (const e3 of d2)
                if (!h2.circle[e3]) {
                  h2.circle[e3] = true;
                  const i3 = 3 * e3, s3 = this.circleKeys[e3];
                  if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(s3)) && !_t(c2, s3.overlapMode))
                    return o2.push(true), true;
                }
            }
          }
          _forEachCell(t2, e2, i2, s2, a2, o2, r2, n2) {
            const l2 = this._convertToXCellCoord(t2), h2 = this._convertToYCellCoord(e2), c2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(s2);
            for (let d2 = l2; d2 <= c2; d2++)
              for (let l3 = h2; l3 <= u2; l3++)
                if (a2.call(this, t2, e2, i2, s2, this.xCellCount * l3 + d2, o2, r2, n2))
                  return;
          }
          _convertToXCellCoord(t2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
          }
          _convertToYCellCoord(t2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
          }
          _circlesCollide(t2, e2, i2, s2, a2, o2) {
            const r2 = s2 - t2, n2 = a2 - e2, l2 = i2 + o2;
            return l2 * l2 > r2 * r2 + n2 * n2;
          }
          _circleAndRectCollide(t2, e2, i2, s2, a2, o2, r2) {
            const n2 = (o2 - s2) / 2, l2 = Math.abs(t2 - (s2 + n2));
            if (l2 > n2 + i2)
              return false;
            const h2 = (r2 - a2) / 2, c2 = Math.abs(e2 - (a2 + h2));
            if (c2 > h2 + i2)
              return false;
            if (l2 <= n2 || c2 <= h2)
              return true;
            const u2 = l2 - n2, d2 = c2 - h2;
            return u2 * u2 + d2 * d2 <= i2 * i2;
          }
        }
        function mt(t2, i2, s2, a2, o2) {
          const r2 = e.F();
          return i2 ? (e.J(r2, r2, [1 / o2, 1 / o2, 1]), s2 || e.ad(r2, r2, a2.angle)) : e.K(r2, a2.labelPlaneMatrix, t2), r2;
        }
        function ft(t2, i2, s2, a2, o2) {
          if (i2) {
            const i3 = e.ae(t2);
            return e.J(i3, i3, [o2, o2, 1]), s2 || e.ad(i3, i3, -a2.angle), i3;
          }
          return a2.glCoordMatrix;
        }
        function gt(t2, i2, s2) {
          let a2;
          s2 ? (a2 = [t2.x, t2.y, s2(t2.x, t2.y), 1], e.af(a2, a2, i2)) : (a2 = [t2.x, t2.y, 0, 1], Mt(a2, a2, i2));
          const o2 = a2[3];
          return { point: new e.P(a2[0] / o2, a2[1] / o2), signedDistanceFromCamera: o2 };
        }
        function vt(t2, e2) {
          return 0.5 + t2 / e2 * 0.5;
        }
        function xt(t2, e2) {
          const i2 = t2[0] / t2[3], s2 = t2[1] / t2[3];
          return i2 >= -e2[0] && i2 <= e2[0] && s2 >= -e2[1] && s2 <= e2[1];
        }
        function yt(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2) {
          const u2 = a2 ? t2.textSizeData : t2.iconSizeData, d2 = e.ag(u2, s2.transform.zoom), _2 = [256 / s2.width * 2 + 1, 256 / s2.height * 2 + 1], p2 = a2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
          p2.clear();
          const m2 = t2.lineVertexArray, f2 = a2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, g2 = s2.transform.width / s2.transform.height;
          let v2 = false;
          for (let a3 = 0; a3 < f2.length; a3++) {
            const x2 = f2.get(a3);
            if (x2.hidden || x2.writingMode === e.ah.vertical && !v2) {
              zt(x2.numGlyphs, p2);
              continue;
            }
            let y2;
            if (v2 = false, c2 ? (y2 = [x2.anchorX, x2.anchorY, c2(x2.anchorX, x2.anchorY), 1], e.af(y2, y2, i2)) : (y2 = [x2.anchorX, x2.anchorY, 0, 1], Mt(y2, y2, i2)), !xt(y2, _2)) {
              zt(x2.numGlyphs, p2);
              continue;
            }
            const b2 = vt(s2.transform.cameraToCenterDistance, y2[3]), w2 = e.ai(u2, d2, x2), T2 = n2 ? w2 / b2 : w2 * b2, I2 = new e.P(x2.anchorX, x2.anchorY), E2 = gt(I2, o2, c2).point, C2 = { projections: {}, offsets: {} }, S2 = Tt(x2, T2, false, l2, i2, o2, r2, t2.glyphOffsetArray, m2, p2, E2, I2, C2, g2, h2, c2);
            v2 = S2.useVertical, (S2.notEnoughRoom || v2 || S2.needsFlipping && Tt(x2, T2, true, l2, i2, o2, r2, t2.glyphOffsetArray, m2, p2, E2, I2, C2, g2, h2, c2).notEnoughRoom) && zt(x2.numGlyphs, p2);
          }
          a2 ? t2.text.dynamicLayoutVertexBuffer.updateData(p2) : t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function bt(t2, e2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2) {
          const _2 = n2.glyphStartIndex + n2.numGlyphs, p2 = n2.lineStartIndex, m2 = n2.lineStartIndex + n2.lineLength, f2 = e2.getoffsetX(n2.glyphStartIndex), g2 = e2.getoffsetX(_2 - 1), v2 = Pt(t2 * f2, i2, s2, a2, o2, r2, n2.segment, p2, m2, l2, h2, c2, u2, d2);
          if (!v2)
            return null;
          const x2 = Pt(t2 * g2, i2, s2, a2, o2, r2, n2.segment, p2, m2, l2, h2, c2, u2, d2);
          return x2 ? { first: v2, last: x2 } : null;
        }
        function wt(t2, i2, s2, a2) {
          return t2 === e.ah.horizontal && Math.abs(s2.y - i2.y) > Math.abs(s2.x - i2.x) * a2 ? { useVertical: true } : (t2 === e.ah.vertical ? i2.y < s2.y : i2.x > s2.x) ? { needsFlipping: true } : null;
        }
        function Tt(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2) {
          const g2 = i2 / 24, v2 = t2.lineOffsetX * g2, x2 = t2.lineOffsetY * g2;
          let y2;
          if (t2.numGlyphs > 1) {
            const e2 = t2.glyphStartIndex + t2.numGlyphs, i3 = t2.lineStartIndex, o3 = t2.lineStartIndex + t2.lineLength, c3 = bt(g2, l2, v2, x2, s2, u2, d2, t2, h2, r2, _2, m2, f2);
            if (!c3)
              return { notEnoughRoom: true };
            const b2 = gt(c3.first.point, n2, f2).point, w2 = gt(c3.last.point, n2, f2).point;
            if (a2 && !s2) {
              const e3 = wt(t2.writingMode, b2, w2, p2);
              if (e3)
                return e3;
            }
            y2 = [c3.first];
            for (let a3 = t2.glyphStartIndex + 1; a3 < e2 - 1; a3++)
              y2.push(Pt(g2 * l2.getoffsetX(a3), v2, x2, s2, u2, d2, t2.segment, i3, o3, h2, r2, _2, m2, f2));
            y2.push(c3.last);
          } else {
            if (a2 && !s2) {
              const i4 = gt(d2, o2, f2).point, s3 = t2.lineStartIndex + t2.segment + 1, a3 = new e.P(h2.getx(s3), h2.gety(s3)), r3 = gt(a3, o2, f2), n3 = r3.signedDistanceFromCamera > 0 ? r3.point : It(d2, a3, i4, 1, o2, f2), l3 = wt(t2.writingMode, i4, n3, p2);
              if (l3)
                return l3;
            }
            const i3 = Pt(g2 * l2.getoffsetX(t2.glyphStartIndex), v2, x2, s2, u2, d2, t2.segment, t2.lineStartIndex, t2.lineStartIndex + t2.lineLength, h2, r2, _2, m2, f2);
            if (!i3)
              return { notEnoughRoom: true };
            y2 = [i3];
          }
          for (const t3 of y2)
            e.aj(c2, t3.point, t3.angle);
          return {};
        }
        function It(t2, e2, i2, s2, a2, o2) {
          const r2 = gt(t2.add(t2.sub(e2)._unit()), a2, o2).point, n2 = i2.sub(r2);
          return i2.add(n2._mult(s2 / n2.mag()));
        }
        function Et(t2, i2) {
          const { projectionCache: s2, lineVertexArray: a2, labelPlaneMatrix: o2, tileAnchorPoint: r2, distanceFromAnchor: n2, getElevation: l2, previousVertex: h2, direction: c2, absOffsetX: u2 } = i2;
          if (s2.projections[t2])
            return s2.projections[t2];
          const d2 = new e.P(a2.getx(t2), a2.gety(t2)), _2 = gt(d2, o2, l2);
          if (_2.signedDistanceFromCamera > 0)
            return s2.projections[t2] = _2.point, _2.point;
          const p2 = t2 - c2;
          return It(0 === n2 ? r2 : new e.P(a2.getx(p2), a2.gety(p2)), d2, h2, u2 - n2 + 1, o2, l2);
        }
        function Ct(t2, e2, i2) {
          return t2._unit()._perp()._mult(e2 * i2);
        }
        function St(t2, i2, s2, a2, o2, r2, n2, l2) {
          const { projectionCache: h2, direction: c2 } = l2;
          if (h2.offsets[t2])
            return h2.offsets[t2];
          const u2 = s2.add(i2);
          if (t2 + c2 < a2 || t2 + c2 >= o2)
            return h2.offsets[t2] = u2, u2;
          const d2 = Et(t2 + c2, l2), _2 = Ct(d2.sub(s2), n2, c2), p2 = s2.add(_2), m2 = d2.add(_2);
          return h2.offsets[t2] = e.ak(r2, u2, p2, m2) || u2, h2.offsets[t2];
        }
        function Pt(t2, e2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2) {
          const p2 = s2 ? t2 - e2 : t2 + e2;
          let m2 = p2 > 0 ? 1 : -1, f2 = 0;
          s2 && (m2 *= -1, f2 = Math.PI), m2 < 0 && (f2 += Math.PI);
          let g2, v2, x2 = m2 > 0 ? n2 + r2 : n2 + r2 + 1, y2 = a2, b2 = a2, w2 = 0, T2 = 0;
          const I2 = Math.abs(p2), E2 = [];
          let C2;
          for (; w2 + T2 <= I2; ) {
            if (x2 += m2, x2 < n2 || x2 >= l2)
              return null;
            w2 += T2, b2 = y2, v2 = g2;
            const t3 = { projectionCache: u2, lineVertexArray: h2, labelPlaneMatrix: c2, tileAnchorPoint: o2, distanceFromAnchor: w2, getElevation: _2, previousVertex: b2, direction: m2, absOffsetX: I2 };
            if (y2 = Et(x2, t3), 0 === i2)
              E2.push(b2), C2 = y2.sub(b2);
            else {
              let e3;
              const s3 = y2.sub(b2);
              e3 = 0 === s3.mag() ? Ct(Et(x2 + m2, t3).sub(y2), i2, m2) : Ct(s3, i2, m2), v2 || (v2 = b2.add(e3)), g2 = St(x2, e3, y2, n2, l2, v2, i2, t3), E2.push(v2), C2 = g2.sub(v2);
            }
            T2 = C2.mag();
          }
          const S2 = C2._mult((I2 - w2) / T2)._add(v2 || b2), P2 = f2 + Math.atan2(y2.y - b2.y, y2.x - b2.x);
          return E2.push(S2), { point: S2, angle: d2 ? P2 : 0, path: E2 };
        }
        const Dt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function zt(t2, e2) {
          for (let i2 = 0; i2 < t2; i2++) {
            const t3 = e2.length;
            e2.resize(t3 + 4), e2.float32.set(Dt, 3 * t3);
          }
        }
        function Mt(t2, e2, i2) {
          const s2 = e2[0], a2 = e2[1];
          return t2[0] = i2[0] * s2 + i2[4] * a2 + i2[12], t2[1] = i2[1] * s2 + i2[5] * a2 + i2[13], t2[3] = i2[3] * s2 + i2[7] * a2 + i2[15], t2;
        }
        const At = 100;
        class Rt {
          constructor(t2, e2 = new pt(t2.width + 200, t2.height + 200, 25), i2 = new pt(t2.width + 200, t2.height + 200, 25)) {
            this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + At, this.screenBottomBoundary = t2.height + At, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t2, e2, i2, s2, a2, o2) {
            const r2 = this.projectAndGetPerspectiveRatio(s2, t2.anchorPointX, t2.anchorPointY, o2), n2 = i2 * r2.perspectiveRatio, l2 = t2.x1 * n2 + r2.point.x, h2 = t2.y1 * n2 + r2.point.y, c2 = t2.x2 * n2 + r2.point.x, u2 = t2.y2 * n2 + r2.point.y;
            return !this.isInsideGrid(l2, h2, c2, u2) || "always" !== e2 && this.grid.hitTest(l2, h2, c2, u2, e2, a2) || r2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l2, h2, c2, u2], offscreen: this.isOffscreen(l2, h2, c2, u2) };
          }
          placeCollisionCircles(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2) {
            const m2 = [], f2 = new e.P(i2.anchorX, i2.anchorY), g2 = gt(f2, r2, p2), v2 = vt(this.transform.cameraToCenterDistance, g2.signedDistanceFromCamera), x2 = (c2 ? o2 / v2 : o2 * v2) / e.ao, y2 = gt(f2, n2, p2).point, b2 = bt(x2, a2, i2.lineOffsetX * x2, i2.lineOffsetY * x2, false, y2, f2, i2, s2, n2, { projections: {}, offsets: {} }, false, p2);
            let w2 = false, T2 = false, I2 = true;
            if (b2) {
              const i3 = 0.5 * d2 * v2 + _2, s3 = new e.P(-100, -100), a3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new dt(), r3 = b2.first, n3 = b2.last;
              let c3 = [];
              for (let t3 = r3.path.length - 1; t3 >= 1; t3--)
                c3.push(r3.path[t3]);
              for (let t3 = 1; t3 < n3.path.length; t3++)
                c3.push(n3.path[t3]);
              const f3 = 2.5 * i3;
              if (l2) {
                const t3 = c3.map((t4) => gt(t4, l2, p2));
                c3 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
              }
              let g3 = [];
              if (c3.length > 0) {
                const t3 = c3[0].clone(), i4 = c3[0].clone();
                for (let e2 = 1; e2 < c3.length; e2++)
                  t3.x = Math.min(t3.x, c3[e2].x), t3.y = Math.min(t3.y, c3[e2].y), i4.x = Math.max(i4.x, c3[e2].x), i4.y = Math.max(i4.y, c3[e2].y);
                g3 = t3.x >= s3.x && i4.x <= a3.x && t3.y >= s3.y && i4.y <= a3.y ? [c3] : i4.x < s3.x || t3.x > a3.x || i4.y < s3.y || t3.y > a3.y ? [] : e.al([c3], s3.x, s3.y, a3.x, a3.y);
              }
              for (const e2 of g3) {
                o3.reset(e2, 0.25 * i3);
                let s4 = 0;
                s4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / f3) + 1;
                for (let e3 = 0; e3 < s4; e3++) {
                  const a4 = e3 / Math.max(s4 - 1, 1), r4 = o3.lerp(a4), n4 = r4.x + At, l3 = r4.y + At;
                  m2.push(n4, l3, i3, 0);
                  const c4 = n4 - i3, d3 = l3 - i3, _3 = n4 + i3, p3 = l3 + i3;
                  if (I2 = I2 && this.isOffscreen(c4, d3, _3, p3), T2 = T2 || this.isInsideGrid(c4, d3, _3, p3), "always" !== t2 && this.grid.hitTestCircle(n4, l3, i3, t2, u2) && (w2 = true, !h2))
                    return { circles: [], offscreen: false, collisionDetected: w2 };
                }
              }
            }
            return { circles: !h2 && w2 || !T2 || v2 < this.perspectiveRatioCutoff ? [] : m2, offscreen: I2, collisionDetected: w2 };
          }
          queryRenderedSymbols(t2) {
            if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i2 = [];
            let s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
            for (const n3 of t2) {
              const t3 = new e.P(n3.x + At, n3.y + At);
              s2 = Math.min(s2, t3.x), a2 = Math.min(a2, t3.y), o2 = Math.max(o2, t3.x), r2 = Math.max(r2, t3.y), i2.push(t3);
            }
            const n2 = this.grid.query(s2, a2, o2, r2).concat(this.ignoredGrid.query(s2, a2, o2, r2)), l2 = {}, h2 = {};
            for (const t3 of n2) {
              const s3 = t3.key;
              if (void 0 === l2[s3.bucketInstanceId] && (l2[s3.bucketInstanceId] = {}), l2[s3.bucketInstanceId][s3.featureIndex])
                continue;
              const a3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
              e.am(i2, a3) && (l2[s3.bucketInstanceId][s3.featureIndex] = true, void 0 === h2[s3.bucketInstanceId] && (h2[s3.bucketInstanceId] = []), h2[s3.bucketInstanceId].push(s3.featureIndex));
            }
            return h2;
          }
          insertCollisionBox(t2, e2, i2, s2, a2, o2) {
            (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s2, featureIndex: a2, collisionGroupID: o2, overlapMode: e2 }, t2[0], t2[1], t2[2], t2[3]);
          }
          insertCollisionCircles(t2, e2, i2, s2, a2, o2) {
            const r2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: s2, featureIndex: a2, collisionGroupID: o2, overlapMode: e2 };
            for (let e3 = 0; e3 < t2.length; e3 += 4)
              r2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
          }
          projectAndGetPerspectiveRatio(t2, i2, s2, a2) {
            let o2;
            return a2 ? (o2 = [i2, s2, a2(i2, s2), 1], e.af(o2, o2, t2)) : (o2 = [i2, s2, 0, 1], Mt(o2, o2, t2)), { point: new e.P((o2[0] / o2[3] + 1) / 2 * this.transform.width + At, (-o2[1] / o2[3] + 1) / 2 * this.transform.height + At), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o2[3] * 0.5 };
          }
          isOffscreen(t2, e2, i2, s2) {
            return i2 < At || t2 >= this.screenRightBoundary || s2 < At || e2 > this.screenBottomBoundary;
          }
          isInsideGrid(t2, e2, i2, s2) {
            return i2 >= 0 && t2 < this.gridRightBoundary && s2 >= 0 && e2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t2 = e.an([]);
            return e.H(t2, t2, [-100, -100, 0]), t2;
          }
        }
        function Lt(t2, i2, s2) {
          return i2 * (e.W / (t2.tileSize * Math.pow(2, s2 - t2.tileID.overscaledZ)));
        }
        class kt {
          constructor(t2, e2, i2, s2) {
            this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : s2 && i2 ? 1 : 0, this.placed = i2;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Ft {
          constructor(t2, e2, i2, s2, a2) {
            this.text = new kt(t2 ? t2.text : null, e2, i2, a2), this.icon = new kt(t2 ? t2.icon : null, e2, s2, a2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Bt {
          constructor(t2, e2, i2) {
            this.text = t2, this.icon = e2, this.skipFade = i2;
          }
        }
        class Ot {
          constructor() {
            this.invProjMatrix = e.F(), this.viewportMatrix = e.F(), this.circles = [];
          }
        }
        class Nt {
          constructor(t2, e2, i2, s2, a2) {
            this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = s2, this.tileID = a2;
          }
        }
        class Ut {
          constructor(t2) {
            this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t2) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t2]) {
              const e2 = ++this.maxGroupID;
              this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
            }
            return this.collisionGroups[t2];
          }
        }
        function Zt(t2, i2, s2, a2, o2) {
          const { horizontalAlign: r2, verticalAlign: n2 } = e.at(t2);
          return new e.P(-(r2 - 0.5) * i2 + a2[0] * o2, -(n2 - 0.5) * s2 + a2[1] * o2);
        }
        function Gt(t2, i2, s2, a2, o2, r2) {
          const { x1: n2, x2: l2, y1: h2, y2: c2, anchorPointX: u2, anchorPointY: d2 } = t2, _2 = new e.P(i2, s2);
          return a2 && _2._rotate(o2 ? r2 : -r2), { x1: n2 + _2.x, y1: h2 + _2.y, x2: l2 + _2.x, y2: c2 + _2.y, anchorPointX: u2, anchorPointY: d2 };
        }
        class qt {
          constructor(t2, e2, i2, s2, a2) {
            this.transform = t2.clone(), this.terrain = e2, this.collisionIndex = new Rt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new Ut(s2), this.collisionCircleArrays = {}, this.prevPlacement = a2, a2 && (a2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t2, i2, s2, a2) {
            const o2 = s2.getBucket(i2), r2 = s2.latestFeatureIndex;
            if (!o2 || !r2 || i2.id !== o2.layerIds[0])
              return;
            const n2 = s2.collisionBoxArray, l2 = o2.layers[0].layout, h2 = Math.pow(2, this.transform.zoom - s2.tileID.overscaledZ), c2 = s2.tileSize / e.W, u2 = this.transform.calculatePosMatrix(s2.tileID.toUnwrapped()), d2 = "map" === l2.get("text-pitch-alignment"), _2 = "map" === l2.get("text-rotation-alignment"), p2 = Lt(s2, 1, this.transform.zoom), m2 = mt(u2, d2, _2, this.transform, p2);
            let f2 = null;
            if (d2) {
              const t3 = ft(u2, d2, _2, this.transform, p2);
              f2 = e.K([], this.transform.labelPlaneMatrix, t3);
            }
            this.retainedQueryData[o2.bucketInstanceId] = new Nt(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, s2.tileID);
            const g2 = { bucket: o2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: m2, labelToScreenMatrix: f2, scale: h2, textPixelRatio: c2, holdingForFade: s2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: e.ag(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
            if (a2)
              for (const e2 of o2.sortKeyRanges) {
                const { sortKey: i3, symbolInstanceStart: s3, symbolInstanceEnd: a3 } = e2;
                t2.push({ sortKey: i3, symbolInstanceStart: s3, symbolInstanceEnd: a3, parameters: g2 });
              }
            else
              t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: g2 });
          }
          attemptAnchorPlacement(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2) {
            const g2 = e.ap[t2.textAnchor], v2 = [t2.textOffset0, t2.textOffset1], x2 = Zt(g2, s2, a2, v2, o2), y2 = this.collisionIndex.placeCollisionBox(Gt(i2, x2.x, x2.y, r2, n2, this.transform.angle), u2, l2, h2, c2.predicate, f2);
            if ((!m2 || 0 !== this.collisionIndex.placeCollisionBox(Gt(m2, x2.x, x2.y, r2, n2, this.transform.angle), u2, l2, h2, c2.predicate, f2).box.length) && y2.box.length > 0) {
              let t3;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[d2.crossTileID].anchor), 0 === d2.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[d2.crossTileID] = { textOffset: v2, width: s2, height: a2, anchor: g2, textBoxScale: o2, prevAnchor: t3 }, this.markUsedJustification(_2, g2, d2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, d2), this.placedOrientations[d2.crossTileID] = p2), { shift: x2, placedGlyphBoxes: y2 };
            }
          }
          placeLayerBucketPart(t2, i2, s2) {
            const { bucket: a2, layout: o2, posMatrix: r2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: h2, holdingForFade: c2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: _2 } = t2.parameters, p2 = o2.get("text-optional"), m2 = o2.get("icon-optional"), f2 = e.aq(o2, "text-overlap", "text-allow-overlap"), g2 = "always" === f2, v2 = e.aq(o2, "icon-overlap", "icon-allow-overlap"), x2 = "always" === v2, y2 = "map" === o2.get("text-rotation-alignment"), b2 = "map" === o2.get("text-pitch-alignment"), w2 = "none" !== o2.get("icon-text-fit"), T2 = "viewport-y" === o2.get("symbol-z-order"), I2 = g2 && (x2 || !a2.hasIconData() || m2), E2 = x2 && (g2 || !a2.hasTextData() || p2);
            !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
            const C2 = this.retainedQueryData[a2.bucketInstanceId].tileID, S2 = this.terrain ? (t3, e2) => this.terrain.getElevation(C2, t3, e2) : null, P2 = (t3, u3) => {
              var x3, T3;
              if (i2[t3.crossTileID])
                return;
              if (c2)
                return void (this.placements[t3.crossTileID] = new Bt(false, false, false));
              let C3 = false, P3 = false, D2 = true, z2 = null, M2 = { box: null, offscreen: null }, A2 = { box: null, offscreen: null }, R2 = null, L2 = null, k2 = null, F2 = 0, B2 = 0, O2 = 0;
              u3.textFeatureIndex ? F2 = u3.textFeatureIndex : t3.useRuntimeCollisionCircles && (F2 = t3.featureIndex), u3.verticalTextFeatureIndex && (B2 = u3.verticalTextFeatureIndex);
              const N2 = u3.textBox;
              if (N2) {
                const i3 = (i4) => {
                  let s4 = e.ah.horizontal;
                  if (a2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                    const e2 = this.prevPlacement.placedOrientations[t3.crossTileID];
                    e2 && (this.placedOrientations[t3.crossTileID] = e2, s4 = e2, this.markUsedOrientation(a2, s4, t3));
                  }
                  return s4;
                }, s3 = (i4, s4) => {
                  if (a2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                    for (const t4 of a2.writingModes)
                      if (t4 === e.ah.vertical ? (M2 = s4(), A2 = M2) : M2 = i4(), M2 && M2.box && M2.box.length)
                        break;
                  } else
                    M2 = i4();
                }, o3 = t3.textAnchorOffsetStartIndex, n3 = t3.textAnchorOffsetEndIndex;
                if (n3 === o3) {
                  const o4 = (e2, i4) => {
                    const s4 = this.collisionIndex.placeCollisionBox(e2, f2, h2, r2, _2.predicate, S2);
                    return s4 && s4.box && s4.box.length && (this.markUsedOrientation(a2, i4, t3), this.placedOrientations[t3.crossTileID] = i4), s4;
                  };
                  s3(() => o4(N2, e.ah.horizontal), () => {
                    const i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && i4 ? o4(i4, e.ah.vertical) : { box: null, offscreen: null };
                  }), i3(M2 && M2.box && M2.box.length);
                } else {
                  let l3 = e.ap[null === (T3 = null === (x3 = this.prevPlacement) || void 0 === x3 ? void 0 : x3.variableOffsets[t3.crossTileID]) || void 0 === T3 ? void 0 : T3.anchor];
                  const c3 = (e2, i4, s4) => {
                    const c4 = e2.x2 - e2.x1, u4 = e2.y2 - e2.y1, d4 = t3.textBoxScale, p3 = w2 && "never" === v2 ? i4 : null;
                    let m3 = { box: [], offscreen: false }, g3 = "never" === f2 ? 1 : 2, x4 = "never";
                    l3 && g3++;
                    for (let i5 = 0; i5 < g3; i5++) {
                      for (let i6 = o3; i6 < n3; i6++) {
                        const o4 = a2.textAnchorOffsets.get(i6);
                        if (l3 && o4.textAnchor !== l3)
                          continue;
                        const n4 = this.attemptAnchorPlacement(o4, e2, c4, u4, d4, y2, b2, h2, r2, _2, x4, t3, a2, s4, p3, S2);
                        if (n4 && (m3 = n4.placedGlyphBoxes, m3 && m3.box && m3.box.length))
                          return C3 = true, z2 = n4.shift, m3;
                      }
                      l3 ? l3 = null : x4 = f2;
                    }
                    return m3;
                  };
                  s3(() => c3(N2, u3.iconBox, e.ah.horizontal), () => {
                    const i4 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && !(M2 && M2.box && M2.box.length) && t3.numVerticalGlyphVertices > 0 && i4 ? c3(i4, u3.verticalIconBox, e.ah.vertical) : { box: null, offscreen: null };
                  }), M2 && (C3 = M2.box, D2 = M2.offscreen);
                  const d3 = i3(M2 && M2.box);
                  if (!C3 && this.prevPlacement) {
                    const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                    e2 && (this.variableOffsets[t3.crossTileID] = e2, this.markUsedJustification(a2, e2.anchor, t3, d3));
                  }
                }
              }
              if (R2 = M2, C3 = R2 && R2.box && R2.box.length > 0, D2 = R2 && R2.offscreen, t3.useRuntimeCollisionCircles) {
                const i3 = a2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex), h3 = e.ai(a2.textSizeData, d2, i3), c3 = o2.get("text-padding");
                L2 = this.collisionIndex.placeCollisionCircles(f2, i3, a2.lineVertexArray, a2.glyphOffsetArray, h3, r2, n2, l2, s2, b2, _2.predicate, t3.collisionCircleDiameter, c3, S2), L2.circles.length && L2.collisionDetected && !s2 && e.w("Collisions detected, but collision boxes are not shown"), C3 = g2 || L2.circles.length > 0 && !L2.collisionDetected, D2 = D2 && L2.offscreen;
              }
              if (u3.iconFeatureIndex && (O2 = u3.iconFeatureIndex), u3.iconBox) {
                const t4 = (t5) => {
                  const e2 = w2 && z2 ? Gt(t5, z2.x, z2.y, y2, b2, this.transform.angle) : t5;
                  return this.collisionIndex.placeCollisionBox(e2, v2, h2, r2, _2.predicate, S2);
                };
                A2 && A2.box && A2.box.length && u3.verticalIconBox ? (k2 = t4(u3.verticalIconBox), P3 = k2.box.length > 0) : (k2 = t4(u3.iconBox), P3 = k2.box.length > 0), D2 = D2 && k2.offscreen;
              }
              const U2 = p2 || 0 === t3.numHorizontalGlyphVertices && 0 === t3.numVerticalGlyphVertices, Z2 = m2 || 0 === t3.numIconVertices;
              if (U2 || Z2 ? Z2 ? U2 || (P3 = P3 && C3) : C3 = P3 && C3 : P3 = C3 = P3 && C3, C3 && R2 && R2.box && this.collisionIndex.insertCollisionBox(R2.box, f2, o2.get("text-ignore-placement"), a2.bucketInstanceId, A2 && A2.box && B2 ? B2 : F2, _2.ID), P3 && k2 && this.collisionIndex.insertCollisionBox(k2.box, v2, o2.get("icon-ignore-placement"), a2.bucketInstanceId, O2, _2.ID), L2 && (C3 && this.collisionIndex.insertCollisionCircles(L2.circles, f2, o2.get("text-ignore-placement"), a2.bucketInstanceId, F2, _2.ID), s2)) {
                const t4 = a2.bucketInstanceId;
                let e2 = this.collisionCircleArrays[t4];
                void 0 === e2 && (e2 = this.collisionCircleArrays[t4] = new Ot());
                for (let t5 = 0; t5 < L2.circles.length; t5 += 4)
                  e2.circles.push(L2.circles[t5 + 0]), e2.circles.push(L2.circles[t5 + 1]), e2.circles.push(L2.circles[t5 + 2]), e2.circles.push(L2.collisionDetected ? 1 : 0);
              }
              if (0 === t3.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === a2.bucketInstanceId)
                throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[t3.crossTileID] = new Bt(C3 || I2, P3 || E2, D2 || a2.justReloaded), i2[t3.crossTileID] = true;
            };
            if (T2) {
              if (0 !== t2.symbolInstanceStart)
                throw new Error("bucket.bucketInstanceId should be 0");
              const e2 = a2.getSortedSymbolIndexes(this.transform.angle);
              for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                const i3 = e2[t3];
                P2(a2.symbolInstances.get(i3), a2.collisionArrays[i3]);
              }
            } else
              for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
                P2(a2.symbolInstances.get(e2), a2.collisionArrays[e2]);
            if (s2 && a2.bucketInstanceId in this.collisionCircleArrays) {
              const t3 = this.collisionCircleArrays[a2.bucketInstanceId];
              e.ar(t3.invProjMatrix, r2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a2.justReloaded = false;
          }
          markUsedJustification(t2, i2, s2, a2) {
            let o2;
            o2 = a2 === e.ah.vertical ? s2.verticalPlacedTextSymbolIndex : { left: s2.leftJustifiedTextSymbolIndex, center: s2.centerJustifiedTextSymbolIndex, right: s2.rightJustifiedTextSymbolIndex }[e.as(i2)];
            const r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex, s2.verticalPlacedTextSymbolIndex];
            for (const e2 of r2)
              e2 >= 0 && (t2.text.placedSymbolArray.get(e2).crossTileID = o2 >= 0 && e2 !== o2 ? 0 : s2.crossTileID);
          }
          markUsedOrientation(t2, i2, s2) {
            const a2 = i2 === e.ah.horizontal || i2 === e.ah.horizontalOnly ? i2 : 0, o2 = i2 === e.ah.vertical ? i2 : 0, r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex];
            for (const e2 of r2)
              t2.text.placedSymbolArray.get(e2).placedOrientation = a2;
            s2.verticalPlacedTextSymbolIndex && (t2.text.placedSymbolArray.get(s2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
          }
          commit(t2) {
            this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e2 = this.prevPlacement;
            let i2 = false;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            const s2 = e2 ? e2.symbolFadeChange(t2) : 1, a2 = e2 ? e2.opacities : {}, o2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
            for (const t3 in this.placements) {
              const e3 = this.placements[t3], o3 = a2[t3];
              o3 ? (this.opacities[t3] = new Ft(o3, s2, e3.text, e3.icon), i2 = i2 || e3.text !== o3.text.placed || e3.icon !== o3.icon.placed) : (this.opacities[t3] = new Ft(null, s2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
            }
            for (const t3 in a2) {
              const e3 = a2[t3];
              if (!this.opacities[t3]) {
                const a3 = new Ft(e3, s2, false, false);
                a3.isHidden() || (this.opacities[t3] = a3, i2 = i2 || e3.text.placed || e3.icon.placed);
              }
            }
            for (const t3 in o2)
              this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = o2[t3]);
            for (const t3 in r2)
              this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
            if (e2 && void 0 === e2.lastPlacementChangeTime)
              throw new Error("Last placement time for previous placement is not defined");
            i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
          }
          updateLayerOpacities(t2, e2) {
            const i2 = {};
            for (const s2 of e2) {
              const e3 = s2.getBucket(t2);
              e3 && s2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i2, s2.collisionBoxArray);
            }
          }
          updateBucketOpacities(t2, i2, s2) {
            t2.hasTextData() && (t2.text.opacityVertexArray.clear(), t2.text.hasVisibleVertices = false), t2.hasIconData() && (t2.icon.opacityVertexArray.clear(), t2.icon.hasVisibleVertices = false), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
            const a2 = t2.layers[0], o2 = a2.layout, r2 = new Ft(null, 0, false, false, true), n2 = o2.get("text-allow-overlap"), l2 = o2.get("icon-allow-overlap"), h2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c2 = "map" === o2.get("text-rotation-alignment"), u2 = "map" === o2.get("text-pitch-alignment"), d2 = "none" !== o2.get("icon-text-fit"), _2 = new Ft(null, 0, n2 && (l2 || !t2.hasIconData() || o2.get("icon-optional")), l2 && (n2 || !t2.hasTextData() || o2.get("text-optional")), true);
            !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
            const p2 = (t3, e2, i3) => {
              for (let s3 = 0; s3 < e2 / 4; s3++)
                t3.opacityVertexArray.emplaceBack(i3);
              t3.hasVisibleVertices = t3.hasVisibleVertices || i3 !== Qt;
            };
            for (let s3 = 0; s3 < t2.symbolInstances.length; s3++) {
              const a3 = t2.symbolInstances.get(s3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: n3, crossTileID: l3 } = a3;
              let m2 = this.opacities[l3];
              i2[l3] ? m2 = r2 : m2 || (m2 = _2, this.opacities[l3] = m2), i2[l3] = true;
              const f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], v2 = g2 === e.ah.vertical, x2 = g2 === e.ah.horizontal || g2 === e.ah.horizontalOnly;
              if (o3 > 0 || n3 > 0) {
                const e2 = Jt(m2.text);
                p2(t2.text, o3, v2 ? Qt : e2), p2(t2.text, n3, x2 ? Qt : e2);
                const i3 = m2.text.isHidden();
                [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((e3) => {
                  e3 >= 0 && (t2.text.placedSymbolArray.get(e3).hidden = i3 || v2 ? 1 : 0);
                }), a3.verticalPlacedTextSymbolIndex >= 0 && (t2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i3 || x2 ? 1 : 0);
                const s4 = this.variableOffsets[a3.crossTileID];
                s4 && this.markUsedJustification(t2, s4.anchor, a3, g2);
                const r3 = this.placedOrientations[a3.crossTileID];
                r3 && (this.markUsedJustification(t2, "left", a3, r3), this.markUsedOrientation(t2, r3, a3));
              }
              if (f2) {
                const e2 = Jt(m2.icon), i3 = !(d2 && a3.verticalPlacedIconSymbolIndex && v2);
                a3.placedIconSymbolIndex >= 0 && (p2(t2.icon, a3.numIconVertices, i3 ? e2 : Qt), t2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = m2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (p2(t2.icon, a3.numVerticalIconVertices, i3 ? Qt : e2), t2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = m2.icon.isHidden());
              }
              if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                const i3 = t2.collisionArrays[s3];
                if (i3) {
                  let s4 = new e.P(0, 0);
                  if (i3.textBox || i3.verticalTextBox) {
                    let e2 = true;
                    if (h2) {
                      const t3 = this.variableOffsets[l3];
                      t3 ? (s4 = Zt(t3.anchor, t3.width, t3.height, t3.textOffset, t3.textBoxScale), c2 && s4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : e2 = false;
                    }
                    i3.textBox && jt(t2.textCollisionBox.collisionVertexArray, m2.text.placed, !e2 || v2, s4.x, s4.y), i3.verticalTextBox && jt(t2.textCollisionBox.collisionVertexArray, m2.text.placed, !e2 || x2, s4.x, s4.y);
                  }
                  const a4 = Boolean(!x2 && i3.verticalIconBox);
                  i3.iconBox && jt(t2.iconCollisionBox.collisionVertexArray, m2.icon.placed, a4, d2 ? s4.x : 0, d2 ? s4.y : 0), i3.verticalIconBox && jt(t2.iconCollisionBox.collisionVertexArray, m2.icon.placed, !a4, d2 ? s4.x : 0, d2 ? s4.y : 0);
                }
              }
            }
            if (t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.text.opacityVertexArray.length !== t2.text.layoutVertexArray.length / 4)
              throw new Error(`bucket.text.opacityVertexArray.length (= ${t2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t2.text.layoutVertexArray.length}) / 4`);
            if (t2.icon.opacityVertexArray.length !== t2.icon.layoutVertexArray.length / 4)
              throw new Error(`bucket.icon.opacityVertexArray.length (= ${t2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t2.icon.layoutVertexArray.length}) / 4`);
            if (t2.bucketInstanceId in this.collisionCircleArrays) {
              const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
              t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
            }
          }
          symbolFadeChange(t2) {
            return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t2) {
            return Math.max(0, (this.transform.zoom - t2) / 1.5);
          }
          hasTransitions(t2) {
            return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t2, e2) {
            const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
          }
          setStale() {
            this.stale = true;
          }
        }
        function jt(t2, e2, i2, s2, a2) {
          t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, a2 || 0);
        }
        const Vt = Math.pow(2, 25), Ht = Math.pow(2, 24), Wt = Math.pow(2, 17), $t = Math.pow(2, 16), Xt = Math.pow(2, 9), Kt = Math.pow(2, 8), Yt = Math.pow(2, 1);
        function Jt(t2) {
          if (0 === t2.opacity && !t2.placed)
            return 0;
          if (1 === t2.opacity && t2.placed)
            return 4294967295;
          const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
          return i2 * Vt + e2 * Ht + i2 * Wt + e2 * $t + i2 * Xt + e2 * Kt + i2 * Yt + e2;
        }
        const Qt = 0;
        class te {
          constructor(t2) {
            this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t2, e2, i2, s2, a2) {
            const o2 = this._bucketParts;
            for (; this._currentTileIndex < t2.length; )
              if (e2.getBucketParts(o2, s2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t3, e3) => t3.sortKey - e3.sortKey)); this._currentPartIndex < o2.length; )
              if (e2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, a2())
                return true;
            return false;
          }
        }
        class ee {
          constructor(t2, e2, i2, s2, a2, o2, r2, n2) {
            this.placement = new qt(t2, e2, o2, r2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = s2, this._showCollisionBoxes = a2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t2, e2, i2) {
            const s2 = o.now(), a2 = () => !this._forceFullPlacement && o.now() - s2 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const s3 = e2[t2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === s3.type && (!s3.minzoom || s3.minzoom <= o2) && (!s3.maxzoom || s3.maxzoom > o2)) {
                if (this._inProgressLayer || (this._inProgressLayer = new te(s3)), this._inProgressLayer.continuePlacement(i2[s3.source], this.placement, this._showCollisionBoxes, s3, a2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t2) {
            return this.placement.commit(t2), this.placement;
          }
        }
        const ie = 512 / e.W / 2;
        class se {
          constructor(t2, i2, s2) {
            this.tileID = t2, this.bucketInstanceId = s2, this._symbolsByKey = {};
            const a2 = /* @__PURE__ */ new Map();
            for (let t3 = 0; t3 < i2.length; t3++) {
              const e2 = i2.get(t3), s3 = e2.key, o2 = a2.get(s3);
              o2 ? o2.push(e2) : a2.set(s3, [e2]);
            }
            for (const [t3, i3] of a2) {
              const s3 = { positions: i3.map((t4) => ({ x: Math.floor(t4.anchorX * ie), y: Math.floor(t4.anchorY * ie) })), crossTileIDs: i3.map((t4) => t4.crossTileID) };
              if (s3.positions.length > 128) {
                const t4 = new e.au(s3.positions.length, 16, Uint16Array);
                for (const { x: e2, y: i4 } of s3.positions)
                  t4.add(e2, i4);
                t4.finish(), delete s3.positions, s3.index = t4;
              }
              this._symbolsByKey[t3] = s3;
            }
          }
          getScaledCoordinates(t2, i2) {
            const { x: s2, y: a2, z: o2 } = this.tileID.canonical, { x: r2, y: n2, z: l2 } = i2.canonical, h2 = ie / Math.pow(2, l2 - o2), c2 = (n2 * e.W + t2.anchorY) * h2, u2 = a2 * e.W * ie;
            return { x: Math.floor((r2 * e.W + t2.anchorX) * h2 - s2 * e.W * ie), y: Math.floor(c2 - u2) };
          }
          findMatches(t2, e2, i2) {
            const s2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
            for (let a2 = 0; a2 < t2.length; a2++) {
              const o2 = t2.get(a2);
              if (o2.crossTileID)
                continue;
              const r2 = this._symbolsByKey[o2.key];
              if (!r2)
                continue;
              const n2 = this.getScaledCoordinates(o2, e2);
              if (r2.index) {
                const t3 = r2.index.range(n2.x - s2, n2.y - s2, n2.x + s2, n2.y + s2).sort();
                for (const e3 of t3) {
                  const t4 = r2.crossTileIDs[e3];
                  if (!i2[t4]) {
                    i2[t4] = true, o2.crossTileID = t4;
                    break;
                  }
                }
              } else if (r2.positions)
                for (let t3 = 0; t3 < r2.positions.length; t3++) {
                  const e3 = r2.positions[t3], a3 = r2.crossTileIDs[t3];
                  if (Math.abs(e3.x - n2.x) <= s2 && Math.abs(e3.y - n2.y) <= s2 && !i2[a3]) {
                    i2[a3] = true, o2.crossTileID = a3;
                    break;
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: t2 }) => t2);
          }
        }
        class ae {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class oe {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t2) {
            const e2 = Math.round((t2 - this.lng) / 360);
            if (0 !== e2)
              for (const t3 in this.indexes) {
                const i2 = this.indexes[t3], s2 = {};
                for (const t4 in i2) {
                  const a2 = i2[t4];
                  a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), s2[a2.tileID.key] = a2;
                }
                this.indexes[t3] = s2;
              }
            this.lng = t2;
          }
          addBucket(t2, e2, i2) {
            if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
              if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++)
              e2.symbolInstances.get(t3).crossTileID = 0;
            this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
            const s2 = this.usedCrossTileIDs[t2.overscaledZ];
            for (const i3 in this.indexes) {
              const a2 = this.indexes[i3];
              if (Number(i3) > t2.overscaledZ)
                for (const i4 in a2) {
                  const o2 = a2[i4];
                  o2.tileID.isChildOf(t2) && o2.findMatches(e2.symbolInstances, t2, s2);
                }
              else {
                const o2 = a2[t2.scaledTo(Number(i3)).key];
                o2 && o2.findMatches(e2.symbolInstances, t2, s2);
              }
            }
            for (let t3 = 0; t3 < e2.symbolInstances.length; t3++) {
              const a2 = e2.symbolInstances.get(t3);
              a2.crossTileID || (a2.crossTileID = i2.generate(), s2[a2.crossTileID] = true);
            }
            return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new se(t2, e2.symbolInstances, e2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t2, e2) {
            for (const i2 of e2.getCrossTileIDsLists())
              for (const e3 of i2)
                delete this.usedCrossTileIDs[t2][e3];
          }
          removeStaleBuckets(t2) {
            let e2 = false;
            for (const i2 in this.indexes) {
              const s2 = this.indexes[i2];
              for (const a2 in s2)
                t2[s2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, s2[a2]), delete s2[a2], e2 = true);
            }
            return e2;
          }
        }
        class re {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new ae(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t2, e2, i2) {
            let s2 = this.layerIndexes[t2.id];
            void 0 === s2 && (s2 = this.layerIndexes[t2.id] = new oe());
            let a2 = false;
            const o2 = {};
            s2.handleWrapJump(i2);
            for (const i3 of e2) {
              const e3 = i3.getBucket(t2);
              e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i3.tileID, e3, this.crossTileIDs) && (a2 = true), o2[e3.bucketInstanceId] = true);
            }
            return s2.removeStaleBuckets(o2) && (a2 = true), a2;
          }
          pruneUnusedLayers(t2) {
            const e2 = {};
            t2.forEach((t3) => {
              e2[t3] = true;
            });
            for (const t3 in this.layerIndexes)
              e2[t3] || delete this.layerIndexes[t3];
          }
        }
        const ne = (t2, i2) => e.t(t2, i2 && i2.filter((t3) => "source.canvas" !== t3.identifier)), le = e.av();
        class he extends e.E {
          constructor(t2, i2 = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const t3 in this.sourceCaches) {
                const e2 = this.sourceCaches[t3].getSource().type;
                "vector" !== e2 && "geojson" !== e2 || this.sourceCaches[t3].reload();
              }
            }, this.map = t2, this.dispatcher = new O(B(), t2._getMapId()), this.dispatcher.registerMessageHandler("GG", (t3, e2) => this.getGlyphs(t3, e2)), this.dispatcher.registerMessageHandler("GI", (t3, e2) => this.getImages(t3, e2)), this.imageManager = new T(), this.imageManager.setEventedParent(this), this.glyphManager = new S(t2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new M(256, 512), this.crossTileSymbolIndex = new re(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e.aw(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", e.ax()), ot().on(it, this._rtlPluginLoaded), this.on("data", (t3) => {
              if ("source" !== t3.dataType || "metadata" !== t3.sourceDataType)
                return;
              const e2 = this.sourceCaches[t3.sourceId];
              if (!e2)
                return;
              const i3 = e2.getSource();
              if (i3 && i3.vectorLayerIds)
                for (const t4 in this._layers) {
                  const e3 = this._layers[t4];
                  e3.source === i3.id && this._validateLayer(e3);
                }
            });
          }
          loadURL(t2, i2 = {}, s2) {
            this.fire(new e.k("dataloading", { dataType: "style" })), i2.validate = "boolean" != typeof i2.validate || i2.validate;
            const a2 = this.map._requestManager.transformRequest(t2, "Style");
            this._loadStyleRequest = new AbortController(), e.h(a2, this._loadStyleRequest).then((t3) => {
              this._loadStyleRequest = null, this._load(t3.data, i2, s2);
            }).catch((t3) => {
              this._loadStyleRequest = null, t3 && this.fire(new e.j(t3));
            });
          }
          loadJSON(t2, i2 = {}, s2) {
            this.fire(new e.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), o.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, i2.validate = false !== i2.validate, this._load(t2, i2, s2);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new e.k("dataloading", { dataType: "style" })), this._load(le, { validate: false });
          }
          _load(t2, i2, s2) {
            var a2;
            const o2 = i2.transformStyle ? i2.transformStyle(s2, t2) : t2;
            if (!i2.validate || !ne(this, e.x(o2))) {
              this._loaded = true, this.stylesheet = o2;
              for (const t3 in o2.sources)
                this.addSource(t3, o2.sources[t3], { validate: false });
              o2.sprite ? this._loadSprite(o2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o2.glyphs), this._createLayers(), this.light = new z(this.stylesheet.light), this.map.setTerrain(null !== (a2 = this.stylesheet.terrain) && void 0 !== a2 ? a2 : null), this.fire(new e.k("data", { dataType: "style" })), this.fire(new e.k("style.load"));
            }
          }
          _createLayers() {
            const t2 = e.ay(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", t2), this._order = t2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
            for (const i2 of t2) {
              const t3 = e.az(i2);
              t3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = t3;
            }
          }
          _loadSprite(t2, i2 = false, s2 = void 0) {
            let a2;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(t3, i3, s3, a3) {
              return e._(this, void 0, void 0, function* () {
                const r2 = y(t3), n2 = s3 > 1 ? "@2x" : "", l2 = {}, h2 = {};
                for (const { id: t4, url: s4 } of r2) {
                  const o2 = i3.transformRequest(i3.normalizeSpriteURL(s4, n2, ".json"), "SpriteJSON");
                  l2[t4] = e.h(o2, a3);
                  const r3 = i3.transformRequest(i3.normalizeSpriteURL(s4, n2, ".png"), "SpriteImage");
                  h2[t4] = _.getImage(r3, a3);
                }
                return yield Promise.all([...Object.values(l2), ...Object.values(h2)]), function(t4, i4) {
                  return e._(this, void 0, void 0, function* () {
                    const e2 = {};
                    for (const s4 in t4) {
                      e2[s4] = {};
                      const a4 = o.getImageCanvasContext((yield i4[s4]).data), r3 = (yield t4[s4]).data;
                      for (const t5 in r3) {
                        const { width: i5, height: o2, x: n3, y: l3, sdf: h3, pixelRatio: c2, stretchX: u2, stretchY: d2, content: _2 } = r3[t5];
                        e2[s4][t5] = { data: null, pixelRatio: c2, sdf: h3, stretchX: u2, stretchY: d2, content: _2, spriteData: { width: i5, height: o2, x: n3, y: l3, context: a4 } };
                      }
                    }
                    return e2;
                  });
                }(l2, h2);
              });
            }(t2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((t3) => {
              if (this._spriteRequest = null, t3)
                for (const e2 in t3) {
                  this._spritesImagesIds[e2] = [];
                  const s3 = this._spritesImagesIds[e2] ? this._spritesImagesIds[e2].filter((e3) => !(e3 in t3)) : [];
                  for (const t4 of s3)
                    this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                  for (const s4 in t3[e2]) {
                    const a3 = "default" === e2 ? s4 : `${e2}:${s4}`;
                    this._spritesImagesIds[e2].push(a3), a3 in this.imageManager.images ? this.imageManager.updateImage(a3, t3[e2][s4], false) : this.imageManager.addImage(a3, t3[e2][s4]), i2 && (this._changedImages[a3] = true);
                  }
                }
            }).catch((t3) => {
              this._spriteRequest = null, a2 = t3, this.fire(new e.j(a2));
            }).finally(() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" })), s2 && s2(a2);
            });
          }
          _unloadSprite() {
            for (const t2 of Object.values(this._spritesImagesIds).flat())
              this.imageManager.removeImage(t2), this._changedImages[t2] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          }
          _validateLayer(t2) {
            const i2 = this.sourceCaches[t2.source];
            if (!i2)
              return;
            const s2 = t2.sourceLayer;
            if (!s2)
              return;
            const a2 = i2.getSource();
            ("geojson" === a2.type || a2.vectorLayerIds && -1 === a2.vectorLayerIds.indexOf(s2)) && this.fire(new e.j(new Error(`Source layer "${s2}" does not exist on source "${a2.id}" as specified by style layer "${t2.id}".`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const t2 in this.sourceCaches)
              if (!this.sourceCaches[t2].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t2) {
            const e2 = this._serializedAllLayers();
            if (!t2 || 0 === t2.length)
              return Object.values(e2);
            const i2 = [];
            for (const s2 of t2)
              e2[s2] && i2.push(e2[s2]);
            return i2;
          }
          _serializedAllLayers() {
            let t2 = this._serializedLayers;
            if (t2)
              return t2;
            t2 = this._serializedLayers = {};
            const e2 = Object.keys(this._layers);
            for (const i2 of e2) {
              const e3 = this._layers[i2];
              "custom" !== e3.type && (t2[i2] = e3.serialize());
            }
            return t2;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            for (const t2 in this.sourceCaches)
              if (this.sourceCaches[t2].hasTransition())
                return true;
            for (const t2 in this._layers)
              if (this._layers[t2].hasTransition())
                return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading.");
          }
          update(t2) {
            if (!this._loaded)
              return;
            const i2 = this._changed;
            if (i2) {
              const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
              (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
              for (const t3 in this._updatedSources) {
                const e3 = this._updatedSources[t3];
                if ("reload" === e3)
                  this._reloadSource(t3);
                else {
                  if ("clear" !== e3)
                    throw new Error(`Invalid action ${e3}`);
                  this._clearSource(t3);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const e3 in this._updatedPaintProps)
                this._layers[e3].updateTransitions(t2);
              this.light.updateTransitions(t2), this._resetUpdates();
            }
            const s2 = {};
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3];
              s2[t3] = e2.used, e2.used = false;
            }
            for (const e2 of this._order) {
              const i3 = this._layers[e2];
              i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
            }
            for (const t3 in s2) {
              const i3 = this.sourceCaches[t3];
              !!s2[t3] != !!i3.used && i3.fire(new e.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: t3 }));
            }
            this.light.recalculate(t2), this.z = t2.zoom, i2 && this.fire(new e.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t2 = Object.keys(this._changedImages);
            if (t2.length) {
              for (const e2 in this.sourceCaches)
                this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t2 in this.sourceCaches)
                this.sourceCaches[t2].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t2, e2) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t2), removedIds: e2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(t2, i2 = {}) {
            var s2;
            this._checkLoaded();
            const a2 = this.serialize();
            if (t2 = i2.transformStyle ? i2.transformStyle(a2, t2) : t2, (null === (s2 = i2.validate) || void 0 === s2 || s2) && ne(this, e.x(t2)))
              return false;
            (t2 = e.aA(t2)).layers = e.ay(t2.layers);
            const o2 = e.aB(a2, t2), r2 = this._getOperationsToPerform(o2);
            if (r2.unimplemented.length > 0)
              throw new Error(`Unimplemented: ${r2.unimplemented.join(", ")}.`);
            if (0 === r2.operations.length)
              return false;
            for (const t3 of r2.operations)
              t3();
            return this.stylesheet = t2, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(t2) {
            const e2 = [], i2 = [];
            for (const s2 of t2)
              switch (s2.command) {
                case "setCenter":
                case "setZoom":
                case "setBearing":
                case "setPitch":
                  continue;
                case "addLayer":
                  e2.push(() => this.addLayer.apply(this, s2.args));
                  break;
                case "removeLayer":
                  e2.push(() => this.removeLayer.apply(this, s2.args));
                  break;
                case "setPaintProperty":
                  e2.push(() => this.setPaintProperty.apply(this, s2.args));
                  break;
                case "setLayoutProperty":
                  e2.push(() => this.setLayoutProperty.apply(this, s2.args));
                  break;
                case "setFilter":
                  e2.push(() => this.setFilter.apply(this, s2.args));
                  break;
                case "addSource":
                  e2.push(() => this.addSource.apply(this, s2.args));
                  break;
                case "removeSource":
                  e2.push(() => this.removeSource.apply(this, s2.args));
                  break;
                case "setLayerZoomRange":
                  e2.push(() => this.setLayerZoomRange.apply(this, s2.args));
                  break;
                case "setLight":
                  e2.push(() => this.setLight.apply(this, s2.args));
                  break;
                case "setGeoJSONSourceData":
                  e2.push(() => this.setGeoJSONSourceData.apply(this, s2.args));
                  break;
                case "setGlyphs":
                  e2.push(() => this.setGlyphs.apply(this, s2.args));
                  break;
                case "setSprite":
                  e2.push(() => this.setSprite.apply(this, s2.args));
                  break;
                case "setTerrain":
                  e2.push(() => this.map.setTerrain.apply(this, s2.args));
                  break;
                case "setTransition":
                  e2.push(() => {
                  });
                  break;
                default:
                  i2.push(s2.command);
              }
            return { operations: e2, unimplemented: i2 };
          }
          addImage(t2, i2) {
            if (this.getImage(t2))
              return this.fire(new e.j(new Error(`An image named "${t2}" already exists.`)));
            this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2);
          }
          updateImage(t2, e2) {
            this.imageManager.updateImage(t2, e2);
          }
          getImage(t2) {
            return this.imageManager.getImage(t2);
          }
          removeImage(t2) {
            if (!this.getImage(t2))
              return this.fire(new e.j(new Error(`An image named "${t2}" does not exist.`)));
            this.imageManager.removeImage(t2), this._afterImageUpdated(t2);
          }
          _afterImageUpdated(t2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t2, i2, s2 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[t2])
              throw new Error(`Source "${t2}" already exists.`);
            if (!i2.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.x.source, `sources.${t2}`, i2, null, s2))
              return;
            this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
            const a2 = this.sourceCaches[t2] = new ht(t2, i2, this.dispatcher);
            a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: a2.loaded(), source: a2.serialize(), sourceId: t2 })), a2.onAdd(this.map), this._changed = true;
          }
          removeSource(t2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t2])
              throw new Error("There is no source with this ID");
            for (const i3 in this._layers)
              if (this._layers[i3].source === t2)
                return this.fire(new e.j(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
            const i2 = this.sourceCaches[t2];
            delete this.sourceCaches[t2], delete this._updatedSources[t2], i2.fire(new e.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t2, e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t2])
              throw new Error(`There is no source with this ID=${t2}`);
            const i2 = this.sourceCaches[t2].getSource();
            if ("geojson" !== i2.type)
              throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
            i2.setData(e2), this._changed = true;
          }
          getSource(t2) {
            return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
          }
          addLayer(t2, i2, s2 = {}) {
            this._checkLoaded();
            const a2 = t2.id;
            if (this.getLayer(a2))
              return void this.fire(new e.j(new Error(`Layer "${a2}" already exists on this map.`)));
            let o2;
            if ("custom" === t2.type) {
              if (ne(this, e.aC(t2)))
                return;
              o2 = e.az(t2);
            } else {
              if ("source" in t2 && "object" == typeof t2.source && (this.addSource(a2, t2.source), t2 = e.aA(t2), t2 = e.e(t2, { source: a2 })), this._validate(e.x.layer, `layers.${a2}`, t2, { arrayIndex: -1 }, s2))
                return;
              o2 = e.az(t2), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: a2 } });
            }
            const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
            if (i2 && -1 === r2)
              this.fire(new e.j(new Error(`Cannot add layer "${a2}" before non-existing layer "${i2}".`)));
            else {
              if (this._order.splice(r2, 0, a2), this._layerOrderChanged = true, this._layers[a2] = o2, this._removedLayers[a2] && o2.source && "custom" !== o2.type) {
                const t3 = this._removedLayers[a2];
                delete this._removedLayers[a2], t3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
              }
              this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
            }
          }
          moveLayer(t2, i2) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t2])
              return void this.fire(new e.j(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
            if (t2 === i2)
              return;
            const s2 = this._order.indexOf(t2);
            this._order.splice(s2, 1);
            const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
            i2 && -1 === a2 ? this.fire(new e.j(new Error(`Cannot move layer "${t2}" before non-existing layer "${i2}".`))) : (this._order.splice(a2, 0, t2), this._layerOrderChanged = true);
          }
          removeLayer(t2) {
            this._checkLoaded();
            const i2 = this._layers[t2];
            if (!i2)
              return void this.fire(new e.j(new Error(`Cannot remove non-existing layer "${t2}".`)));
            i2.setEventedParent(null);
            const s2 = this._order.indexOf(t2);
            this._order.splice(s2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], this._serializedLayers && delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map);
          }
          getLayer(t2) {
            return this._layers[t2];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t2) {
            return t2 in this._layers;
          }
          setLayerZoomRange(t2, i2, s2) {
            this._checkLoaded();
            const a2 = this.getLayer(t2);
            a2 ? a2.minzoom === i2 && a2.maxzoom === s2 || (null != i2 && (a2.minzoom = i2), null != s2 && (a2.maxzoom = s2), this._updateLayer(a2)) : this.fire(new e.j(new Error(`Cannot set the zoom range of non-existing layer "${t2}".`)));
          }
          setFilter(t2, i2, s2 = {}) {
            this._checkLoaded();
            const a2 = this.getLayer(t2);
            if (a2) {
              if (!e.aD(a2.filter, i2))
                return null == i2 ? (a2.filter = void 0, void this._updateLayer(a2)) : void (this._validate(e.x.filter, `layers.${a2.id}.filter`, i2, null, s2) || (a2.filter = e.aA(i2), this._updateLayer(a2)));
            } else
              this.fire(new e.j(new Error(`Cannot filter non-existing layer "${t2}".`)));
          }
          getFilter(t2) {
            return e.aA(this.getLayer(t2).filter);
          }
          setLayoutProperty(t2, i2, s2, a2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(t2);
            o2 ? e.aD(o2.getLayoutProperty(i2), s2) || (o2.setLayoutProperty(i2, s2, a2), this._updateLayer(o2)) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
          }
          getLayoutProperty(t2, i2) {
            const s2 = this.getLayer(t2);
            if (s2)
              return s2.getLayoutProperty(i2);
            this.fire(new e.j(new Error(`Cannot get style of non-existing layer "${t2}".`)));
          }
          setPaintProperty(t2, i2, s2, a2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(t2);
            o2 ? e.aD(o2.getPaintProperty(i2), s2) || (o2.setPaintProperty(i2, s2, a2) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[t2] = true, this._serializedLayers = null) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
          }
          getPaintProperty(t2, e2) {
            return this.getLayer(t2).getPaintProperty(e2);
          }
          setFeatureState(t2, i2) {
            this._checkLoaded();
            const s2 = t2.source, a2 = t2.sourceLayer, o2 = this.sourceCaches[s2];
            if (void 0 === o2)
              return void this.fire(new e.j(new Error(`The source '${s2}' does not exist in the map's style.`)));
            const r2 = o2.getSource().type;
            "geojson" === r2 && a2 ? this.fire(new e.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r2 || a2 ? (void 0 === t2.id && this.fire(new e.j(new Error("The feature id parameter must be provided."))), o2.setFeatureState(a2, t2.id, i2)) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t2, i2) {
            this._checkLoaded();
            const s2 = t2.source, a2 = this.sourceCaches[s2];
            if (void 0 === a2)
              return void this.fire(new e.j(new Error(`The source '${s2}' does not exist in the map's style.`)));
            const o2 = a2.getSource().type, r2 = "vector" === o2 ? t2.sourceLayer : void 0;
            "vector" !== o2 || r2 ? i2 && "string" != typeof t2.id && "number" != typeof t2.id ? this.fire(new e.j(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(r2, t2.id, i2) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t2) {
            this._checkLoaded();
            const i2 = t2.source, s2 = t2.sourceLayer, a2 = this.sourceCaches[i2];
            if (void 0 !== a2)
              return "vector" !== a2.getSource().type || s2 ? (void 0 === t2.id && this.fire(new e.j(new Error("The feature id parameter must be provided."))), a2.getFeatureState(s2, t2.id)) : void this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new e.j(new Error(`The source '${i2}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded)
              return;
            const t2 = e.aE(this.sourceCaches, (t3) => t3.serialize()), i2 = this._serializeByIds(this._order), s2 = this.map.getTerrain() || void 0, a2 = this.stylesheet;
            return e.aF({ version: a2.version, name: a2.name, metadata: a2.metadata, light: a2.light, center: a2.center, zoom: a2.zoom, bearing: a2.bearing, pitch: a2.pitch, sprite: a2.sprite, glyphs: a2.glyphs, transition: a2.transition, sources: t2, layers: i2, terrain: s2 }, (t3) => void 0 !== t3);
          }
          _updateLayer(t2) {
            this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t2) {
            const e2 = (t3) => "fill-extrusion" === this._layers[t3].type, i2 = {}, s2 = [];
            for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
              const o2 = this._order[a3];
              if (e2(o2)) {
                i2[o2] = a3;
                for (const e3 of t2) {
                  const t3 = e3[o2];
                  if (t3)
                    for (const e4 of t3)
                      s2.push(e4);
                }
              }
            }
            s2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
            const a2 = [];
            for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
              const r2 = this._order[o2];
              if (e2(r2))
                for (let t3 = s2.length - 1; t3 >= 0; t3--) {
                  const e3 = s2[t3].feature;
                  if (i2[e3.layer.id] < o2)
                    break;
                  a2.push(e3), s2.pop();
                }
              else
                for (const e3 of t2) {
                  const t3 = e3[r2];
                  if (t3)
                    for (const e4 of t3)
                      a2.push(e4.feature);
                }
            }
            return a2;
          }
          queryRenderedFeatures(t2, i2, s2) {
            i2 && i2.filter && this._validate(e.x.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
            const a2 = {};
            if (i2 && i2.layers) {
              if (!Array.isArray(i2.layers))
                return this.fire(new e.j(new Error("parameters.layers must be an Array."))), [];
              for (const t3 of i2.layers) {
                const i3 = this._layers[t3];
                if (!i3)
                  return this.fire(new e.j(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                a2[i3.source] = true;
              }
            }
            const o2 = [];
            i2.availableImages = this._availableImages;
            const r2 = this._serializedAllLayers();
            for (const e2 in this.sourceCaches)
              i2.layers && !a2[e2] || o2.push(Z(this.sourceCaches[e2], this._layers, r2, t2, i2, s2));
            return this.placement && o2.push(function(t3, e2, i3, s3, a3, o3, r3) {
              const n2 = {}, l2 = o3.queryRenderedSymbols(s3), h2 = [];
              for (const t4 of Object.keys(l2).map(Number))
                h2.push(r3[t4]);
              h2.sort(G);
              for (const i4 of h2) {
                const s4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e2, i4.bucketIndex, i4.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t3);
                for (const t4 in s4) {
                  const e3 = n2[t4] = n2[t4] || [], a4 = s4[t4];
                  a4.sort((t5, e4) => {
                    const s5 = i4.featureSortOrder;
                    if (s5) {
                      const i5 = s5.indexOf(t5.featureIndex);
                      return s5.indexOf(e4.featureIndex) - i5;
                    }
                    return e4.featureIndex - t5.featureIndex;
                  });
                  for (const t5 of a4)
                    e3.push(t5);
                }
              }
              for (const e3 in n2)
                n2[e3].forEach((s4) => {
                  const a4 = s4.feature, o4 = i3[t3[e3].source].getFeatureState(a4.layer["source-layer"], a4.id);
                  a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = o4;
                });
              return n2;
            }(this._layers, r2, this.sourceCaches, t2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
          }
          querySourceFeatures(t2, i2) {
            i2 && i2.filter && this._validate(e.x.filter, "querySourceFeatures.filter", i2.filter, null, i2);
            const s2 = this.sourceCaches[t2];
            return s2 ? function(t3, e2) {
              const i3 = t3.getRenderableIds().map((e3) => t3.getTileByID(e3)), s3 = [], a2 = {};
              for (let t4 = 0; t4 < i3.length; t4++) {
                const o2 = i3[t4], r2 = o2.tileID.canonical.key;
                a2[r2] || (a2[r2] = true, o2.querySourceFeatures(s3, e2));
              }
              return s3;
            }(s2, i2) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t2, i2 = {}) {
            this._checkLoaded();
            const s2 = this.light.getLight();
            let a2 = false;
            for (const i3 in t2)
              if (!e.aD(t2[i3], s2[i3])) {
                a2 = true;
                break;
              }
            if (!a2)
              return;
            const r2 = { now: o.now(), transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t2, i2), this.light.updateTransitions(r2);
          }
          _validate(t2, i2, s2, a2, o2 = {}) {
            return (!o2 || false !== o2.validate) && ne(this, t2.call(e.x, e.e({ key: i2, style: this.serialize(), value: s2, styleSpec: e.v }, a2)));
          }
          _remove(t2 = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ot().off(it, this._rtlPluginLoaded);
            for (const t3 in this._layers)
              this._layers[t3].setEventedParent(null);
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3];
              e2.setEventedParent(null), e2.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t2 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t2);
          }
          _clearSource(t2) {
            this.sourceCaches[t2].clearTiles();
          }
          _reloadSource(t2) {
            this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
          }
          _updateSources(t2) {
            for (const e2 in this.sourceCaches)
              this.sourceCaches[e2].update(t2, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t2 in this.sourceCaches)
              this._reloadSource(t2);
          }
          _updatePlacement(t2, e2, i2, s2, a2 = false) {
            let r2 = false, n2 = false;
            const l2 = {};
            for (const e3 of this._order) {
              const i3 = this._layers[e3];
              if ("symbol" !== i3.type)
                continue;
              if (!l2[i3.source]) {
                const t3 = this.sourceCaches[i3.source];
                l2[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
              }
              const s3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng);
              r2 = r2 || s3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a2 = a2 || this._layerOrderChanged || 0 === i2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.now(), t2.zoom)) && (this.pauseablePlacement = new ee(t2, this.map.terrain, this._order, a2, e2, i2, s2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
              for (const t3 of this._order) {
                const e3 = this._layers[t3];
                "symbol" === e3.type && this.placement.updateLayerOpacities(e3, l2[e3.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t2 in this.sourceCaches)
              this.sourceCaches[t2].releaseSymbolFadeTiles();
          }
          getImages(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const t3 = yield this.imageManager.getImages(i2.icons);
              this._updateTilesForChangedImages();
              const e2 = this.sourceCaches[i2.source];
              return e2 && e2.setDependencies(i2.tileID.key, i2.type, i2.icons), t3;
            });
          }
          getGlyphs(t2, i2) {
            return e._(this, void 0, void 0, function* () {
              const t3 = yield this.glyphManager.getGlyphs(i2.stacks), e2 = this.sourceCaches[i2.source];
              return e2 && e2.setDependencies(i2.tileID.key, i2.type, [""]), t3;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t2, i2 = {}) {
            this._checkLoaded(), t2 && this._validate(e.x.glyphs, "glyphs", t2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t2, this.glyphManager.entries = {}, this.glyphManager.setURL(t2));
          }
          addSprite(t2, i2, s2 = {}, a2) {
            this._checkLoaded();
            const o2 = [{ id: t2, url: i2 }], r2 = [...y(this.stylesheet.sprite), ...o2];
            this._validate(e.x.sprite, "sprite", r2, null, s2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, a2));
          }
          removeSprite(t2) {
            this._checkLoaded();
            const i2 = y(this.stylesheet.sprite);
            if (i2.find((e2) => e2.id === t2)) {
              if (this._spritesImagesIds[t2])
                for (const e2 of this._spritesImagesIds[t2])
                  this.imageManager.removeImage(e2), this._changedImages[e2] = true;
              i2.splice(i2.findIndex((e2) => e2.id === t2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : void 0, delete this._spritesImagesIds[t2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
            } else
              this.fire(new e.j(new Error(`Sprite "${t2}" doesn't exists on this map.`)));
          }
          getSprite() {
            return y(this.stylesheet.sprite);
          }
          setSprite(t2, i2 = {}, s2) {
            this._checkLoaded(), t2 && this._validate(e.x.sprite, "sprite", t2, null, i2) || (this.stylesheet.sprite = t2, t2 ? this._loadSprite(t2, true, s2) : (this._unloadSprite(), s2 && s2(null)));
          }
        }
        var ce = e.X([{ name: "a_pos", type: "Int16", components: 2 }]), ue = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const de = { prelude: _e("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: _e("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: _e("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _e("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: _e("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: _e("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: _e("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _e("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _e("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: _e("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: _e("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: _e("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: _e("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: _e("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: _e("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: _e("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: _e("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _e("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: _e("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: _e("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: _e("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: _e("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: _e("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: _e("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: _e("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: _e("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: _e("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ue), terrainDepth: _e("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ue), terrainCoords: _e("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ue) };
        function _e(t2, e2) {
          const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s2 = e2.match(/attribute ([\w]+) ([\w]+)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(a2) : a2, n2 = {};
          return { fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, s3, a3) => (n2[a3] = true, "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i3} ${s3} ${a3};
#else
uniform ${i3} ${s3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i3} ${s3} ${a3} = u_${a3};
#endif
`)), vertexSource: e2 = e2.replace(i2, (t3, e3, i3, s3, a3) => {
            const o3 = "float" === s3 ? "vec2" : "vec4", r3 = a3.match(/color/) ? "color" : o3;
            return n2[a3] ? "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${o3} a_${a3};
varying ${i3} ${s3} ${a3};
#else
uniform ${i3} ${s3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i3} ${s3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${s3} ${a3} = u_${a3};
#endif
` : "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${o3} a_${a3};
#else
uniform ${i3} ${s3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${s3} ${a3} = a_${a3};
#else
    ${i3} ${s3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${s3} ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${s3} ${a3} = u_${a3};
#endif
`;
          }), staticAttributes: s2, staticUniforms: r2 };
        }
        class pe {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t2, e2, i2, s2, a2, o2, r2, n2, l2) {
            this.context = t2;
            let h2 = this.boundPaintVertexBuffers.length !== s2.length;
            for (let t3 = 0; !h2 && t3 < s2.length; t3++)
              this.boundPaintVertexBuffers[t3] !== s2[t3] && (h2 = true);
            !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i2 || h2 || this.boundIndexBuffer !== a2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(e2, i2, s2, a2, o2, r2, n2, l2) : (t2.bindVertexArray.set(this.vao), r2 && r2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind(), l2 && l2.bind());
          }
          freshBind(t2, e2, i2, s2, a2, o2, r2, n2) {
            const l2 = t2.numAttributes, h2 = this.context, c2 = h2.gl;
            this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = s2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2, e2.enableAttributes(c2, t2);
            for (const e3 of i2)
              e3.enableAttributes(c2, t2);
            o2 && o2.enableAttributes(c2, t2), r2 && r2.enableAttributes(c2, t2), n2 && n2.enableAttributes(c2, t2), e2.bind(), e2.setVertexAttribPointers(c2, t2, a2);
            for (const e3 of i2)
              e3.bind(), e3.setVertexAttribPointers(c2, t2, a2);
            o2 && (o2.bind(), o2.setVertexAttribPointers(c2, t2, a2)), s2 && s2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(c2, t2, a2)), n2 && (n2.bind(), n2.setVertexAttribPointers(c2, t2, a2)), h2.currentNumAttributes = l2;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function me(t2) {
          const e2 = [];
          for (let i2 = 0; i2 < t2.length; i2++) {
            if (null === t2[i2])
              continue;
            const s2 = t2[i2].split(" ");
            e2.push(s2.pop());
          }
          return e2;
        }
        class fe {
          constructor(t2, i2, s2, a2, o2, r2) {
            const n2 = t2.gl;
            this.program = n2.createProgram();
            const l2 = me(i2.staticAttributes), h2 = s2 ? s2.getBinderAttributes() : [], c2 = l2.concat(h2), u2 = de.prelude.staticUniforms ? me(de.prelude.staticUniforms) : [], d2 = i2.staticUniforms ? me(i2.staticUniforms) : [], _2 = s2 ? s2.getBinderUniforms() : [], p2 = u2.concat(d2).concat(_2), m2 = [];
            for (const t3 of p2)
              m2.indexOf(t3) < 0 && m2.push(t3);
            const f2 = s2 ? s2.defines() : [];
            o2 && f2.push("#define OVERDRAW_INSPECTOR;"), r2 && f2.push("#define TERRAIN3D;");
            const g2 = f2.concat(de.prelude.fragmentSource, i2.fragmentSource).join("\n"), v2 = f2.concat(de.prelude.vertexSource, i2.vertexSource).join("\n"), x2 = n2.createShader(n2.FRAGMENT_SHADER);
            if (n2.isContextLost())
              return void (this.failedToCreate = true);
            if (n2.shaderSource(x2, g2), n2.compileShader(x2), !n2.getShaderParameter(x2, n2.COMPILE_STATUS))
              throw new Error(`Could not compile fragment shader: ${n2.getShaderInfoLog(x2)}`);
            n2.attachShader(this.program, x2);
            const y2 = n2.createShader(n2.VERTEX_SHADER);
            if (n2.isContextLost())
              return void (this.failedToCreate = true);
            if (n2.shaderSource(y2, v2), n2.compileShader(y2), !n2.getShaderParameter(y2, n2.COMPILE_STATUS))
              throw new Error(`Could not compile vertex shader: ${n2.getShaderInfoLog(y2)}`);
            n2.attachShader(this.program, y2), this.attributes = {};
            const b2 = {};
            this.numAttributes = c2.length;
            for (let t3 = 0; t3 < this.numAttributes; t3++)
              c2[t3] && (n2.bindAttribLocation(this.program, t3, c2[t3]), this.attributes[c2[t3]] = t3);
            if (n2.linkProgram(this.program), !n2.getProgramParameter(this.program, n2.LINK_STATUS))
              throw new Error(`Program failed to link: ${n2.getProgramInfoLog(this.program)}`);
            n2.deleteShader(y2), n2.deleteShader(x2);
            for (let t3 = 0; t3 < m2.length; t3++) {
              const e2 = m2[t3];
              if (e2 && !b2[e2]) {
                const t4 = n2.getUniformLocation(this.program, e2);
                t4 && (b2[e2] = t4);
              }
            }
            this.fixedUniforms = a2(t2, b2), this.terrainUniforms = ((t3, i3) => ({ u_depth: new e.aG(t3, i3.u_depth), u_terrain: new e.aG(t3, i3.u_terrain), u_terrain_dim: new e.aH(t3, i3.u_terrain_dim), u_terrain_matrix: new e.aI(t3, i3.u_terrain_matrix), u_terrain_unpack: new e.aJ(t3, i3.u_terrain_unpack), u_terrain_exaggeration: new e.aH(t3, i3.u_terrain_exaggeration) }))(t2, b2), this.binderUniforms = s2 ? s2.getUniforms(t2, b2) : [];
          }
          draw(t2, e2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2, g2) {
            const v2 = t2.gl;
            if (this.failedToCreate)
              return;
            if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(s2), t2.setColorMode(a2), t2.setCullFace(o2), n2) {
              t2.activeTexture.set(v2.TEXTURE2), v2.bindTexture(v2.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(v2.TEXTURE3), v2.bindTexture(v2.TEXTURE_2D, n2.texture);
              for (const t3 in this.terrainUniforms)
                this.terrainUniforms[t3].set(n2[t3]);
            }
            for (const t3 in this.fixedUniforms)
              this.fixedUniforms[t3].set(r2[t3]);
            p2 && p2.setUniforms(t2, this.binderUniforms, d2, { zoom: _2 });
            let x2 = 0;
            switch (e2) {
              case v2.LINES:
                x2 = 2;
                break;
              case v2.TRIANGLES:
                x2 = 3;
                break;
              case v2.LINE_STRIP:
                x2 = 1;
            }
            for (const i3 of u2.get()) {
              const s3 = i3.vaos || (i3.vaos = {});
              (s3[l2] || (s3[l2] = new pe())).bind(t2, this, h2, p2 ? p2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, m2, f2, g2), v2.drawElements(e2, i3.primitiveLength * x2, v2.UNSIGNED_SHORT, i3.primitiveOffset * x2 * 2);
            }
          }
        }
        function ge(t2, e2, i2) {
          const s2 = 1 / Lt(i2, 1, e2.transform.tileZoom), a2 = Math.pow(2, i2.tileID.overscaledZ), o2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / a2, r2 = o2 * (i2.tileID.canonical.x + i2.tileID.wrap * a2), n2 = o2 * i2.tileID.canonical.y;
          return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [s2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
        }
        const ve = (t2, i2, s2, a2) => {
          const o2 = i2.style.light, r2 = o2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
            var t3 = new e.A(9);
            return e.A != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
          }();
          "viewport" === o2.properties.get("anchor") && function(t3, e2) {
            var i3 = Math.sin(e2), s3 = Math.cos(e2);
            t3[0] = s3, t3[1] = i3, t3[2] = 0, t3[3] = -i3, t3[4] = s3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
          }(l2, -i2.transform.angle), function(t3, e2, i3) {
            var s3 = e2[0], a3 = e2[1], o3 = e2[2];
            t3[0] = s3 * i3[0] + a3 * i3[3] + o3 * i3[6], t3[1] = s3 * i3[1] + a3 * i3[4] + o3 * i3[7], t3[2] = s3 * i3[2] + a3 * i3[5] + o3 * i3[8];
          }(n2, n2, l2);
          const h2 = o2.properties.get("color");
          return { u_matrix: t2, u_lightpos: n2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +s2, u_opacity: a2 };
        }, xe = (t2, i2, s2, a2, o2, r2, n2) => e.e(ve(t2, i2, s2, a2), ge(r2, i2, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), ye = (t2) => ({ u_matrix: t2 }), be = (t2, i2, s2, a2) => e.e(ye(t2), ge(s2, i2, a2)), we = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), Te = (t2, i2, s2, a2, o2) => e.e(be(t2, i2, s2, a2), { u_world: o2 }), Ie = (t2, e2, i2, s2) => {
          const a2 = t2.transform;
          let o2, r2;
          if ("map" === s2.paint.get("circle-pitch-alignment")) {
            const t3 = Lt(i2, 1, a2.zoom);
            o2 = true, r2 = [t3, t3];
          } else
            o2 = false, r2 = a2.pixelsToGLUnits;
          return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +("map" === s2.paint.get("circle-pitch-scale")), u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_pitch_with_map: +o2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: r2 };
        }, Ee = (t2, e2, i2) => {
          const s2 = Lt(i2, 1, e2.zoom), a2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), o2 = i2.tileID.overscaleFactor();
          return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: s2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (s2 * a2), e2.pixelsToGLUnits[1] / (s2 * a2)], u_overscale_factor: o2 };
        }, Ce = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), Se = (t2) => ({ u_matrix: t2 }), Pe = (t2, e2, i2, s2) => ({ u_matrix: t2, u_extrude_scale: Lt(e2, 1, i2), u_intensity: s2 });
        function De(t2, i2) {
          const s2 = Math.pow(2, i2.canonical.z), a2 = i2.canonical.y;
          return [new e.Y(0, a2 / s2).toLngLat().lat, new e.Y(0, (a2 + 1) / s2).toLngLat().lat];
        }
        const ze = (t2, e2, i2, s2) => {
          const a2 = t2.transform;
          return { u_matrix: ke(t2, e2, i2, s2), u_ratio: 1 / Lt(e2, 1, a2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, Me = (t2, i2, s2, a2, o2) => e.e(ze(t2, i2, s2, o2), { u_image: 0, u_image_height: a2 }), Ae = (t2, e2, i2, s2, a2) => {
          const o2 = t2.transform, r2 = Le(e2, o2);
          return { u_matrix: ke(t2, e2, i2, a2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / Lt(e2, 1, o2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [r2, s2.fromScale, s2.toScale], u_fade: s2.t, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
        }, Re = (t2, i2, s2, a2, o2, r2) => {
          const n2 = t2.lineAtlas, l2 = Le(i2, t2.transform), h2 = "round" === s2.layout.get("line-cap"), c2 = n2.getDash(a2.from, h2), u2 = n2.getDash(a2.to, h2), d2 = c2.width * o2.fromScale, _2 = u2.width * o2.toScale;
          return e.e(ze(t2, i2, s2, r2), { u_patternscale_a: [l2 / d2, -c2.height / 2], u_patternscale_b: [l2 / _2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * t2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u2.y, u_mix: o2.t });
        };
        function Le(t2, e2) {
          return 1 / Lt(t2, 1, e2.tileZoom);
        }
        function ke(t2, e2, i2, s2) {
          return t2.translatePosMatrix(s2 ? s2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
        }
        const Fe = (t2, e2, i2, s2, a2) => {
          return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: s2.mix, u_opacity: s2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = a2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (o2 = a2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: Be(a2.paint.get("raster-hue-rotate")) };
          var o2, r2;
        };
        function Be(t2) {
          t2 *= Math.PI / 180;
          const e2 = Math.sin(t2), i2 = Math.cos(t2);
          return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
        }
        const Oe = (t2, e2, i2, s2, a2, o2, r2, n2, l2, h2) => {
          const c2 = a2.transform;
          return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: c2.cameraToCenterDistance, u_pitch: c2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: c2.width / c2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: o2, u_label_plane_matrix: r2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +s2, u_texsize: h2, u_texture: 0 };
        }, Ne = (t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2) => {
          const d2 = o2.transform;
          return e.e(Oe(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: o2.pixelRatio, u_is_halo: +u2 });
        }, Ue = (t2, i2, s2, a2, o2, r2, n2, l2, h2, c2) => e.e(Ne(t2, i2, s2, a2, o2, r2, n2, l2, true, h2, true), { u_texsize_icon: c2, u_texture_icon: 1 }), Ze = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), Ge = (t2, i2, s2, a2, o2, r2) => e.e(function(t3, e2, i3, s3) {
          const a3 = i3.imageManager.getPattern(t3.from.toString()), o3 = i3.imageManager.getPattern(t3.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, s3.tileID.overscaledZ), h2 = s3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, c2 = h2 * (s3.tileID.canonical.x + s3.tileID.wrap * l2), u2 = h2 * s3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [r3, n2], u_mix: e2.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: e2.fromScale, u_scale_b: e2.toScale, u_tile_units_to_pixels: 1 / Lt(s3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [c2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & c2, 65535 & u2] };
        }(a2, r2, s2, o2), { u_matrix: t2, u_opacity: i2 }), qe = { fillExtrusion: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_lightpos: new e.aK(t2, i2.u_lightpos), u_lightintensity: new e.aH(t2, i2.u_lightintensity), u_lightcolor: new e.aK(t2, i2.u_lightcolor), u_vertical_gradient: new e.aH(t2, i2.u_vertical_gradient), u_opacity: new e.aH(t2, i2.u_opacity) }), fillExtrusionPattern: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_lightpos: new e.aK(t2, i2.u_lightpos), u_lightintensity: new e.aH(t2, i2.u_lightintensity), u_lightcolor: new e.aK(t2, i2.u_lightcolor), u_vertical_gradient: new e.aH(t2, i2.u_vertical_gradient), u_height_factor: new e.aH(t2, i2.u_height_factor), u_image: new e.aG(t2, i2.u_image), u_texsize: new e.aL(t2, i2.u_texsize), u_pixel_coord_upper: new e.aL(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aL(t2, i2.u_pixel_coord_lower), u_scale: new e.aK(t2, i2.u_scale), u_fade: new e.aH(t2, i2.u_fade), u_opacity: new e.aH(t2, i2.u_opacity) }), fill: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix) }), fillPattern: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_image: new e.aG(t2, i2.u_image), u_texsize: new e.aL(t2, i2.u_texsize), u_pixel_coord_upper: new e.aL(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aL(t2, i2.u_pixel_coord_lower), u_scale: new e.aK(t2, i2.u_scale), u_fade: new e.aH(t2, i2.u_fade) }), fillOutline: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_world: new e.aL(t2, i2.u_world) }), fillOutlinePattern: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_world: new e.aL(t2, i2.u_world), u_image: new e.aG(t2, i2.u_image), u_texsize: new e.aL(t2, i2.u_texsize), u_pixel_coord_upper: new e.aL(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aL(t2, i2.u_pixel_coord_lower), u_scale: new e.aK(t2, i2.u_scale), u_fade: new e.aH(t2, i2.u_fade) }), circle: (t2, i2) => ({ u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_scale_with_map: new e.aG(t2, i2.u_scale_with_map), u_pitch_with_map: new e.aG(t2, i2.u_pitch_with_map), u_extrude_scale: new e.aL(t2, i2.u_extrude_scale), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_matrix: new e.aI(t2, i2.u_matrix) }), collisionBox: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new e.aH(t2, i2.u_pixels_to_tile_units), u_extrude_scale: new e.aL(t2, i2.u_extrude_scale), u_overscale_factor: new e.aH(t2, i2.u_overscale_factor) }), collisionCircle: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_inv_matrix: new e.aI(t2, i2.u_inv_matrix), u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_viewport_size: new e.aL(t2, i2.u_viewport_size) }), debug: (t2, i2) => ({ u_color: new e.aM(t2, i2.u_color), u_matrix: new e.aI(t2, i2.u_matrix), u_overlay: new e.aG(t2, i2.u_overlay), u_overlay_scale: new e.aH(t2, i2.u_overlay_scale) }), clippingMask: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix) }), heatmap: (t2, i2) => ({ u_extrude_scale: new e.aH(t2, i2.u_extrude_scale), u_intensity: new e.aH(t2, i2.u_intensity), u_matrix: new e.aI(t2, i2.u_matrix) }), heatmapTexture: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_world: new e.aL(t2, i2.u_world), u_image: new e.aG(t2, i2.u_image), u_color_ramp: new e.aG(t2, i2.u_color_ramp), u_opacity: new e.aH(t2, i2.u_opacity) }), hillshade: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_image: new e.aG(t2, i2.u_image), u_latrange: new e.aL(t2, i2.u_latrange), u_light: new e.aL(t2, i2.u_light), u_shadow: new e.aM(t2, i2.u_shadow), u_highlight: new e.aM(t2, i2.u_highlight), u_accent: new e.aM(t2, i2.u_accent) }), hillshadePrepare: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_image: new e.aG(t2, i2.u_image), u_dimension: new e.aL(t2, i2.u_dimension), u_zoom: new e.aH(t2, i2.u_zoom), u_unpack: new e.aJ(t2, i2.u_unpack) }), line: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_ratio: new e.aH(t2, i2.u_ratio), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aL(t2, i2.u_units_to_pixels) }), lineGradient: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_ratio: new e.aH(t2, i2.u_ratio), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aL(t2, i2.u_units_to_pixels), u_image: new e.aG(t2, i2.u_image), u_image_height: new e.aH(t2, i2.u_image_height) }), linePattern: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_texsize: new e.aL(t2, i2.u_texsize), u_ratio: new e.aH(t2, i2.u_ratio), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_image: new e.aG(t2, i2.u_image), u_units_to_pixels: new e.aL(t2, i2.u_units_to_pixels), u_scale: new e.aK(t2, i2.u_scale), u_fade: new e.aH(t2, i2.u_fade) }), lineSDF: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_ratio: new e.aH(t2, i2.u_ratio), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aL(t2, i2.u_units_to_pixels), u_patternscale_a: new e.aL(t2, i2.u_patternscale_a), u_patternscale_b: new e.aL(t2, i2.u_patternscale_b), u_sdfgamma: new e.aH(t2, i2.u_sdfgamma), u_image: new e.aG(t2, i2.u_image), u_tex_y_a: new e.aH(t2, i2.u_tex_y_a), u_tex_y_b: new e.aH(t2, i2.u_tex_y_b), u_mix: new e.aH(t2, i2.u_mix) }), raster: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_tl_parent: new e.aL(t2, i2.u_tl_parent), u_scale_parent: new e.aH(t2, i2.u_scale_parent), u_buffer_scale: new e.aH(t2, i2.u_buffer_scale), u_fade_t: new e.aH(t2, i2.u_fade_t), u_opacity: new e.aH(t2, i2.u_opacity), u_image0: new e.aG(t2, i2.u_image0), u_image1: new e.aG(t2, i2.u_image1), u_brightness_low: new e.aH(t2, i2.u_brightness_low), u_brightness_high: new e.aH(t2, i2.u_brightness_high), u_saturation_factor: new e.aH(t2, i2.u_saturation_factor), u_contrast_factor: new e.aH(t2, i2.u_contrast_factor), u_spin_weights: new e.aK(t2, i2.u_spin_weights) }), symbolIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aG(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aG(t2, i2.u_is_size_feature_constant), u_size_t: new e.aH(t2, i2.u_size_t), u_size: new e.aH(t2, i2.u_size), u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_pitch: new e.aH(t2, i2.u_pitch), u_rotate_symbol: new e.aG(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aH(t2, i2.u_aspect_ratio), u_fade_change: new e.aH(t2, i2.u_fade_change), u_matrix: new e.aI(t2, i2.u_matrix), u_label_plane_matrix: new e.aI(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aI(t2, i2.u_coord_matrix), u_is_text: new e.aG(t2, i2.u_is_text), u_pitch_with_map: new e.aG(t2, i2.u_pitch_with_map), u_texsize: new e.aL(t2, i2.u_texsize), u_texture: new e.aG(t2, i2.u_texture) }), symbolSDF: (t2, i2) => ({ u_is_size_zoom_constant: new e.aG(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aG(t2, i2.u_is_size_feature_constant), u_size_t: new e.aH(t2, i2.u_size_t), u_size: new e.aH(t2, i2.u_size), u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_pitch: new e.aH(t2, i2.u_pitch), u_rotate_symbol: new e.aG(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aH(t2, i2.u_aspect_ratio), u_fade_change: new e.aH(t2, i2.u_fade_change), u_matrix: new e.aI(t2, i2.u_matrix), u_label_plane_matrix: new e.aI(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aI(t2, i2.u_coord_matrix), u_is_text: new e.aG(t2, i2.u_is_text), u_pitch_with_map: new e.aG(t2, i2.u_pitch_with_map), u_texsize: new e.aL(t2, i2.u_texsize), u_texture: new e.aG(t2, i2.u_texture), u_gamma_scale: new e.aH(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aG(t2, i2.u_is_halo) }), symbolTextAndIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aG(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aG(t2, i2.u_is_size_feature_constant), u_size_t: new e.aH(t2, i2.u_size_t), u_size: new e.aH(t2, i2.u_size), u_camera_to_center_distance: new e.aH(t2, i2.u_camera_to_center_distance), u_pitch: new e.aH(t2, i2.u_pitch), u_rotate_symbol: new e.aG(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aH(t2, i2.u_aspect_ratio), u_fade_change: new e.aH(t2, i2.u_fade_change), u_matrix: new e.aI(t2, i2.u_matrix), u_label_plane_matrix: new e.aI(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aI(t2, i2.u_coord_matrix), u_is_text: new e.aG(t2, i2.u_is_text), u_pitch_with_map: new e.aG(t2, i2.u_pitch_with_map), u_texsize: new e.aL(t2, i2.u_texsize), u_texsize_icon: new e.aL(t2, i2.u_texsize_icon), u_texture: new e.aG(t2, i2.u_texture), u_texture_icon: new e.aG(t2, i2.u_texture_icon), u_gamma_scale: new e.aH(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aH(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aG(t2, i2.u_is_halo) }), background: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_opacity: new e.aH(t2, i2.u_opacity), u_color: new e.aM(t2, i2.u_color) }), backgroundPattern: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_opacity: new e.aH(t2, i2.u_opacity), u_image: new e.aG(t2, i2.u_image), u_pattern_tl_a: new e.aL(t2, i2.u_pattern_tl_a), u_pattern_br_a: new e.aL(t2, i2.u_pattern_br_a), u_pattern_tl_b: new e.aL(t2, i2.u_pattern_tl_b), u_pattern_br_b: new e.aL(t2, i2.u_pattern_br_b), u_texsize: new e.aL(t2, i2.u_texsize), u_mix: new e.aH(t2, i2.u_mix), u_pattern_size_a: new e.aL(t2, i2.u_pattern_size_a), u_pattern_size_b: new e.aL(t2, i2.u_pattern_size_b), u_scale_a: new e.aH(t2, i2.u_scale_a), u_scale_b: new e.aH(t2, i2.u_scale_b), u_pixel_coord_upper: new e.aL(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aL(t2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new e.aH(t2, i2.u_tile_units_to_pixels) }), terrain: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_texture: new e.aG(t2, i2.u_texture), u_ele_delta: new e.aH(t2, i2.u_ele_delta) }), terrainDepth: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_ele_delta: new e.aH(t2, i2.u_ele_delta) }), terrainCoords: (t2, i2) => ({ u_matrix: new e.aI(t2, i2.u_matrix), u_texture: new e.aG(t2, i2.u_texture), u_terrain_coords_id: new e.aH(t2, i2.u_terrain_coords_id), u_ele_delta: new e.aH(t2, i2.u_ele_delta) }) };
        class je {
          constructor(t2, e2, i2) {
            this.context = t2;
            const s2 = t2.gl;
            this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t2) {
            const e2 = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ve = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class He {
          constructor(t2, e2, i2, s2) {
            this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = s2, this.context = t2;
            const a2 = t2.gl;
            this.buffer = a2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t2) {
            if (t2.length !== this.length)
              throw new Error(`Length of new data is ${t2.length}, which doesn't match current length of ${this.length}`);
            const e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
          }
          enableAttributes(t2, e2) {
            for (let i2 = 0; i2 < this.attributes.length; i2++) {
              const s2 = e2.attributes[this.attributes[i2].name];
              void 0 !== s2 && t2.enableVertexAttribArray(s2);
            }
          }
          setVertexAttribPointers(t2, e2, i2) {
            for (let s2 = 0; s2 < this.attributes.length; s2++) {
              const a2 = this.attributes[s2], o2 = e2.attributes[a2.name];
              void 0 !== o2 && t2.vertexAttribPointer(o2, a2.components, t2[Ve[a2.type]], false, this.itemSize, a2.offset + this.itemSize * (i2 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const We = /* @__PURE__ */ new WeakMap();
        function $e(t2) {
          var e2;
          if (We.has(t2))
            return We.get(t2);
          {
            const i2 = null === (e2 = t2.getParameter(t2.VERSION)) || void 0 === e2 ? void 0 : e2.startsWith("WebGL 2.0");
            return We.set(t2, i2), i2;
          }
        }
        class Xe {
          constructor(t2) {
            this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t2) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ke extends Xe {
          getDefault() {
            return e.aO.transparent;
          }
          set(t2) {
            const e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class Ye extends Xe {
          getDefault() {
            return 1;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
          }
        }
        class Je extends Xe {
          getDefault() {
            return 0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
          }
        }
        class Qe extends Xe {
          getDefault() {
            return [true, true, true, true];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class ti extends Xe {
          getDefault() {
            return true;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class ei extends Xe {
          getDefault() {
            return 255;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
          }
        }
        class ii extends Xe {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t2) {
            const e2 = this.current;
            (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
          }
        }
        class si extends Xe {
          getDefault() {
            const t2 = this.gl;
            return [t2.KEEP, t2.KEEP, t2.KEEP];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
          }
        }
        class ai extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
          }
        }
        class oi extends Xe {
          getDefault() {
            return [0, 1];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class ri extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
          }
        }
        class ni extends Xe {
          getDefault() {
            return this.gl.LESS;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
          }
        }
        class li extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
          }
        }
        class hi extends Xe {
          getDefault() {
            const t2 = this.gl;
            return [t2.ONE, t2.ZERO];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
          }
        }
        class ci extends Xe {
          getDefault() {
            return e.aO.transparent;
          }
          set(t2) {
            const e2 = this.current;
            (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
          }
        }
        class ui extends Xe {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
          }
        }
        class di extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
          }
        }
        class _i extends Xe {
          getDefault() {
            return this.gl.BACK;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class pi extends Xe {
          getDefault() {
            return this.gl.CCW;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
          }
        }
        class mi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
          }
        }
        class fi extends Xe {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t2) {
            (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
          }
        }
        class gi extends Xe {
          getDefault() {
            const t2 = this.gl;
            return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
          }
          set(t2) {
            const e2 = this.current;
            (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
          }
        }
        class vi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class xi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class yi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
          }
        }
        class bi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class wi extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            const e2 = this.gl;
            e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ti extends Xe {
          getDefault() {
            return null;
          }
          set(t2) {
            var e2;
            if (t2 === this.current && !this.dirty)
              return;
            const i2 = this.gl;
            $e(i2) ? i2.bindVertexArray(t2) : null === (e2 = i2.getExtension("OES_vertex_array_object")) || void 0 === e2 || e2.bindVertexArrayOES(t2), this.current = t2, this.dirty = false;
          }
        }
        class Ii extends Xe {
          getDefault() {
            return 4;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ei extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class Ci extends Xe {
          getDefault() {
            return false;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
          }
        }
        class Si extends Xe {
          constructor(t2, e2) {
            super(t2), this.context = t2, this.parent = e2;
          }
          getDefault() {
            return null;
          }
        }
        class Pi extends Si {
          setDirty() {
            this.dirty = true;
          }
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
          }
        }
        class Di extends Si {
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class zi extends Si {
          set(t2) {
            if (t2 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
          }
        }
        class Mi {
          constructor(t2, e2, i2, s2, a2) {
            this.context = t2, this.width = e2, this.height = i2;
            const o2 = t2.gl, r2 = this.framebuffer = o2.createFramebuffer();
            if (this.colorAttachment = new Pi(t2, r2), s2)
              this.depthAttachment = a2 ? new zi(t2, r2) : new Di(t2, r2);
            else if (a2)
              throw new Error("Stencil cannot be set without depth");
            if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE)
              throw new Error("Framebuffer is not complete");
          }
          destroy() {
            const t2 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
              const e3 = this.depthAttachment.get();
              e3 && t2.deleteRenderbuffer(e3);
            }
            t2.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ai {
          constructor(t2, e2, i2) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
          }
        }
        Ai.Replace = [1, 0], Ai.disabled = new Ai(Ai.Replace, e.aO.transparent, [false, false, false, false]), Ai.unblended = new Ai(Ai.Replace, e.aO.transparent, [true, true, true, true]), Ai.alphaBlended = new Ai([1, 771], e.aO.transparent, [true, true, true, true]);
        class Ri {
          constructor(t2) {
            var e2, i2;
            if (this.gl = t2, this.clearColor = new Ke(this), this.clearDepth = new Ye(this), this.clearStencil = new Je(this), this.colorMask = new Qe(this), this.depthMask = new ti(this), this.stencilMask = new ei(this), this.stencilFunc = new ii(this), this.stencilOp = new si(this), this.stencilTest = new ai(this), this.depthRange = new oi(this), this.depthTest = new ri(this), this.depthFunc = new ni(this), this.blend = new li(this), this.blendFunc = new hi(this), this.blendColor = new ci(this), this.blendEquation = new ui(this), this.cullFace = new di(this), this.cullFaceSide = new _i(this), this.frontFace = new pi(this), this.program = new mi(this), this.activeTexture = new fi(this), this.viewport = new gi(this), this.bindFramebuffer = new vi(this), this.bindRenderbuffer = new xi(this), this.bindTexture = new yi(this), this.bindVertexBuffer = new bi(this), this.bindElementBuffer = new wi(this), this.bindVertexArray = new Ti(this), this.pixelStoreUnpack = new Ii(this), this.pixelStoreUnpackPremultiplyAlpha = new Ei(this), this.pixelStoreUnpackFlipY = new Ci(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), $e(t2)) {
              this.HALF_FLOAT = t2.HALF_FLOAT;
              const s2 = t2.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (e2 = t2.RGBA16F) && void 0 !== e2 ? e2 : null == s2 ? void 0 : s2.RGBA16F_EXT, this.RGB16F = null !== (i2 = t2.RGB16F) && void 0 !== i2 ? i2 : null == s2 ? void 0 : s2.RGB16F_EXT, t2.getExtension("EXT_color_buffer_float");
            } else {
              t2.getExtension("EXT_color_buffer_half_float"), t2.getExtension("OES_texture_half_float_linear");
              const e3 = t2.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == e3 ? void 0 : e3.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t2, e2) {
            return new je(this, t2, e2);
          }
          createVertexBuffer(t2, e2, i2) {
            return new He(this, t2, e2, i2);
          }
          createRenderbuffer(t2, e2, i2) {
            const s2 = this.gl, a2 = s2.createRenderbuffer();
            return this.bindRenderbuffer.set(a2), s2.renderbufferStorage(s2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), a2;
          }
          createFramebuffer(t2, e2, i2, s2) {
            return new Mi(this, t2, e2, i2, s2);
          }
          clear({ color: t2, depth: e2, stencil: i2 }) {
            const s2 = this.gl;
            let a2 = 0;
            t2 && (a2 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), void 0 !== e2 && (a2 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), void 0 !== i2 && (a2 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), s2.clear(a2);
          }
          setCullFace(t2) {
            false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
          }
          setDepthMode(t2) {
            t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
          }
          setStencilMode(t2) {
            t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t2) {
            e.aD(t2.blendFunction, Ai.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
          }
          createVertexArray() {
            var t2;
            return $e(this.gl) ? this.gl.createVertexArray() : null === (t2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t2 ? void 0 : t2.createVertexArrayOES();
          }
          deleteVertexArray(t2) {
            var e2;
            return $e(this.gl) ? this.gl.deleteVertexArray(t2) : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.deleteVertexArrayOES(t2);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class Li {
          constructor(t2, e2, i2) {
            this.func = t2, this.mask = e2, this.range = i2;
          }
        }
        Li.ReadOnly = false, Li.ReadWrite = true, Li.disabled = new Li(519, Li.ReadOnly, [0, 1]);
        const ki = 7680;
        class Fi {
          constructor(t2, e2, i2, s2, a2, o2) {
            this.test = t2, this.ref = e2, this.mask = i2, this.fail = s2, this.depthFail = a2, this.pass = o2;
          }
        }
        Fi.disabled = new Fi({ func: 519, mask: 0 }, 0, 0, ki, ki, ki);
        class Bi {
          constructor(t2, e2, i2) {
            this.enable = t2, this.mode = e2, this.frontFace = i2;
          }
        }
        let Oi;
        function Ni(t2, i2, s2, a2, o2, r2, n2) {
          const l2 = t2.context, h2 = l2.gl, c2 = t2.useProgram("collisionBox"), u2 = [];
          let d2 = 0, _2 = 0;
          for (let p3 = 0; p3 < a2.length; p3++) {
            const m3 = a2[p3], f3 = i2.getTile(m3), g3 = f3.getBucket(s2);
            if (!g3)
              continue;
            let v3 = m3.posMatrix;
            0 === o2[0] && 0 === o2[1] || (v3 = t2.translatePosMatrix(m3.posMatrix, f3, o2, r2));
            const x3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
            if (y2.length > 0) {
              const i3 = e.F(), s3 = v3;
              e.aP(i3, g3.placementInvProjMatrix, t2.transform.glCoordMatrix), e.aP(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: _2, transform: s3, invTransform: i3, coord: m3 }), d2 += y2.length / 4, _2 = d2;
            }
            x3 && c2.draw(l2, h2.LINES, Li.disabled, Fi.disabled, t2.colorModeForRenderPass(), Bi.disabled, Ee(v3, t2.transform, f3), t2.style.map.terrain && t2.style.map.terrain.getTerrainData(m3), s2.id, x3.layoutVertexBuffer, x3.indexBuffer, x3.segments, null, t2.transform.zoom, null, null, x3.collisionVertexBuffer);
          }
          if (!n2 || !u2.length)
            return;
          const p2 = t2.useProgram("collisionCircle"), m2 = new e.aQ();
          m2.resize(4 * d2), m2._trim();
          let f2 = 0;
          for (const t3 of u2)
            for (let e2 = 0; e2 < t3.circleArray.length / 4; e2++) {
              const i3 = 4 * e2, s3 = t3.circleArray[i3 + 0], a3 = t3.circleArray[i3 + 1], o3 = t3.circleArray[i3 + 2], r3 = t3.circleArray[i3 + 3];
              m2.emplace(f2++, s3, a3, o3, r3, 0), m2.emplace(f2++, s3, a3, o3, r3, 1), m2.emplace(f2++, s3, a3, o3, r3, 2), m2.emplace(f2++, s3, a3, o3, r3, 3);
            }
          (!Oi || Oi.length < 2 * d2) && (Oi = function(t3) {
            const i3 = 2 * t3, s3 = new e.aS();
            s3.resize(i3), s3._trim();
            for (let t4 = 0; t4 < i3; t4++) {
              const e2 = 6 * t4;
              s3.uint16[e2 + 0] = 4 * t4 + 0, s3.uint16[e2 + 1] = 4 * t4 + 1, s3.uint16[e2 + 2] = 4 * t4 + 2, s3.uint16[e2 + 3] = 4 * t4 + 2, s3.uint16[e2 + 4] = 4 * t4 + 3, s3.uint16[e2 + 5] = 4 * t4 + 0;
            }
            return s3;
          }(d2));
          const g2 = l2.createIndexBuffer(Oi, true), v2 = l2.createVertexBuffer(m2, e.aR.members, true);
          for (const i3 of u2) {
            const a3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (x2 = t2.transform).cameraToCenterDistance, u_viewport_size: [x2.width, x2.height] };
            p2.draw(l2, h2.TRIANGLES, Li.disabled, Fi.disabled, t2.colorModeForRenderPass(), Bi.disabled, a3, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(i3.coord), s2.id, v2, g2, e.$.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, t2.transform.zoom, null, null, null);
          }
          var x2;
          v2.destroy(), g2.destroy();
        }
        Bi.disabled = new Bi(false, 1029, 2305), Bi.backCCW = new Bi(true, 1029, 2305);
        const Ui = e.an(new Float32Array(16));
        function Zi(t2, i2, s2, a2, o2, r2) {
          const { horizontalAlign: n2, verticalAlign: l2 } = e.at(t2);
          return new e.P((-(n2 - 0.5) * i2 / o2 + a2[0]) * r2, (-(l2 - 0.5) * s2 / o2 + a2[1]) * r2);
        }
        function Gi(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2) {
          const d2 = t2.text.placedSymbolArray, _2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {};
          _2.clear();
          for (let p3 = 0; p3 < d2.length; p3++) {
            const f2 = d2.get(p3), g2 = f2.hidden || !f2.crossTileID || t2.allowVerticalPlacement && !f2.placedOrientation ? null : a2[f2.crossTileID];
            if (g2) {
              const a3 = new e.P(f2.anchorX, f2.anchorY), d3 = gt(a3, s2 ? n2 : r2, u2), p4 = vt(o2.cameraToCenterDistance, d3.signedDistanceFromCamera);
              let v2 = e.ai(t2.textSizeData, h2, f2) * p4 / e.ao;
              s2 && (v2 *= t2.tilePixelRatio / l2);
              const { width: x2, height: y2, anchor: b2, textOffset: w2, textBoxScale: T2 } = g2, I2 = Zi(b2, x2, y2, w2, T2, v2), E2 = s2 ? gt(a3.add(I2), r2, u2).point : d3.point.add(i2 ? I2.rotate(-o2.angle) : I2), C2 = t2.allowVerticalPlacement && f2.placedOrientation === e.ah.vertical ? Math.PI / 2 : 0;
              for (let t3 = 0; t3 < f2.numGlyphs; t3++)
                e.aj(_2, E2, C2);
              c2 && f2.associatedIconIndex >= 0 && (m2[f2.associatedIconIndex] = { shiftedAnchor: E2, angle: C2 });
            } else
              zt(f2.numGlyphs, _2);
          }
          if (c2) {
            p2.clear();
            const i3 = t2.icon.placedSymbolArray;
            for (let t3 = 0; t3 < i3.length; t3++) {
              const s3 = i3.get(t3);
              if (s3.hidden)
                zt(s3.numGlyphs, p2);
              else {
                const i4 = m2[t3];
                if (i4)
                  for (let t4 = 0; t4 < s3.numGlyphs; t4++)
                    e.aj(p2, i4.shiftedAnchor, i4.angle);
                else
                  zt(s3.numGlyphs, p2);
              }
            }
            t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
          }
          t2.text.dynamicLayoutVertexBuffer.updateData(_2);
        }
        function qi(t2, e2, i2) {
          return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
        }
        function ji(t2, i2, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2) {
          const _2 = t2.context, p2 = _2.gl, m2 = t2.transform, f2 = "map" === l2, g2 = "map" === h2, v2 = "viewport" !== l2 && "point" !== s2.layout.get("symbol-placement"), x2 = f2 && !g2 && !v2, y2 = !s2.layout.get("symbol-sort-key").isConstant();
          let b2 = false;
          const w2 = t2.depthModeForSublayer(0, Li.ReadOnly), T2 = s2._unevaluatedLayout.hasValue("text-variable-anchor") || s2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I2 = [];
          for (const l3 of a2) {
            const a3 = i2.getTile(l3), h3 = a3.getBucket(s2);
            if (!h3)
              continue;
            const u3 = o2 ? h3.text : h3.icon;
            if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices)
              continue;
            const d3 = u3.programConfigurations.get(s2.id), _3 = o2 || h3.sdfIcons, w3 = o2 ? h3.textSizeData : h3.iconSizeData, E2 = g2 || 0 !== m2.pitch, C2 = t2.useProgram(qi(_3, o2, h3), d3), S2 = e.ag(w3, m2.zoom), P2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(l3);
            let D2, z2, M2, A2, R2 = [0, 0], L2 = null;
            if (o2)
              z2 = a3.glyphAtlasTexture, M2 = p2.LINEAR, D2 = a3.glyphAtlasTexture.size, h3.iconsInText && (R2 = a3.imageAtlasTexture.size, L2 = a3.imageAtlasTexture, A2 = E2 || t2.options.rotating || t2.options.zooming || "composite" === w3.kind || "camera" === w3.kind ? p2.LINEAR : p2.NEAREST);
            else {
              const e2 = 1 !== s2.layout.get("icon-size").constantOr(0) || h3.iconsNeedLinear;
              z2 = a3.imageAtlasTexture, M2 = _3 || t2.options.rotating || t2.options.zooming || e2 || E2 ? p2.LINEAR : p2.NEAREST, D2 = a3.imageAtlasTexture.size;
            }
            const k2 = Lt(a3, 1, t2.transform.zoom), F2 = mt(l3.posMatrix, g2, f2, t2.transform, k2), B2 = ft(l3.posMatrix, g2, f2, t2.transform, k2), O2 = T2 && h3.hasTextData(), N2 = "none" !== s2.layout.get("icon-text-fit") && O2 && h3.hasIconData();
            if (v2) {
              const e2 = t2.style.map.terrain ? (e3, i4) => t2.style.map.terrain.getElevation(l3, e3, i4) : null, i3 = "map" === s2.layout.get("text-rotation-alignment");
              yt(h3, l3.posMatrix, t2, o2, F2, B2, g2, c2, i3, e2);
            }
            const U2 = t2.translatePosMatrix(l3.posMatrix, a3, r2, n2), Z2 = v2 || o2 && T2 || N2 ? Ui : F2, G2 = t2.translatePosMatrix(B2, a3, r2, n2, true), q2 = _3 && 0 !== s2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let j2;
            j2 = _3 ? h3.iconsInText ? Ue(w3.kind, S2, x2, g2, t2, U2, Z2, G2, D2, R2) : Ne(w3.kind, S2, x2, g2, t2, U2, Z2, G2, o2, D2, true) : Oe(w3.kind, S2, x2, g2, t2, U2, Z2, G2, o2, D2);
            const V2 = { program: C2, buffers: u3, uniformValues: j2, atlasTexture: z2, atlasTextureIcon: L2, atlasInterpolation: M2, atlasInterpolationIcon: A2, isSDF: _3, hasHalo: q2 };
            if (y2 && h3.canOverlap) {
              b2 = true;
              const t3 = u3.segments.get();
              for (const i3 of t3)
                I2.push({ segments: new e.$([i3]), sortKey: i3.sortKey, state: V2, terrainData: P2 });
            } else
              I2.push({ segments: u3.segments, sortKey: 0, state: V2, terrainData: P2 });
          }
          b2 && I2.sort((t3, e2) => t3.sortKey - e2.sortKey);
          for (const e2 of I2) {
            const i3 = e2.state;
            if (_2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
              const a3 = i3.uniformValues;
              i3.hasHalo && (a3.u_is_halo = 1, Vi(i3.buffers, e2.segments, s2, t2, i3.program, w2, u2, d2, a3, e2.terrainData)), a3.u_is_halo = 0;
            }
            Vi(i3.buffers, e2.segments, s2, t2, i3.program, w2, u2, d2, i3.uniformValues, e2.terrainData);
          }
        }
        function Vi(t2, e2, i2, s2, a2, o2, r2, n2, l2, h2) {
          const c2 = s2.context;
          a2.draw(c2, c2.gl.TRIANGLES, o2, r2, n2, Bi.disabled, l2, h2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, s2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
        }
        function Hi(t2, e2, i2, s2, a2) {
          if (!i2 || !s2 || !s2.imageAtlas)
            return;
          const o2 = s2.imageAtlas.patternPositions;
          let r2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
          if (!r2 && n2 && (r2 = n2), !n2 && r2 && (n2 = r2), !r2 || !n2) {
            const t3 = a2.getPaintProperty(e2);
            r2 = o2[t3], n2 = o2[t3];
          }
          r2 && n2 && t2.setConstantPatternPositions(r2, n2);
        }
        function Wi(t2, e2, i2, s2, a2, o2, r2) {
          const n2 = t2.context.gl, l2 = "fill-pattern", h2 = i2.paint.get(l2), c2 = h2 && h2.constantOr(1), u2 = i2.getCrossfadeParameters();
          let d2, _2, p2, m2, f2;
          r2 ? (_2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = c2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
          const g2 = h2.constantOr(null);
          for (const h3 of s2) {
            const s3 = e2.getTile(h3);
            if (c2 && !s3.patternsLoaded())
              continue;
            const v2 = s3.getBucket(i2);
            if (!v2)
              continue;
            const x2 = v2.programConfigurations.get(i2.id), y2 = t2.useProgram(_2, x2), b2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(h3);
            c2 && (t2.context.activeTexture.set(n2.TEXTURE0), s3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(u2)), Hi(x2, l2, g2, s3, i2);
            const w2 = b2 ? h3 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : h3.posMatrix, s3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
            if (r2) {
              m2 = v2.indexBuffer2, f2 = v2.segments2;
              const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
              p2 = "fillOutlinePattern" === _2 && c2 ? Te(T2, t2, u2, s3, e3) : we(T2, e3);
            } else
              m2 = v2.indexBuffer, f2 = v2.segments, p2 = c2 ? be(T2, t2, u2, s3) : ye(T2);
            y2.draw(t2.context, d2, a2, t2.stencilModeForClipping(h3), o2, Bi.disabled, p2, b2, i2.id, v2.layoutVertexBuffer, m2, f2, i2.paint, t2.transform.zoom, x2);
          }
        }
        function $i(t2, e2, i2, s2, a2, o2, r2) {
          const n2 = t2.context, l2 = n2.gl, h2 = "fill-extrusion-pattern", c2 = i2.paint.get(h2), u2 = c2.constantOr(1), d2 = i2.getCrossfadeParameters(), _2 = i2.paint.get("fill-extrusion-opacity"), p2 = c2.constantOr(null);
          for (const c3 of s2) {
            const s3 = e2.getTile(c3), m2 = s3.getBucket(i2);
            if (!m2)
              continue;
            const f2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(c3), g2 = m2.programConfigurations.get(i2.id), v2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", g2);
            u2 && (t2.context.activeTexture.set(l2.TEXTURE0), s3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), g2.updatePaintBuffers(d2)), Hi(g2, h2, p2, s3, i2);
            const x2 = t2.translatePosMatrix(c3.posMatrix, s3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y2 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? xe(x2, t2, y2, _2, c3, d2, s3) : ve(x2, t2, y2, _2);
            v2.draw(n2, n2.gl.TRIANGLES, a2, o2, r2, Bi.backCCW, b2, f2, i2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i2.paint, t2.transform.zoom, g2, t2.style.map.terrain && m2.centroidVertexBuffer);
          }
        }
        function Xi(t2, e2, i2, s2, a2, o2, r2) {
          const n2 = t2.context, l2 = n2.gl, h2 = i2.fbo;
          if (!h2)
            return;
          const c2 = t2.useProgram("hillshade"), u2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(e2);
          n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, h2.colorAttachment.get()), c2.draw(n2, l2.TRIANGLES, a2, o2, r2, Bi.disabled, ((t3, e3, i3, s3) => {
            const a3 = i3.paint.get("hillshade-shadow-color"), o3 = i3.paint.get("hillshade-highlight-color"), r3 = i3.paint.get("hillshade-accent-color");
            let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i3.paint.get("hillshade-illumination-anchor") && (n3 -= t3.transform.angle);
            const l3 = !t3.options.moving;
            return { u_matrix: s3 ? s3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: De(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: a3, u_highlight: o3, u_accent: r3 };
          })(t2, i2, s2, u2 ? e2 : null), u2, s2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
        }
        function Ki(t2, i2, s2, a2, o2, r2) {
          const n2 = t2.context, l2 = n2.gl, h2 = i2.dem;
          if (h2 && h2.data) {
            const c2 = h2.dim, u2 = h2.stride, d2 = h2.getPixels();
            if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(u2), i2.demTexture) {
              const t3 = i2.demTexture;
              t3.update(d2, { premultiply: false }), t3.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            } else
              i2.demTexture = new b(n2, d2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            n2.activeTexture.set(l2.TEXTURE0);
            let _2 = i2.fbo;
            if (!_2) {
              const t3 = new b(n2, { width: c2, height: c2, data: null }, l2.RGBA);
              t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(c2, c2, true, false), _2.colorAttachment.set(t3.texture);
            }
            n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, c2, c2]), t2.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, a2, o2, r2, Bi.disabled, ((t3, i3) => {
              const s3 = i3.stride, a3 = e.F();
              return e.aN(a3, 0, e.W, -e.W, 0, 0, 1), e.H(a3, a3, [0, -e.W, 0]), { u_matrix: a3, u_image: 1, u_dimension: [s3, s3], u_zoom: t3.overscaledZ, u_unpack: i3.getUnpackVector() };
            })(i2.tileID, h2), null, s2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
          }
        }
        function Yi(t2, i2, s2, a2, r2, n2) {
          const l2 = a2.paint.get("raster-fade-duration");
          if (!n2 && l2 > 0) {
            const a3 = o.now(), n3 = (a3 - t2.timeAdded) / l2, h2 = i2 ? (a3 - i2.timeAdded) / l2 : -1, c2 = s2.getSource(), u2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u2) > Math.abs(t2.tileID.overscaledZ - u2), _2 = d2 && t2.refreshedUponExpiration ? 1 : e.ac(d2 ? n3 : 1 - h2, 0, 1);
            return t2.refreshedUponExpiration && n3 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Ji = new e.aO(1, 0, 0, 1), Qi = new e.aO(0, 1, 0, 1), ts = new e.aO(0, 0, 1, 1), es = new e.aO(1, 0, 1, 1), is = new e.aO(0, 1, 1, 1);
        function ss(t2, e2, i2, s2) {
          os(t2, 0, e2 + i2 / 2, t2.transform.width, i2, s2);
        }
        function as(t2, e2, i2, s2) {
          os(t2, e2 - i2 / 2, 0, i2, t2.transform.height, s2);
        }
        function os(t2, e2, i2, s2, a2, o2) {
          const r2 = t2.context, n2 = r2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, s2 * t2.pixelRatio, a2 * t2.pixelRatio), r2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function rs(t2, i2, s2) {
          const a2 = t2.context, o2 = a2.gl, r2 = s2.posMatrix, n2 = t2.useProgram("debug"), l2 = Li.disabled, h2 = Fi.disabled, c2 = t2.colorModeForRenderPass(), u2 = "$debug", d2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(s2);
          a2.activeTexture.set(o2.TEXTURE0);
          const _2 = i2.getTileByID(s2.key).latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(s2).tileSize, f2 = 512 / Math.min(m2, 512) * (s2.overscaledZ / t2.transform.zoom) * 0.5;
          let g2 = s2.canonical.toString();
          s2.overscaledZ !== s2.canonical.z && (g2 += ` => ${s2.overscaledZ}`), function(t3, e2) {
            t3.initDebugOverlayCanvas();
            const i3 = t3.debugOverlayCanvas, s3 = t3.context.gl, a3 = t3.debugOverlayCanvas.getContext("2d");
            a3.clearRect(0, 0, i3.width, i3.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e2, 5, 5), a3.strokeText(e2, 5, 5), t3.debugOverlayTexture.update(i3), t3.debugOverlayTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          }(t2, `${g2} ${p2}kB`), n2.draw(a2, o2.TRIANGLES, l2, h2, Ai.alphaBlended, Bi.disabled, Ce(r2, e.aO.transparent, f2), null, u2, t2.debugBuffer, t2.quadTriangleIndexBuffer, t2.debugSegments), n2.draw(a2, o2.LINE_STRIP, l2, h2, c2, Bi.disabled, Ce(r2, e.aO.red), d2, u2, t2.debugBuffer, t2.tileBorderIndexBuffer, t2.debugSegments);
        }
        function ns(t2, e2, i2) {
          const s2 = t2.context, a2 = s2.gl, o2 = t2.colorModeForRenderPass(), r2 = new Li(a2.LEQUAL, Li.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e2.getTerrainMesh();
          s2.bindFramebuffer.set(null), s2.viewport.set([0, 0, t2.width, t2.height]);
          for (const h2 of i2) {
            const i3 = t2.renderToTexture.getTexture(h2), c2 = e2.getTerrainData(h2.tileID);
            s2.activeTexture.set(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, i3.texture);
            const u2 = { u_matrix: t2.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e2.getMeshFrameDelta(t2.transform.zoom) };
            n2.draw(s2, a2.TRIANGLES, r2, Fi.disabled, o2, Bi.backCCW, u2, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
          }
        }
        class ls {
          constructor(t2, i2) {
            this.context = new Ri(t2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: e.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ht.maxUnderzooming + ht.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new re();
          }
          resize(t2, e2, i2) {
            if (this.width = Math.floor(t2 * i2), this.height = Math.floor(e2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const t3 of this.style._order)
                this.style._layers[t3].resize();
          }
          setup() {
            const t2 = this.context, i2 = new e.aV();
            i2.emplaceBack(0, 0), i2.emplaceBack(e.W, 0), i2.emplaceBack(0, e.W), i2.emplaceBack(e.W, e.W), this.tileExtentBuffer = t2.createVertexBuffer(i2, ce.members), this.tileExtentSegments = e.$.simpleSegment(0, 0, 4, 2);
            const s2 = new e.aV();
            s2.emplaceBack(0, 0), s2.emplaceBack(e.W, 0), s2.emplaceBack(0, e.W), s2.emplaceBack(e.W, e.W), this.debugBuffer = t2.createVertexBuffer(s2, ce.members), this.debugSegments = e.$.simpleSegment(0, 0, 4, 5);
            const a2 = new e.Z();
            a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(e.W, 0, e.W, 0), a2.emplaceBack(0, e.W, 0, e.W), a2.emplaceBack(e.W, e.W, e.W, e.W), this.rasterBoundsBuffer = t2.createVertexBuffer(a2, K.members), this.rasterBoundsSegments = e.$.simpleSegment(0, 0, 4, 2);
            const o2 = new e.aV();
            o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(o2, ce.members), this.viewportSegments = e.$.simpleSegment(0, 0, 4, 2);
            const r2 = new e.aW();
            r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = t2.createIndexBuffer(r2);
            const n2 = new e.aX();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
            const l2 = this.context.gl;
            this.stencilClearMode = new Fi({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
          }
          clearStencil() {
            const t2 = this.context, i2 = t2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s2 = e.F();
            e.aN(s2, 0, this.width, this.height, 0, 0, 1), e.J(s2, s2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, Li.disabled, this.stencilClearMode, Ai.disabled, Bi.disabled, Se(s2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t2, e2) {
            if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length)
              return;
            this.currentStencilSource = t2.source;
            const i2 = this.context, s2 = i2.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Ai.disabled), i2.setDepthMode(Li.disabled);
            const a2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t3 of e2) {
              const e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t3);
              a2.draw(i2, s2.TRIANGLES, Li.disabled, new Fi({ func: s2.ALWAYS, mask: 0 }, e3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), Ai.disabled, Bi.disabled, Se(t3.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t2 = this.nextStencilID++, e2 = this.context.gl;
            return new Fi({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilModeForClipping(t2) {
            const e2 = this.context.gl;
            return new Fi({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilConfigForOverlap(t2) {
            const e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), s2 = i2[i2.length - 1].overscaledZ, a2 = i2[0].overscaledZ - s2 + 1;
            if (a2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
              const t3 = {};
              for (let i3 = 0; i3 < a2; i3++)
                t3[i3 + s2] = new Fi({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
              return this.nextStencilID += a2, [t3, i2];
            }
            return [{ [s2]: Fi.disabled }, i2];
          }
          colorModeForRenderPass() {
            const t2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i2 = 1 / 8;
              return new Ai([t2.CONSTANT_COLOR, t2.ONE], new e.aO(i2, i2, i2, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Ai.unblended : Ai.alphaBlended;
          }
          depthModeForSublayer(t2, e2, i2) {
            if (!this.opaquePassEnabledForLayer())
              return Li.disabled;
            const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new Li(i2 || this.context.gl.LEQUAL, e2, [s2, s2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t2, i2) {
            this.style = t2, this.options = i2, this.lineAtlas = t2.lineAtlas, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(o.now()), this.imageManager.beginFrame();
            const s2 = this.style._order, a2 = this.style.sourceCaches, r2 = {}, n2 = {}, l2 = {};
            for (const t3 in a2) {
              const e2 = a2[t3];
              e2.used && e2.prepare(this.context), r2[t3] = e2.getVisibleCoordinates(), n2[t3] = r2[t3].slice().reverse(), l2[t3] = e2.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t3 = 0; t3 < s2.length; t3++)
              if (this.style._layers[s2[t3]].is3D()) {
                this.opaquePassCutoff = t3;
                break;
              }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const t3 of s2) {
              const e2 = this.style._layers[t3];
              if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom))
                continue;
              const i3 = n2[e2.source];
              ("custom" === e2.type || i3.length) && this.renderLayer(this, a2[e2.source], e2, i3);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? e.aO.black : e.aO.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = s2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const t3 = this.style._layers[s2[this.currentLayer]], e2 = a2[t3.source], i3 = r2[t3.source];
                this._renderTileClippingMasks(t3, i3), this.renderLayer(this, e2, t3, i3);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s2.length; this.currentLayer++) {
              const t3 = this.style._layers[s2[this.currentLayer]], e2 = a2[t3.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(t3))
                continue;
              const i3 = ("symbol" === t3.type ? l2 : n2)[t3.source];
              this._renderTileClippingMasks(t3, r2[t3.source]), this.renderLayer(this, e2, t3, i3);
            }
            if (this.options.showTileBoundaries) {
              const t3 = function(t4, e2) {
                let i3 = null;
                const s3 = Object.values(t4._layers).flatMap((i4) => i4.source && !i4.isHidden(e2) ? [t4.sourceCaches[i4.source]] : []), a3 = s3.filter((t5) => "vector" === t5.getSource().type), o2 = s3.filter((t5) => "vector" !== t5.getSource().type), r3 = (t5) => {
                  (!i3 || i3.getSource().maxzoom < t5.getSource().maxzoom) && (i3 = t5);
                };
                return a3.forEach((t5) => r3(t5)), i3 || o2.forEach((t5) => r3(t5)), i3;
              }(this.style, this.transform.zoom);
              t3 && function(t4, e2, i3) {
                for (let s3 = 0; s3 < i3.length; s3++)
                  rs(t4, e2, i3[s3]);
              }(this, t3, t3.getVisibleCoordinates());
            }
            this.options.showPadding && function(t3) {
              const e2 = t3.transform.padding;
              ss(t3, t3.transform.height - (e2.top || 0), 3, Ji), ss(t3, e2.bottom || 0, 3, Qi), as(t3, e2.left || 0, 3, ts), as(t3, t3.transform.width - (e2.right || 0), 3, es);
              const i3 = t3.transform.centerPoint;
              !function(t4, e3, i4, s3) {
                os(t4, e3 - 1, i4 - 10, 2, 20, s3), os(t4, e3 - 10, i4 - 1, 20, 2, s3);
              }(t3, i3.x, t3.transform.height - i3.y, is);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t2) {
            if (!this.style || !this.style.map || !this.style.map.terrain)
              return;
            const i2 = this.terrainFacilitator.matrix, s2 = this.transform.projMatrix;
            let a2 = this.terrainFacilitator.dirty;
            a2 || (a2 = t2 ? !e.aY(i2, s2) : !e.aZ(i2, s2)), a2 || (a2 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), a2 && (e.a_(i2, s2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(t3, i3) {
              const s3 = t3.context, a3 = s3.gl, o2 = Ai.unblended, r2 = new Li(a3.LEQUAL, Li.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.sourceCache.getRenderableTiles(), h2 = t3.useProgram("terrainDepth");
              s3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), s3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), s3.clear({ color: e.aO.transparent, depth: 1 });
              for (const e2 of l2) {
                const l3 = i3.getTerrainData(e2.tileID), c2 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
                h2.draw(s3, a3.TRIANGLES, r2, Fi.disabled, o2, Bi.backCCW, c2, l3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments);
              }
              s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, t3.width, t3.height]);
            }(this, this.style.map.terrain), function(t3, i3) {
              const s3 = t3.context, a3 = s3.gl, o2 = Ai.unblended, r2 = new Li(a3.LEQUAL, Li.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.getCoordsTexture(), h2 = i3.sourceCache.getRenderableTiles(), c2 = t3.useProgram("terrainCoords");
              s3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), s3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), s3.clear({ color: e.aO.transparent, depth: 1 }), i3.coordsIndex = [];
              for (const e2 of h2) {
                const h3 = i3.getTerrainData(e2.tileID);
                s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, l2.texture);
                const u2 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
                c2.draw(s3, a3.TRIANGLES, r2, Fi.disabled, o2, Bi.backCCW, u2, h3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments), i3.coordsIndex.push(e2.tileID.key);
              }
              s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, t3.width, t3.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(t2, i2, s2, a2) {
            if (!s2.isHidden(this.transform.zoom) && ("background" === s2.type || "custom" === s2.type || (a2 || []).length))
              switch (this.id = s2.id, s2.type) {
                case "symbol":
                  !function(t3, i3, s3, a3, o2) {
                    if ("translucent" !== t3.renderPass)
                      return;
                    const r2 = Fi.disabled, n2 = t3.colorModeForRenderPass();
                    (s3._unevaluatedLayout.hasValue("text-variable-anchor") || s3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(t4, i4, s4, a4, o3, r3, n3) {
                      const l2 = i4.transform, h2 = "map" === o3, c2 = "map" === r3;
                      for (const o4 of t4) {
                        const t5 = a4.getTile(o4), r4 = t5.getBucket(s4);
                        if (!r4 || !r4.text || !r4.text.segments.get().length)
                          continue;
                        const u2 = e.ag(r4.textSizeData, l2.zoom), d2 = Lt(t5, 1, i4.transform.zoom), _2 = mt(o4.posMatrix, c2, h2, i4.transform, d2), p2 = "none" !== s4.layout.get("icon-text-fit") && r4.hasIconData();
                        if (u2) {
                          const e2 = Math.pow(2, l2.zoom - t5.tileID.overscaledZ);
                          Gi(r4, h2, c2, n3, l2, _2, o4.posMatrix, e2, u2, p2, i4.style.map.terrain ? (t6, e3) => i4.style.map.terrain.getElevation(o4, t6, e3) : null);
                        }
                      }
                    }(a3, t3, s3, i3, s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), o2), 0 !== s3.paint.get("icon-opacity").constantOr(1) && ji(t3, i3, s3, a3, false, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), s3.layout.get("icon-rotation-alignment"), s3.layout.get("icon-pitch-alignment"), s3.layout.get("icon-keep-upright"), r2, n2), 0 !== s3.paint.get("text-opacity").constantOr(1) && ji(t3, i3, s3, a3, true, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), s3.layout.get("text-keep-upright"), r2, n2), i3.map.showCollisionBoxes && (Ni(t3, i3, s3, a3, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), true), Ni(t3, i3, s3, a3, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), false));
                  }(t2, i2, s2, a2, this.style.placement.variableOffsets);
                  break;
                case "circle":
                  !function(t3, i3, s3, a3) {
                    if ("translucent" !== t3.renderPass)
                      return;
                    const o2 = s3.paint.get("circle-opacity"), r2 = s3.paint.get("circle-stroke-width"), n2 = s3.paint.get("circle-stroke-opacity"), l2 = !s3.layout.get("circle-sort-key").isConstant();
                    if (0 === o2.constantOr(1) && (0 === r2.constantOr(1) || 0 === n2.constantOr(1)))
                      return;
                    const h2 = t3.context, c2 = h2.gl, u2 = t3.depthModeForSublayer(0, Li.ReadOnly), d2 = Fi.disabled, _2 = t3.colorModeForRenderPass(), p2 = [];
                    for (let o3 = 0; o3 < a3.length; o3++) {
                      const r3 = a3[o3], n3 = i3.getTile(r3), h3 = n3.getBucket(s3);
                      if (!h3)
                        continue;
                      const c3 = h3.programConfigurations.get(s3.id), u3 = t3.useProgram("circle", c3), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(r3), f2 = { programConfiguration: c3, program: u3, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: Ie(t3, r3, n3, s3), terrainData: m2 };
                      if (l2) {
                        const t4 = h3.segments.get();
                        for (const i4 of t4)
                          p2.push({ segments: new e.$([i4]), sortKey: i4.sortKey, state: f2 });
                      } else
                        p2.push({ segments: h3.segments, sortKey: 0, state: f2 });
                    }
                    l2 && p2.sort((t4, e2) => t4.sortKey - e2.sortKey);
                    for (const e2 of p2) {
                      const { programConfiguration: i4, program: a4, layoutVertexBuffer: o3, indexBuffer: r3, uniformValues: n3, terrainData: l3 } = e2.state;
                      a4.draw(h2, c2.TRIANGLES, u2, d2, _2, Bi.disabled, n3, l3, s3.id, o3, r3, e2.segments, s3.paint, t3.transform.zoom, i4);
                    }
                  }(t2, i2, s2, a2);
                  break;
                case "heatmap":
                  !function(t3, i3, s3, a3) {
                    if (0 !== s3.paint.get("heatmap-opacity"))
                      if ("offscreen" === t3.renderPass) {
                        const o2 = t3.context, r2 = o2.gl, n2 = Fi.disabled, l2 = new Ai([r2.ONE, r2.ONE], e.aO.transparent, [true, true, true, true]);
                        !function(t4, e2, i4) {
                          const s4 = t4.gl;
                          t4.activeTexture.set(s4.TEXTURE1), t4.viewport.set([0, 0, e2.width / 4, e2.height / 4]);
                          let a4 = i4.heatmapFbo;
                          if (a4)
                            s4.bindTexture(s4.TEXTURE_2D, a4.colorAttachment.get()), t4.bindFramebuffer.set(a4.framebuffer);
                          else {
                            const o3 = s4.createTexture();
                            s4.bindTexture(s4.TEXTURE_2D, o3), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_S, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_T, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MIN_FILTER, s4.LINEAR), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MAG_FILTER, s4.LINEAR), a4 = i4.heatmapFbo = t4.createFramebuffer(e2.width / 4, e2.height / 4, false, false), function(t5, e3, i5, s5) {
                              var a5, o4;
                              const r3 = t5.gl, n3 = null !== (a5 = t5.HALF_FLOAT) && void 0 !== a5 ? a5 : r3.UNSIGNED_BYTE, l3 = null !== (o4 = t5.RGBA16F) && void 0 !== o4 ? o4 : r3.RGBA;
                              r3.texImage2D(r3.TEXTURE_2D, 0, l3, e3.width / 4, e3.height / 4, 0, r3.RGBA, n3, null), s5.colorAttachment.set(i5);
                            }(t4, e2, o3, a4);
                          }
                        }(o2, t3, s3), o2.clear({ color: e.aO.transparent });
                        for (let e2 = 0; e2 < a3.length; e2++) {
                          const h2 = a3[e2];
                          if (i3.hasRenderableParent(h2))
                            continue;
                          const c2 = i3.getTile(h2), u2 = c2.getBucket(s3);
                          if (!u2)
                            continue;
                          const d2 = u2.programConfigurations.get(s3.id), _2 = t3.useProgram("heatmap", d2), { zoom: p2 } = t3.transform;
                          _2.draw(o2, r2.TRIANGLES, Li.disabled, n2, l2, Bi.disabled, Pe(h2.posMatrix, c2, p2, s3.paint.get("heatmap-intensity")), null, s3.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, s3.paint, t3.transform.zoom, d2);
                        }
                        o2.viewport.set([0, 0, t3.width, t3.height]);
                      } else
                        "translucent" === t3.renderPass && (t3.context.setColorMode(t3.colorModeForRenderPass()), function(t4, i4) {
                          const s4 = t4.context, a4 = s4.gl, o2 = i4.heatmapFbo;
                          if (!o2)
                            return;
                          s4.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, o2.colorAttachment.get()), s4.activeTexture.set(a4.TEXTURE1);
                          let r2 = i4.colorRampTexture;
                          r2 || (r2 = i4.colorRampTexture = new b(s4, i4.colorRamp, a4.RGBA)), r2.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(s4, a4.TRIANGLES, Li.disabled, Fi.disabled, t4.colorModeForRenderPass(), Bi.disabled, ((t5, i5, s5, a5) => {
                            const o3 = e.F();
                            e.aN(o3, 0, t5.width, t5.height, 0, 0, 1);
                            const r3 = t5.context.gl;
                            return { u_matrix: o3, u_world: [r3.drawingBufferWidth, r3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i5.paint.get("heatmap-opacity") };
                          })(t4, i4), null, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom);
                        }(t3, s3));
                  }(t2, i2, s2, a2);
                  break;
                case "line":
                  !function(t3, i3, s3, a3) {
                    if ("translucent" !== t3.renderPass)
                      return;
                    const o2 = s3.paint.get("line-opacity"), r2 = s3.paint.get("line-width");
                    if (0 === o2.constantOr(1) || 0 === r2.constantOr(1))
                      return;
                    const n2 = t3.depthModeForSublayer(0, Li.ReadOnly), l2 = t3.colorModeForRenderPass(), h2 = s3.paint.get("line-dasharray"), c2 = s3.paint.get("line-pattern"), u2 = c2.constantOr(1), d2 = s3.paint.get("line-gradient"), _2 = s3.getCrossfadeParameters(), p2 = u2 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = t3.context, f2 = m2.gl;
                    let g2 = true;
                    for (const o3 of a3) {
                      const a4 = i3.getTile(o3);
                      if (u2 && !a4.patternsLoaded())
                        continue;
                      const r3 = a4.getBucket(s3);
                      if (!r3)
                        continue;
                      const v2 = r3.programConfigurations.get(s3.id), x2 = t3.context.program.get(), y2 = t3.useProgram(p2, v2), w2 = g2 || y2.program !== x2, T2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(o3), I2 = c2.constantOr(null);
                      if (I2 && a4.imageAtlas) {
                        const t4 = a4.imageAtlas, e2 = t4.patternPositions[I2.to.toString()], i4 = t4.patternPositions[I2.from.toString()];
                        e2 && i4 && v2.setConstantPatternPositions(e2, i4);
                      }
                      const E2 = T2 ? o3 : null, C2 = u2 ? Ae(t3, a4, s3, _2, E2) : h2 ? Re(t3, a4, s3, h2, _2, E2) : d2 ? Me(t3, a4, s3, r3.lineClipsArray.length, E2) : ze(t3, a4, s3, E2);
                      if (u2)
                        m2.activeTexture.set(f2.TEXTURE0), a4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
                      else if (h2 && (w2 || t3.lineAtlas.dirty))
                        m2.activeTexture.set(f2.TEXTURE0), t3.lineAtlas.bind(m2);
                      else if (d2) {
                        const a5 = r3.gradients[s3.id];
                        let n3 = a5.texture;
                        if (s3.gradientVersion !== a5.version) {
                          let l3 = 256;
                          if (s3.stepInterpolant) {
                            const s4 = i3.getSource().maxzoom, a6 = o3.canonical.z === s4 ? Math.ceil(1 << t3.transform.maxZoom - o3.canonical.z) : 1;
                            l3 = e.ac(e.aT(r3.maxLineLength / e.W * 1024 * a6), 256, m2.maxTextureSize);
                          }
                          a5.gradient = e.aU({ expression: s3.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: a5.gradient || void 0, clips: r3.lineClipsArray }), a5.texture ? a5.texture.update(a5.gradient) : a5.texture = new b(m2, a5.gradient, f2.RGBA), a5.version = s3.gradientVersion, n3 = a5.texture;
                        }
                        m2.activeTexture.set(f2.TEXTURE0), n3.bind(s3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                      }
                      y2.draw(m2, f2.TRIANGLES, n2, t3.stencilModeForClipping(o3), l2, Bi.disabled, C2, T2, s3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, s3.paint, t3.transform.zoom, v2, r3.layoutVertexBuffer2), g2 = false;
                    }
                  }(t2, i2, s2, a2);
                  break;
                case "fill":
                  !function(t3, i3, s3, a3) {
                    const o2 = s3.paint.get("fill-color"), r2 = s3.paint.get("fill-opacity");
                    if (0 === r2.constantOr(1))
                      return;
                    const n2 = t3.colorModeForRenderPass(), l2 = s3.paint.get("fill-pattern"), h2 = t3.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === o2.constantOr(e.aO.transparent).a && 1 === r2.constantOr(0) ? "opaque" : "translucent";
                    if (t3.renderPass === h2) {
                      const e2 = t3.depthModeForSublayer(1, "opaque" === t3.renderPass ? Li.ReadWrite : Li.ReadOnly);
                      Wi(t3, i3, s3, a3, e2, n2, false);
                    }
                    if ("translucent" === t3.renderPass && s3.paint.get("fill-antialias")) {
                      const e2 = t3.depthModeForSublayer(s3.getPaintProperty("fill-outline-color") ? 2 : 0, Li.ReadOnly);
                      Wi(t3, i3, s3, a3, e2, n2, true);
                    }
                  }(t2, i2, s2, a2);
                  break;
                case "fill-extrusion":
                  !function(t3, e2, i3, s3) {
                    const a3 = i3.paint.get("fill-extrusion-opacity");
                    if (0 !== a3 && "translucent" === t3.renderPass) {
                      const o2 = new Li(t3.context.gl.LEQUAL, Li.ReadWrite, t3.depthRangeFor3D);
                      if (1 !== a3 || i3.paint.get("fill-extrusion-pattern").constantOr(1))
                        $i(t3, e2, i3, s3, o2, Fi.disabled, Ai.disabled), $i(t3, e2, i3, s3, o2, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                      else {
                        const a4 = t3.colorModeForRenderPass();
                        $i(t3, e2, i3, s3, o2, Fi.disabled, a4);
                      }
                    }
                  }(t2, i2, s2, a2);
                  break;
                case "hillshade":
                  !function(t3, e2, i3, s3) {
                    if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass)
                      return;
                    const a3 = t3.context, o2 = t3.depthModeForSublayer(0, Li.ReadOnly), r2 = t3.colorModeForRenderPass(), [n2, l2] = "translucent" === t3.renderPass ? t3.stencilConfigForOverlap(s3) : [{}, s3];
                    for (const s4 of l2) {
                      const a4 = e2.getTile(s4);
                      void 0 !== a4.needsHillshadePrepare && a4.needsHillshadePrepare && "offscreen" === t3.renderPass ? Ki(t3, a4, i3, o2, Fi.disabled, r2) : "translucent" === t3.renderPass && Xi(t3, s4, a4, i3, o2, n2[s4.overscaledZ], r2);
                    }
                    a3.viewport.set([0, 0, t3.width, t3.height]);
                  }(t2, i2, s2, a2);
                  break;
                case "raster":
                  !function(t3, e2, i3, s3) {
                    if ("translucent" !== t3.renderPass)
                      return;
                    if (0 === i3.paint.get("raster-opacity"))
                      return;
                    if (!s3.length)
                      return;
                    const a3 = t3.context, o2 = a3.gl, r2 = e2.getSource(), n2 = t3.useProgram("raster"), l2 = t3.colorModeForRenderPass(), [h2, c2] = r2 instanceof Y ? [{}, s3] : t3.stencilConfigForOverlap(s3), u2 = c2[c2.length - 1].overscaledZ, d2 = !t3.options.moving;
                    for (const s4 of c2) {
                      const c3 = t3.depthModeForSublayer(s4.overscaledZ - u2, 1 === i3.paint.get("raster-opacity") ? Li.ReadWrite : Li.ReadOnly, o2.LESS), _2 = e2.getTile(s4);
                      _2.registerFadeDuration(i3.paint.get("raster-fade-duration"));
                      const p2 = e2.findLoadedParent(s4, 0), m2 = Yi(_2, p2, e2, i3, t3.transform, t3.style.map.terrain);
                      let f2, g2;
                      const v2 = "nearest" === i3.paint.get("raster-resampling") ? o2.NEAREST : o2.LINEAR;
                      a3.activeTexture.set(o2.TEXTURE0), _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), a3.activeTexture.set(o2.TEXTURE1), p2 ? (p2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, p2.tileID.overscaledZ - _2.tileID.overscaledZ), g2 = [_2.tileID.canonical.x * f2 % 1, _2.tileID.canonical.y * f2 % 1]) : _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST);
                      const x2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(s4), y2 = x2 ? s4 : null, b2 = y2 ? y2.posMatrix : t3.transform.calculatePosMatrix(s4.toUnwrapped(), d2), w2 = Fe(b2, g2 || [0, 0], f2 || 1, m2, i3);
                      r2 instanceof Y ? n2.draw(a3, o2.TRIANGLES, c3, Fi.disabled, l2, Bi.disabled, w2, x2, i3.id, r2.boundsBuffer, t3.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(a3, o2.TRIANGLES, c3, h2[s4.overscaledZ], l2, Bi.disabled, w2, x2, i3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                    }
                  }(t2, i2, s2, a2);
                  break;
                case "background":
                  !function(t3, e2, i3, s3) {
                    const a3 = i3.paint.get("background-color"), o2 = i3.paint.get("background-opacity");
                    if (0 === o2)
                      return;
                    const r2 = t3.context, n2 = r2.gl, l2 = t3.transform, h2 = l2.tileSize, c2 = i3.paint.get("background-pattern");
                    if (t3.isPatternMissing(c2))
                      return;
                    const u2 = !c2 && 1 === a3.a && 1 === o2 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (t3.renderPass !== u2)
                      return;
                    const d2 = Fi.disabled, _2 = t3.depthModeForSublayer(0, "opaque" === u2 ? Li.ReadWrite : Li.ReadOnly), p2 = t3.colorModeForRenderPass(), m2 = t3.useProgram(c2 ? "backgroundPattern" : "background"), f2 = s3 || l2.coveringTiles({ tileSize: h2, terrain: t3.style.map.terrain });
                    c2 && (r2.activeTexture.set(n2.TEXTURE0), t3.imageManager.bind(t3.context));
                    const g2 = i3.getCrossfadeParameters();
                    for (const e3 of f2) {
                      const l3 = s3 ? e3.posMatrix : t3.transform.calculatePosMatrix(e3.toUnwrapped()), u3 = c2 ? Ge(l3, o2, t3, c2, { tileID: e3, tileSize: h2 }, g2) : Ze(l3, o2, a3), f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e3);
                      m2.draw(r2, n2.TRIANGLES, _2, d2, p2, Bi.disabled, u3, f3, i3.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                    }
                  }(t2, 0, s2, a2);
                  break;
                case "custom":
                  !function(t3, e2, i3) {
                    const s3 = t3.context, a3 = i3.implementation;
                    if ("offscreen" === t3.renderPass) {
                      const e3 = a3.prerender;
                      e3 && (t3.setCustomLayerDefaults(), s3.setColorMode(t3.colorModeForRenderPass()), e3.call(a3, s3.gl, t3.transform.customLayerMatrix()), s3.setDirty(), t3.setBaseState());
                    } else if ("translucent" === t3.renderPass) {
                      t3.setCustomLayerDefaults(), s3.setColorMode(t3.colorModeForRenderPass()), s3.setStencilMode(Fi.disabled);
                      const e3 = "3d" === a3.renderingMode ? new Li(t3.context.gl.LEQUAL, Li.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Li.ReadOnly);
                      s3.setDepthMode(e3), a3.render(s3.gl, t3.transform.customLayerMatrix()), s3.setDirty(), t3.setBaseState(), s3.bindFramebuffer.set(null);
                    }
                  }(t2, 0, s2);
              }
          }
          translatePosMatrix(t2, i2, s2, a2, o2) {
            if (!s2[0] && !s2[1])
              return t2;
            const r2 = o2 ? "map" === a2 ? this.transform.angle : 0 : "viewport" === a2 ? -this.transform.angle : 0;
            if (r2) {
              const t3 = Math.sin(r2), e2 = Math.cos(r2);
              s2 = [s2[0] * e2 - s2[1] * t3, s2[0] * t3 + s2[1] * e2];
            }
            const n2 = [o2 ? s2[0] : Lt(i2, s2[0], this.transform.zoom), o2 ? s2[1] : Lt(i2, s2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return e.H(l2, t2, n2), l2;
          }
          saveTileTexture(t2) {
            const e2 = this._tileTextures[t2.size[0]];
            e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
          }
          getTileTexture(t2) {
            const e2 = this._tileTextures[t2];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }
          isPatternMissing(t2) {
            if (!t2)
              return false;
            if (!t2.from || !t2.to)
              return true;
            const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
            return !e2 || !i2;
          }
          useProgram(t2, e2) {
            this.cache = this.cache || {};
            const i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[i2] || (this.cache[i2] = new fe(this.context, de[t2], e2, qe[t2], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i2];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new b(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t2, drawingBufferHeight: e2 } = this.context.gl;
            return this.width !== t2 || this.height !== e2;
          }
        }
        class hs {
          constructor(t2, e2) {
            this.points = t2, this.planes = e2;
          }
          static fromInvProjectionMatrix(t2, i2, s2) {
            const a2 = Math.pow(2, s2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s3) => {
              const o3 = 1 / (s3 = e.af([], s3, t2))[3] / i2 * a2;
              return e.a$(s3, s3, [o3, o3, 1 / s3[3], o3]);
            }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
              const e2 = function(t4, e3) {
                var i4 = e3[0], s4 = e3[1], a4 = e3[2], o3 = i4 * i4 + s4 * s4 + a4 * a4;
                return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t4[0] = e3[0] * o3, t4[1] = e3[1] * o3, t4[2] = e3[2] * o3, t4;
              }([], function(t4, e3, i4) {
                var s4 = e3[0], a4 = e3[1], o3 = e3[2], r3 = i4[0], n2 = i4[1], l2 = i4[2];
                return t4[0] = a4 * l2 - o3 * n2, t4[1] = o3 * r3 - s4 * l2, t4[2] = s4 * n2 - a4 * r3, t4;
              }([], v([], o2[t3[0]], o2[t3[1]]), v([], o2[t3[2]], o2[t3[1]]))), i3 = -((s3 = e2)[0] * (a3 = o2[t3[1]])[0] + s3[1] * a3[1] + s3[2] * a3[2]);
              var s3, a3;
              return e2.concat(i3);
            });
            return new hs(o2, r2);
          }
        }
        class cs {
          constructor(t2, e2) {
            this.min = t2, this.max = e2, this.center = function(t3, e3, i2) {
              return t3[0] = 0.5 * e3[0], t3[1] = 0.5 * e3[1], t3[2] = 0.5 * e3[2], t3;
            }([], function(t3, e3, i2) {
              return t3[0] = e3[0] + i2[0], t3[1] = e3[1] + i2[1], t3[2] = e3[2] + i2[2], t3;
            }([], this.min, this.max));
          }
          quadrant(t2) {
            const e2 = [t2 % 2 == 0, t2 < 2], i2 = f(this.min), s2 = f(this.max);
            for (let t3 = 0; t3 < e2.length; t3++)
              i2[t3] = e2[t3] ? this.min[t3] : this.center[t3], s2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
            return s2[2] = this.max[2], new cs(i2, s2);
          }
          distanceX(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }
          distanceY(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }
          intersects(t2) {
            const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let s2 = true;
            for (let a2 = 0; a2 < t2.planes.length; a2++) {
              const o2 = t2.planes[a2];
              let r2 = 0;
              for (let t3 = 0; t3 < i2.length; t3++)
                e.b0(o2, i2[t3]) >= 0 && r2++;
              if (0 === r2)
                return 0;
              r2 !== i2.length && (s2 = false);
            }
            if (s2)
              return 2;
            for (let e2 = 0; e2 < 3; e2++) {
              let i3 = Number.MAX_VALUE, s3 = -Number.MAX_VALUE;
              for (let a2 = 0; a2 < t2.points.length; a2++) {
                const o2 = t2.points[a2][e2] - this.min[e2];
                i3 = Math.min(i3, o2), s3 = Math.max(s3, o2);
              }
              if (s3 < 0 || i3 > this.max[e2] - this.min[e2])
                return 0;
            }
            return 1;
          }
        }
        class us {
          constructor(t2 = 0, e2 = 0, i2 = 0, s2 = 0) {
            if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(s2) || s2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t2, this.bottom = e2, this.left = i2, this.right = s2;
          }
          interpolate(t2, i2, s2) {
            return null != i2.top && null != t2.top && (this.top = e.z.number(t2.top, i2.top, s2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.z.number(t2.bottom, i2.bottom, s2)), null != i2.left && null != t2.left && (this.left = e.z.number(t2.left, i2.left, s2)), null != i2.right && null != t2.right && (this.right = e.z.number(t2.right, i2.right, s2)), this;
          }
          getCenter(t2, i2) {
            const s2 = e.ac((this.left + t2 - this.right) / 2, 0, t2), a2 = e.ac((this.top + i2 - this.bottom) / 2, 0, i2);
            return new e.P(s2, a2);
          }
          equals(t2) {
            return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
          }
          clone() {
            return new us(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        const ds = 85.051129;
        class _s {
          constructor(t2, i2, s2, a2, o2) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === o2 || !!o2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == s2 ? 0 : s2, this._maxPitch = null == a2 ? 60 : a2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.M(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new us(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this.minElevationForCurrentTile = 0;
          }
          clone() {
            const t2 = new _s(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t2.apply(this), t2;
          }
          apply(t2) {
            this.tileSize = t2.tileSize, this.latRange = t2.latRange, this.width = t2.width, this.height = t2.height, this._center = t2._center, this._elevation = t2._elevation, this.minElevationForCurrentTile = t2.minElevationForCurrentTile, this.zoom = t2.zoom, this.angle = t2.angle, this._fov = t2._fov, this._pitch = t2._pitch, this._unmodified = t2._unmodified, this._edgeInsets = t2._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t2) {
            this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t2) {
            this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t2) {
            this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t2) {
            this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t2) {
            void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e.P(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(t2) {
            const i2 = -e.b1(t2, -180, 180) * Math.PI / 180;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
              var t3 = new e.A(4);
              return e.A != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
            }(), function(t3, e2, i3) {
              var s2 = e2[0], a2 = e2[1], o2 = e2[2], r2 = e2[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
              t3[0] = s2 * l2 + o2 * n2, t3[1] = a2 * l2 + r2 * n2, t3[2] = s2 * -n2 + o2 * l2, t3[3] = a2 * -n2 + r2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t2) {
            const i2 = e.ac(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t2) {
            const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t2) {
            t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t2) {
            t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t2) {
            this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t2) {
            return this._edgeInsets.equals(t2);
          }
          interpolatePadding(t2, e2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t2) {
            const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
            return Math.max(0, e2);
          }
          getVisibleUnwrappedCoordinates(t2) {
            const i2 = [new e.b2(0, t2)];
            if (this._renderWorldCopies) {
              const s2 = this.pointCoordinate(new e.P(0, 0)), a2 = this.pointCoordinate(new e.P(this.width, 0)), o2 = this.pointCoordinate(new e.P(this.width, this.height)), r2 = this.pointCoordinate(new e.P(0, this.height)), n2 = Math.floor(Math.min(s2.x, a2.x, o2.x, r2.x)), l2 = Math.floor(Math.max(s2.x, a2.x, o2.x, r2.x)), h2 = 1;
              for (let s3 = n2 - h2; s3 <= l2 + h2; s3++)
                0 !== s3 && i2.push(new e.b2(s3, t2));
            }
            return i2;
          }
          coveringTiles(t2) {
            var i2, s2;
            let a2 = this.coveringZoomLevel(t2);
            const o2 = a2;
            if (void 0 !== t2.minzoom && a2 < t2.minzoom)
              return [];
            void 0 !== t2.maxzoom && a2 > t2.maxzoom && (a2 = t2.maxzoom);
            const r2 = this.pointCoordinate(this.getCameraPoint()), n2 = e.Y.fromLngLat(this.center), l2 = Math.pow(2, a2), h2 = [l2 * r2.x, l2 * r2.y, 0], c2 = [l2 * n2.x, l2 * n2.y, 0], u2 = hs.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a2);
            let d2 = t2.minzoom || 0;
            !t2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = a2);
            const _2 = t2.terrain ? 2 / Math.min(this.tileSize, t2.tileSize) * this.tileSize : 3, p2 = (t3) => ({ aabb: new cs([t3 * l2, 0, 0], [(t3 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), m2 = [], f2 = [], g2 = a2, v2 = t2.reparseOverscaled ? o2 : a2;
            if (this._renderWorldCopies)
              for (let t3 = 1; t3 <= 3; t3++)
                m2.push(p2(-t3)), m2.push(p2(t3));
            for (m2.push(p2(0)); m2.length > 0; ) {
              const a3 = m2.pop(), o3 = a3.x, r3 = a3.y;
              let n3 = a3.fullyVisible;
              if (!n3) {
                const t3 = a3.aabb.intersects(u2);
                if (0 === t3)
                  continue;
                n3 = 2 === t3;
              }
              const l3 = t2.terrain ? h2 : c2, p3 = a3.aabb.distanceX(l3), y2 = a3.aabb.distanceY(l3), b2 = Math.max(Math.abs(p3), Math.abs(y2));
              if (a3.zoom === g2 || b2 > _2 + (1 << g2 - a3.zoom) - 2 && a3.zoom >= d2) {
                const t3 = g2 - a3.zoom, i3 = h2[0] - 0.5 - (o3 << t3), s3 = h2[1] - 0.5 - (r3 << t3);
                f2.push({ tileID: new e.Q(a3.zoom === g2 ? v2 : a3.zoom, a3.wrap, a3.zoom, o3, r3), distanceSq: x([c2[0] - 0.5 - o3, c2[1] - 0.5 - r3]), tileDistanceToCamera: Math.sqrt(i3 * i3 + s3 * s3) });
              } else
                for (let l4 = 0; l4 < 4; l4++) {
                  const h3 = (o3 << 1) + l4 % 2, c3 = (r3 << 1) + (l4 >> 1), u3 = a3.zoom + 1;
                  let d3 = a3.aabb.quadrant(l4);
                  if (t2.terrain) {
                    const o4 = new e.Q(u3, a3.wrap, u3, h3, c3), r4 = t2.terrain.getMinMaxElevation(o4), n4 = null !== (i2 = r4.minElevation) && void 0 !== i2 ? i2 : this.elevation, l5 = null !== (s2 = r4.maxElevation) && void 0 !== s2 ? s2 : this.elevation;
                    d3 = new cs([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                  }
                  m2.push({ aabb: d3, zoom: u3, x: h3, y: c3, wrap: a3.wrap, fullyVisible: n3 });
                }
            }
            return f2.sort((t3, e2) => t3.distanceSq - e2.distanceSq).map((t3) => t3.tileID);
          }
          resize(t2, e2) {
            this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t2) {
            return Math.pow(2, t2);
          }
          scaleZoom(t2) {
            return Math.log(t2) / Math.LN2;
          }
          project(t2) {
            const i2 = e.ac(t2.lat, -85.051129, ds);
            return new e.P(e.N(t2.lng) * this.worldSize, e.O(i2) * this.worldSize);
          }
          unproject(t2) {
            return new e.Y(t2.x / this.worldSize, t2.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(t2) {
            const i2 = this.elevation, s2 = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, a2 = this.pointLocation(this.centerPoint, t2), o2 = t2.getElevationForLngLatZoom(a2, this.tileZoom);
            if (!(this.elevation - o2))
              return;
            const r2 = s2 + i2 - o2, n2 = Math.cos(this._pitch) * this.cameraToCenterDistance / r2 / e.b3(1, a2.lat), l2 = this.scaleZoom(n2 / this.tileSize);
            this._elevation = o2, this._center = a2, this.zoom = l2;
          }
          setLocationAtPoint(t2, i2) {
            const s2 = this.pointCoordinate(i2), a2 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(t2), r2 = new e.Y(o2.x - (s2.x - a2.x), o2.y - (s2.y - a2.y));
            this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t2, e2) {
            return e2 ? this.coordinatePoint(this.locationCoordinate(t2), e2.getElevationForLngLatZoom(t2, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
          }
          pointLocation(t2, e2) {
            return this.coordinateLocation(this.pointCoordinate(t2, e2));
          }
          locationCoordinate(t2) {
            return e.Y.fromLngLat(t2);
          }
          coordinateLocation(t2) {
            return t2 && t2.toLngLat();
          }
          pointCoordinate(t2, i2) {
            if (i2) {
              const e2 = i2.pointCoordinate(t2);
              if (null != e2)
                return e2;
            }
            const s2 = [t2.x, t2.y, 0, 1], a2 = [t2.x, t2.y, 1, 1];
            e.af(s2, s2, this.pixelMatrixInverse), e.af(a2, a2, this.pixelMatrixInverse);
            const o2 = s2[3], r2 = a2[3], n2 = s2[1] / o2, l2 = a2[1] / r2, h2 = s2[2] / o2, c2 = a2[2] / r2, u2 = h2 === c2 ? 0 : (0 - h2) / (c2 - h2);
            return new e.Y(e.z.number(s2[0] / o2, a2[0] / r2, u2) / this.worldSize, e.z.number(n2, l2, u2) / this.worldSize);
          }
          coordinatePoint(t2, i2 = 0, s2 = this.pixelMatrix) {
            const a2 = [t2.x * this.worldSize, t2.y * this.worldSize, i2, 1];
            return e.af(a2, a2, s2), new e.P(a2[0] / a2[3], a2[1] / a2[3]);
          }
          getBounds() {
            const t2 = Math.max(0, this.height / 2 - this.getHorizon());
            return new j().extend(this.pointLocation(new e.P(0, t2))).extend(this.pointLocation(new e.P(this.width, t2))).extend(this.pointLocation(new e.P(this.width, this.height))).extend(this.pointLocation(new e.P(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new j([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t2) {
            t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, ds]);
          }
          calculatePosMatrix(t2, i2 = false) {
            const s2 = t2.key, a2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a2[s2])
              return a2[s2];
            const o2 = t2.canonical, r2 = this.worldSize / this.zoomScale(o2.z), n2 = o2.x + Math.pow(2, o2.z) * t2.wrap, l2 = e.an(new Float64Array(16));
            return e.H(l2, l2, [n2 * r2, o2.y * r2, 0]), e.J(l2, l2, [r2 / e.W, r2 / e.W, 1]), e.K(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), a2[s2] = new Float32Array(l2), a2[s2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          getConstrained(t2, i2) {
            i2 = e.ac(+i2, this.minZoom, this.maxZoom);
            const s2 = { center: new e.M(t2.lng, t2.lat), zoom: i2 };
            let a2 = this.lngRange;
            if (!this._renderWorldCopies && null === a2) {
              const t3 = 180 - 1e-10;
              a2 = [-t3, t3];
            }
            const o2 = this.tileSize * this.zoomScale(s2.zoom);
            let r2 = 0, n2 = o2, l2 = 0, h2 = o2, c2 = 0, u2 = 0;
            const { x: d2, y: _2 } = this.size;
            if (this.latRange) {
              const t3 = this.latRange;
              r2 = e.O(t3[1]) * o2, n2 = e.O(t3[0]) * o2, n2 - r2 < _2 && (c2 = _2 / (n2 - r2));
            }
            a2 && (l2 = e.b1(e.N(a2[0]) * o2, 0, o2), h2 = e.b1(e.N(a2[1]) * o2, 0, o2), h2 < l2 && (h2 += o2), h2 - l2 < d2 && (u2 = d2 / (h2 - l2)));
            const { x: p2, y: m2 } = this.project.call({ worldSize: o2 }, t2);
            let f2, g2;
            const v2 = Math.max(u2 || 0, c2 || 0);
            if (v2) {
              const t3 = new e.P(u2 ? (h2 + l2) / 2 : p2, c2 ? (n2 + r2) / 2 : m2);
              return s2.center = this.unproject.call({ worldSize: o2 }, t3).wrap(), s2.zoom += this.scaleZoom(v2), s2;
            }
            if (this.latRange) {
              const t3 = _2 / 2;
              m2 - t3 < r2 && (g2 = r2 + t3), m2 + t3 > n2 && (g2 = n2 - t3);
            }
            if (a2) {
              const t3 = (l2 + h2) / 2;
              let i3 = p2;
              this._renderWorldCopies && (i3 = e.b1(p2, t3 - o2 / 2, t3 + o2 / 2));
              const s3 = d2 / 2;
              i3 - s3 < l2 && (f2 = l2 + s3), i3 + s3 > h2 && (f2 = h2 - s3);
            }
            if (void 0 !== f2 || void 0 !== g2) {
              const t3 = new e.P(null != f2 ? f2 : p2, null != g2 ? g2 : m2);
              s2.center = this.unproject.call({ worldSize: o2 }, t3).wrap();
            }
            return s2;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            const t2 = this._unmodified, { center: e2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
            this.center = e2, this.zoom = i2, this._unmodified = t2, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t2 = this.centerOffset, i2 = this.point.x, s2 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = e.b3(1, this.center.lat) * this.worldSize;
            let a2 = e.an(new Float64Array(16));
            e.J(a2, a2, [this.width / 2, -this.height / 2, 1]), e.H(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = e.an(new Float64Array(16)), e.J(a2, a2, [1, -1, 1]), e.H(a2, a2, [-1, -1, 0]), e.J(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2;
            const o2 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r2 = Math.min(this.elevation, this.minElevationForCurrentTile), n2 = o2 - r2 * this._pixelPerMeter / Math.cos(this._pitch), l2 = r2 < 0 ? n2 : o2, h2 = Math.PI / 2 + this._pitch, c2 = this._fov * (0.5 + t2.y / this.height), u2 = Math.sin(c2) * l2 / Math.sin(e.ac(Math.PI - h2 - c2, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + t2.y / (2 * d2)), p2 = Math.sin(_2) * l2 / Math.sin(e.ac(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u2, p2), f2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l2), g2 = this.height / 50;
            a2 = new Float64Array(16), e.b4(a2, this._fov, this.width / this.height, g2, f2), a2[8] = 2 * -t2.x / this.width, a2[9] = 2 * t2.y / this.height, e.J(a2, a2, [1, -1, 1]), e.H(a2, a2, [0, 0, -this.cameraToCenterDistance]), e.b5(a2, a2, this._pitch), e.ad(a2, a2, this.angle), e.H(a2, a2, [-i2, -s2, 0]), this.mercatorMatrix = e.J([], a2, [this.worldSize, this.worldSize, this.worldSize]), e.J(a2, a2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = e.K(new Float64Array(16), this.labelPlaneMatrix, a2), e.H(a2, a2, [0, 0, -this.elevation]), this.projMatrix = a2, this.invProjMatrix = e.ar([], a2), this.pixelMatrix3D = e.K(new Float64Array(16), this.labelPlaneMatrix, a2);
            const v2 = this.width % 2 / 2, x2 = this.height % 2 / 2, y2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = i2 - Math.round(i2) + y2 * v2 + b2 * x2, T2 = s2 - Math.round(s2) + y2 * x2 + b2 * v2, I2 = new Float64Array(a2);
            if (e.H(I2, I2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = I2, a2 = e.ar(new Float64Array(16), this.pixelMatrix), !a2)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = a2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse)
              return 1;
            const t2 = this.pointCoordinate(new e.P(0, 0)), i2 = [t2.x * this.worldSize, t2.y * this.worldSize, 0, 1];
            return e.af(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e.P(0, t2));
          }
          getCameraQueryGeometry(t2) {
            const i2 = this.getCameraPoint();
            if (1 === t2.length)
              return [t2[0], i2];
            {
              let s2 = i2.x, a2 = i2.y, o2 = i2.x, r2 = i2.y;
              for (const e2 of t2)
                s2 = Math.min(s2, e2.x), a2 = Math.min(a2, e2.y), o2 = Math.max(o2, e2.x), r2 = Math.max(r2, e2.y);
              return [new e.P(s2, a2), new e.P(o2, a2), new e.P(o2, r2), new e.P(s2, r2), new e.P(s2, a2)];
            }
          }
          lngLatToCameraDepth(t2, i2) {
            const s2 = this.locationCoordinate(t2), a2 = [s2.x * this.worldSize, s2.y * this.worldSize, i2, 1];
            return e.af(a2, a2, this.projMatrix), a2[2] / a2[3];
          }
        }
        function ps(t2, e2) {
          let i2, s2 = false, a2 = null, o2 = null;
          const r2 = () => {
            a2 = null, s2 && (t2.apply(o2, i2), a2 = setTimeout(r2, e2), s2 = false);
          };
          return (...t3) => (s2 = true, o2 = this, i2 = t3, a2 || r2(), a2);
        }
        class ms {
          constructor(t2) {
            this._getCurrentHash = () => {
              const t3 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t3.split("&").map((t4) => t4.split("=")).forEach((t4) => {
                  t4[0] === this._hashName && (e2 = t4);
                }), (e2 && e2[1] || "").split("/");
              }
              return t3.split("/");
            }, this._onHashChange = () => {
              const t3 = this._getCurrentHash();
              if (t3.length >= 3 && !t3.some((t4) => isNaN(t4))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: e2, pitch: +(t3[4] || 0) }), true;
              }
              return false;
            }, this._updateHashUnthrottled = () => {
              const t3 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t3);
              } catch (t4) {
              }
            }, this._updateHash = ps(this._updateHashUnthrottled, 300), this._hashName = t2 && encodeURIComponent(t2);
          }
          addTo(t2) {
            return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t2) {
            const e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, s2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, s2), o2 = Math.round(e2.lng * a2) / a2, r2 = Math.round(e2.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
            let h2 = "";
            if (h2 += t2 ? `/${o2}/${r2}/${i2}` : `${i2}/${r2}/${o2}`, (n2 || l2) && (h2 += "/" + Math.round(10 * n2) / 10), l2 && (h2 += `/${Math.round(l2)}`), this._hashName) {
              const t3 = this._hashName;
              let e3 = false;
              const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                const s3 = i4.split("=")[0];
                return s3 === t3 ? (e3 = true, `${s3}=${h2}`) : i4;
              }).filter((t4) => t4);
              return e3 || i3.push(`${t3}=${h2}`), `#${i3.join("&")}`;
            }
            return `#${h2}`;
          }
        }
        const fs = { linearity: 0.3, easing: e.b6(0, 0, 0.3, 1) }, gs = e.e({ deceleration: 2500, maxSpeed: 1400 }, fs), vs = e.e({ deceleration: 20, maxSpeed: 1400 }, fs), xs = e.e({ deceleration: 1e3, maxSpeed: 360 }, fs), ys = e.e({ deceleration: 1e3, maxSpeed: 90 }, fs);
        class bs {
          constructor(t2) {
            this._map = t2, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.now(), settings: t2 });
          }
          _drainInertiaBuffer() {
            const t2 = this._inertiaBuffer, e2 = o.now();
            for (; t2.length > 0 && e2 - t2[0].time > 160; )
              t2.shift();
          }
          _onMoveEnd(t2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t3 } of this._inertiaBuffer)
              i2.zoom += t3.zoomDelta || 0, i2.bearing += t3.bearingDelta || 0, i2.pitch += t3.pitchDelta || 0, t3.panDelta && i2.pan._add(t3.panDelta), t3.around && (i2.around = t3.around), t3.pinchAround && (i2.pinchAround = t3.pinchAround);
            const s2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
            if (i2.pan.mag()) {
              const o2 = Ts(i2.pan.mag(), s2, e.e({}, gs, t2 || {}));
              a2.offset = i2.pan.mult(o2.amount / i2.pan.mag()), a2.center = this._map.transform.center, ws(a2, o2);
            }
            if (i2.zoom) {
              const t3 = Ts(i2.zoom, s2, vs);
              a2.zoom = this._map.transform.zoom + t3.amount, ws(a2, t3);
            }
            if (i2.bearing) {
              const t3 = Ts(i2.bearing, s2, xs);
              a2.bearing = this._map.transform.bearing + e.ac(t3.amount, -179, 179), ws(a2, t3);
            }
            if (i2.pitch) {
              const t3 = Ts(i2.pitch, s2, ys);
              a2.pitch = this._map.transform.pitch + t3.amount, ws(a2, t3);
            }
            if (a2.zoom || a2.bearing) {
              const t3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
              a2.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
            }
            return this.clear(), e.e(a2, { noMoveStart: true });
          }
        }
        function ws(t2, e2) {
          (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
        }
        function Ts(t2, i2, s2) {
          const { maxSpeed: a2, linearity: o2, deceleration: r2 } = s2, n2 = e.ac(t2 * o2 / (i2 / 1e3), -a2, a2), l2 = Math.abs(n2) / (r2 * o2);
          return { easing: s2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
        }
        class Is extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, s2, a2 = {}) {
            const o2 = r.mousePos(i2.getCanvas(), s2), n2 = i2.unproject(o2);
            super(t2, e.e({ point: o2, lngLat: n2, originalEvent: s2 }, a2)), this._defaultPrevented = false, this.target = i2;
          }
        }
        class Es extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, i2, s2) {
            const a2 = "touchend" === t2 ? s2.changedTouches : s2.touches, o2 = r.touchPos(i2.getCanvasContainer(), a2), n2 = o2.map((t3) => i2.unproject(t3)), l2 = o2.reduce((t3, e2, i3, s3) => t3.add(e2.div(s3.length)), new e.P(0, 0));
            super(t2, { points: o2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: s2 }), this._defaultPrevented = false;
          }
        }
        class Cs extends e.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t2, e2, i2) {
            super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
          }
        }
        class Ss {
          constructor(t2, e2) {
            this._map = t2, this._clickTolerance = e2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t2) {
            return this._firePreventable(new Cs(t2.type, this._map, t2));
          }
          mousedown(t2, e2) {
            return this._mousedownPos = e2, this._firePreventable(new Is(t2.type, this._map, t2));
          }
          mouseup(t2) {
            this._map.fire(new Is(t2.type, this._map, t2));
          }
          click(t2, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new Is(t2.type, this._map, t2));
          }
          dblclick(t2) {
            return this._firePreventable(new Is(t2.type, this._map, t2));
          }
          mouseover(t2) {
            this._map.fire(new Is(t2.type, this._map, t2));
          }
          mouseout(t2) {
            this._map.fire(new Is(t2.type, this._map, t2));
          }
          touchstart(t2) {
            return this._firePreventable(new Es(t2.type, this._map, t2));
          }
          touchmove(t2) {
            this._map.fire(new Es(t2.type, this._map, t2));
          }
          touchend(t2) {
            this._map.fire(new Es(t2.type, this._map, t2));
          }
          touchcancel(t2) {
            this._map.fire(new Es(t2.type, this._map, t2));
          }
          _firePreventable(t2) {
            if (this._map.fire(t2), t2.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ps {
          constructor(t2) {
            this._map = t2;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t2) {
            this._map.fire(new Is(t2.type, this._map, t2));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Is("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t2) {
            this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new Is(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ds {
          constructor(t2) {
            this._map = t2;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t2) {
            return this.transform.pointLocation(e.P.convert(t2), this._map.terrain);
          }
        }
        class zs {
          constructor(t2, e2) {
            this._map = t2, this._tr = new Ds(t2), this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t2, e2) {
            this.isEnabled() && t2.shiftKey && 0 === t2.button && (r.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
          }
          mousemoveWindow(t2, e2) {
            if (!this._active)
              return;
            const i2 = e2;
            if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
              return;
            const s2 = this._startPos;
            this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t2));
            const a2 = Math.min(s2.x, i2.x), o2 = Math.max(s2.x, i2.x), n2 = Math.min(s2.y, i2.y), l2 = Math.max(s2.y, i2.y);
            r.setTransform(this._box, `translate(${a2}px,${n2}px)`), this._box.style.width = o2 - a2 + "px", this._box.style.height = l2 - n2 + "px";
          }
          mouseupWindow(t2, i2) {
            if (!this._active)
              return;
            if (0 !== t2.button)
              return;
            const s2 = this._startPos, a2 = i2;
            if (this.reset(), r.suppressClick(), s2.x !== a2.x || s2.y !== a2.y)
              return this._map.fire(new e.k("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(s2, a2, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", t2);
          }
          keydown(t2) {
            this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t2, i2) {
            return this._map.fire(new e.k(t2, { originalEvent: i2 }));
          }
        }
        function Ms(t2, e2) {
          if (t2.length !== e2.length)
            throw new Error(`The number of touches and points are not equal - touches ${t2.length}, points ${e2.length}`);
          const i2 = {};
          for (let s2 = 0; s2 < t2.length; s2++)
            i2[t2[s2].identifier] = e2[s2];
          return i2;
        }
        class As {
          constructor(t2) {
            this.reset(), this.numTouches = t2.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(t2, i2, s2) {
            (this.centroid || s2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = t2.timeStamp), s2.length === this.numTouches && (this.centroid = function(t3) {
              const i3 = new e.P(0, 0);
              for (const e2 of t3)
                i3._add(e2);
              return i3.div(t3.length);
            }(i2), this.touches = Ms(s2, i2)));
          }
          touchmove(t2, e2, i2) {
            if (this.aborted || !this.centroid)
              return;
            const s2 = Ms(i2, e2);
            for (const t3 in this.touches) {
              const e3 = s2[t3];
              (!e3 || e3.dist(this.touches[t3]) > 30) && (this.aborted = true);
            }
          }
          touchend(t2, e2, i2) {
            if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              const t3 = !this.aborted && this.centroid;
              if (this.reset(), t3)
                return t3;
            }
          }
        }
        class Rs {
          constructor(t2) {
            this.singleTap = new As(t2), this.numTaps = t2.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t2, e2, i2) {
            this.singleTap.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this.singleTap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            const s2 = this.singleTap.touchend(t2, e2, i2);
            if (s2) {
              const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(s2) < 30;
              if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = s2, this.count === this.numTaps)
                return this.reset(), s2;
            }
          }
        }
        class Ls {
          constructor(t2) {
            this._tr = new Ds(t2), this._zoomIn = new Rs({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Rs({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t2, e2, i2) {
            this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            const s2 = this._zoomIn.touchend(t2, e2, i2), a2 = this._zoomOut.touchend(t2, e2, i2), o2 = this._tr;
            return s2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(s2) }, { originalEvent: t2 }) }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(a2) }, { originalEvent: t2 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ks {
          constructor(t2) {
            this._enabled = !!t2.enable, this._moveStateManager = t2.moveStateManager, this._clickTolerance = t2.clickTolerance || 1, this._moveFunction = t2.move, this._activateOnStart = !!t2.activateOnStart, t2.assignEvents(this), this.reset();
          }
          reset(t2) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t2);
          }
          _move(...t2) {
            const e2 = this._moveFunction(...t2);
            if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta)
              return this._active = true, e2;
          }
          dragStart(t2, e2) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t2) && (this._moveStateManager.startMove(t2), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t2, e2) {
            if (!this.isEnabled())
              return;
            const i2 = this._lastPoint;
            if (!i2)
              return;
            if (t2.preventDefault(), !this._moveStateManager.isValidMoveEvent(t2))
              return void this.reset(t2);
            const s2 = e2.length ? e2[0] : e2;
            return !this._moved && s2.dist(i2) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s2, this._move(i2, s2));
          }
          dragEnd(t2) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t2) && (this._moved && r.suppressClick(), this.reset(t2));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Fs = { 0: 1, 2: 2 };
        class Bs {
          constructor(t2) {
            this._correctEvent = t2.checkCorrectEvent;
          }
          startMove(t2) {
            const e2 = r.mouseButton(t2);
            this._eventButton = e2;
          }
          endMove(t2) {
            delete this._eventButton;
          }
          isValidStartEvent(t2) {
            return this._correctEvent(t2);
          }
          isValidMoveEvent(t2) {
            return !function(t3, e2) {
              const i2 = Fs[e2];
              return void 0 === t3.buttons || (t3.buttons & i2) !== i2;
            }(t2, this._eventButton);
          }
          isValidEndEvent(t2) {
            return r.mouseButton(t2) === this._eventButton;
          }
        }
        class Os {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t2) {
            return 1 === t2.targetTouches.length;
          }
          _isSameTouchEvent(t2) {
            return t2.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t2) {
            this._firstTouch = t2.targetTouches[0].identifier;
          }
          endMove(t2) {
            delete this._firstTouch;
          }
          isValidStartEvent(t2) {
            return this._isOneFingerTouch(t2);
          }
          isValidMoveEvent(t2) {
            return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
          }
          isValidEndEvent(t2) {
            return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
          }
        }
        const Ns = (t2) => {
          t2.mousedown = t2.dragStart, t2.mousemoveWindow = t2.dragMove, t2.mouseup = t2.dragEnd, t2.contextmenu = function(t3) {
            t3.preventDefault();
          };
        }, Us = ({ enable: t2, clickTolerance: e2, bearingDegreesPerPixelMoved: i2 = 0.8 }) => {
          const s2 = new Bs({ checkCorrectEvent: (t3) => 0 === r.mouseButton(t3) && t3.ctrlKey || 2 === r.mouseButton(t3) });
          return new ks({ clickTolerance: e2, move: (t3, e3) => ({ bearingDelta: (e3.x - t3.x) * i2 }), moveStateManager: s2, enable: t2, assignEvents: Ns });
        }, Zs = ({ enable: t2, clickTolerance: e2, pitchDegreesPerPixelMoved: i2 = -0.5 }) => {
          const s2 = new Bs({ checkCorrectEvent: (t3) => 0 === r.mouseButton(t3) && t3.ctrlKey || 2 === r.mouseButton(t3) });
          return new ks({ clickTolerance: e2, move: (t3, e3) => ({ pitchDelta: (e3.y - t3.y) * i2 }), moveStateManager: s2, enable: t2, assignEvents: Ns });
        };
        class Gs {
          constructor(t2, e2) {
            this._clickTolerance = t2.clickTolerance || 1, this._map = e2, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
          }
          minTouchs() {
            return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
          }
          touchstart(t2, e2, i2) {
            return this._calculateTransform(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            if (this._active && !(i2.length < this.minTouchs()))
              return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            this._calculateTransform(t2, e2, i2), this._active && i2.length < this.minTouchs() && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t2, i2, s2) {
            s2.length > 0 && (this._active = true);
            const a2 = Ms(s2, i2), o2 = new e.P(0, 0), r2 = new e.P(0, 0);
            let n2 = 0;
            for (const t3 in a2) {
              const e2 = a2[t3], i3 = this._touches[t3];
              i3 && (o2._add(e2), r2._add(e2.sub(i3)), n2++, a2[t3] = e2);
            }
            if (this._touches = a2, n2 < this.minTouchs() || !r2.mag())
              return;
            const l2 = r2.div(n2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n2), panDelta: l2 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class qs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t2, e2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
          }
          touchmove(t2, e2, i2) {
            if (!this._firstTwoTouches)
              return;
            t2.preventDefault();
            const [s2, a2] = this._firstTwoTouches, o2 = js(i2, e2, s2), r2 = js(i2, e2, a2);
            if (!o2 || !r2)
              return;
            const n2 = this._aroundCenter ? null : o2.add(r2).div(2);
            return this._move([o2, r2], n2, t2);
          }
          touchend(t2, e2, i2) {
            if (!this._firstTwoTouches)
              return;
            const [s2, a2] = this._firstTwoTouches, o2 = js(i2, e2, s2), n2 = js(i2, e2, a2);
            o2 && n2 || (this._active && r.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t2) {
            this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function js(t2, e2, i2) {
          for (let s2 = 0; s2 < t2.length; s2++)
            if (t2[s2].identifier === i2)
              return e2[s2];
        }
        function Vs(t2, e2) {
          return Math.log(t2 / e2) / Math.LN2;
        }
        class Hs extends qs {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t2) {
            this._startDistance = this._distance = t2[0].dist(t2[1]);
          }
          _move(t2, e2) {
            const i2 = this._distance;
            if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(Vs(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Vs(this._distance, i2), pinchAround: e2 };
          }
        }
        function Ws(t2, e2) {
          return 180 * t2.angleWith(e2) / Math.PI;
        }
        class $s extends qs {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t2) {
            this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
          }
          _move(t2, e2, i2) {
            const s2 = this._vector;
            if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: Ws(this._vector, s2), pinchAround: e2 };
          }
          _isBelowThreshold(t2) {
            this._minDiameter = Math.min(this._minDiameter, t2.mag());
            const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Ws(t2, this._startVector);
            return Math.abs(i2) < e2;
          }
        }
        function Xs(t2) {
          return Math.abs(t2.y) > Math.abs(t2.x);
        }
        class Ks extends qs {
          constructor(t2) {
            super(), this._currentTouchCount = 0, this._map = t2;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t2, e2, i2) {
            super.touchstart(t2, e2, i2), this._currentTouchCount = i2.length;
          }
          _start(t2) {
            this._lastPoints = t2, Xs(t2[0].sub(t2[1])) && (this._valid = false);
          }
          _move(t2, e2, i2) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
              return;
            const s2 = t2[0].sub(this._lastPoints[0]), a2 = t2[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(s2, a2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = true, { pitchDelta: (s2.y + a2.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t2, e2, i2) {
            if (void 0 !== this._valid)
              return this._valid;
            const s2 = t2.mag() >= 2, a2 = e2.mag() >= 2;
            if (!s2 && !a2)
              return;
            if (!s2 || !a2)
              return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
            const o2 = t2.y > 0 == e2.y > 0;
            return Xs(t2) && Xs(e2) && o2;
          }
        }
        const Ys = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Js {
          constructor(t2) {
            this._tr = new Ds(t2);
            const e2 = Ys;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t2) {
            if (t2.altKey || t2.ctrlKey || t2.metaKey)
              return;
            let e2 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
            switch (t2.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t2.shiftKey ? i2 = -1 : (t2.preventDefault(), a2 = -1);
                break;
              case 39:
                t2.shiftKey ? i2 = 1 : (t2.preventDefault(), a2 = 1);
                break;
              case 38:
                t2.shiftKey ? s2 = 1 : (t2.preventDefault(), o2 = -1);
                break;
              case 40:
                t2.shiftKey ? s2 = -1 : (t2.preventDefault(), o2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i2 = 0, s2 = 0), { cameraAnimation: (r2) => {
              const n2 = this._tr;
              r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Qs, zoom: e2 ? Math.round(n2.zoom) + e2 * (t2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + s2 * this._pitchStep, offset: [-a2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Qs(t2) {
          return t2 * (2 - t2);
        }
        const ta = 4.000244140625;
        class ea {
          constructor(t2, e2) {
            this._onTimeout = (t3) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t3);
            }, this._map = t2, this._tr = new Ds(t2), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(t2) {
            this._defaultZoomRate = t2;
          }
          setWheelZoomRate(t2) {
            this._wheelZoomRate = t2;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          wheel(t2) {
            if (!this.isEnabled())
              return;
            if (this._map.cooperativeGestures.isEnabled() && !t2[this._map.cooperativeGestures._bypassKey])
              return;
            let e2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
            const i2 = o.now(), s2 = i2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = i2, 0 !== e2 && e2 % ta == 0 ? this._type = "wheel" : 0 !== e2 && Math.abs(e2) < 4 ? this._type = "trackpad" : s2 > 400 ? (this._type = null, this._lastValue = e2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(s2 * e2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e2 += this._lastValue)), t2.shiftKey && e2 && (e2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= e2, this._active || this._start(t2)), t2.preventDefault();
          }
          _start(t2) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i2 = r.mousePos(this._map.getCanvas(), t2), s2 = this._tr;
            this._around = i2.y > s2.transform.height / 2 - s2.transform.getHorizon() ? e.M.convert(this._aroundCenter ? s2.center : s2.unproject(i2)) : e.M.convert(s2.center), this._aroundPoint = s2.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t2 = this._tr.transform;
            if (0 !== this._delta) {
              const e2 = "wheel" === this._type && Math.abs(this._delta) > ta ? this._wheelZoomRate : this._defaultZoomRate;
              let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
              this._delta < 0 && 0 !== i3 && (i3 = 1 / i3);
              const s3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : t2.scale;
              this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(s3 * i3))), "wheel" === this._type && (this._startZoom = t2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i2 = "number" == typeof this._targetZoom ? this._targetZoom : t2.zoom, s2 = this._startZoom, a2 = this._easing;
            let r2, n2 = false;
            if ("wheel" === this._type && s2 && a2) {
              const t3 = Math.min((o.now() - this._lastWheelEventTime) / 200, 1), l2 = a2(t3);
              r2 = e.z.number(s2, i2, l2), t3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
            } else
              r2 = i2, n2 = true;
            return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !n2, zoomDelta: r2 - t2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t2) {
            let i2 = e.b7;
            if (this._prevEase) {
              const t3 = this._prevEase, s2 = (o.now() - t3.start) / t3.duration, a2 = t3.easing(s2 + 0.01) - t3.easing(s2), r2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
              i2 = e.b6(r2, n2, 0.25, 1);
            }
            return this._prevEase = { start: o.now(), duration: t2, easing: i2 }, i2;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class ia {
          constructor(t2, e2) {
            this._clickZoom = t2, this._tapZoom = e2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class sa {
          constructor(t2) {
            this._tr = new Ds(t2), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t2, e2) {
            return t2.preventDefault(), { cameraAnimation: (i2) => {
              i2.easeTo({ duration: 300, zoom: this._tr.zoom + (t2.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t2 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class aa {
          constructor() {
            this._tap = new Rs({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t2, e2, i2) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const s2 = e2[0], a2 = t2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(s2) < 30;
                a2 && o2 ? i2.length > 0 && (this._swipePoint = s2, this._swipeTouch = i2[0].identifier) : this.reset();
              } else
                this._tap.touchstart(t2, e2, i2);
          }
          touchmove(t2, e2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch)
                  return;
                const s2 = e2[0], a2 = s2.y - this._swipePoint.y;
                return this._swipePoint = s2, t2.preventDefault(), this._active = true, { zoomDelta: a2 / 128 };
              }
            } else
              this._tap.touchmove(t2, e2, i2);
          }
          touchend(t2, e2, i2) {
            if (this._tapTime)
              this._swipePoint && 0 === i2.length && this.reset();
            else {
              const s2 = this._tap.touchend(t2, e2, i2);
              s2 && (this._tapTime = t2.timeStamp, this._tapPoint = s2);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class oa {
          constructor(t2, e2, i2) {
            this._el = t2, this._mousePan = e2, this._touchPan = i2;
          }
          enable(t2) {
            this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class ra {
          constructor(t2, e2, i2) {
            this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class na {
          constructor(t2, e2, i2, s2) {
            this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = s2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t2) {
            this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class la {
          constructor(t2, e2) {
            this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = t2, this._options = e2, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container)
              return;
            const t2 = this._map.getCanvasContainer();
            t2.classList.add("maplibregl-cooperative-gestures"), this._container = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
            let e2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            "metaKey" === this._bypassKey && (e2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), s2 = document.createElement("div");
            s2.className = "maplibregl-desktop-message", s2.textContent = e2, this._container.appendChild(s2);
            const a2 = document.createElement("div");
            a2.className = "maplibregl-mobile-message", a2.textContent = i2, this._container.appendChild(a2), this._container.setAttribute("aria-hidden", "true");
          }
          _destoryUI() {
            this._container && (r.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destoryUI();
          }
          isEnabled() {
            return this._enabled;
          }
          touchmove(t2) {
            this._onCooperativeGesture(1 === t2.touches.length);
          }
          wheel(t2) {
            this._map.scrollZoom.isEnabled() && this._onCooperativeGesture(!t2[this._bypassKey]);
          }
          _onCooperativeGesture(t2) {
            this._enabled && t2 && (this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const ha = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
        class ca extends e.k {
        }
        function ua(t2) {
          return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
        }
        class da {
          constructor(t2, e2) {
            this.handleWindowEvent = (t3) => {
              this.handleEvent(t3, `${t3.type}Window`);
            }, this.handleEvent = (t3, e3) => {
              if ("blur" === t3.type)
                return void this.stop(true);
              this._updatingCamera = true;
              const i3 = "renderFrame" === t3.type ? void 0 : t3, s2 = { needsRenderFrame: false }, a2 = {}, o2 = {}, n2 = t3.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, h2 = l2 ? r.touchPos(this._map.getCanvas(), l2) : r.mousePos(this._map.getCanvas(), t3);
              for (const { handlerName: r2, handler: n3, allowed: c3 } of this._handlers) {
                if (!n3.isEnabled())
                  continue;
                let u3;
                this._blockedByActive(o2, c3, r2) ? n3.reset() : n3[e3 || t3.type] && (u3 = n3[e3 || t3.type](t3, h2, l2), this.mergeHandlerResult(s2, a2, u3, r2, i3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (o2[r2] = n3);
              }
              const c2 = {};
              for (const t4 in this._previousActiveHandlers)
                o2[t4] || (c2[t4] = i3);
              this._previousActiveHandlers = o2, (Object.keys(c2).length || ua(s2)) && (this._changes.push([s2, a2, c2]), this._triggerRenderFrame()), (Object.keys(o2).length || ua(s2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u2 } = s2;
              u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
            }, this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new bs(t2), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
            const i2 = this._el;
            this._listeners = [[i2, "touchstart", { passive: true }], [i2, "touchmove", { passive: false }], [i2, "touchend", void 0], [i2, "touchcancel", void 0], [i2, "mousedown", void 0], [i2, "mousemove", void 0], [i2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [i2, "mouseover", void 0], [i2, "mouseout", void 0], [i2, "dblclick", void 0], [i2, "click", void 0], [i2, "keydown", { capture: false }], [i2, "keyup", void 0], [i2, "wheel", { passive: false }], [i2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t3, e3, i3] of this._listeners)
              r.addEventListener(t3, e3, t3 === document ? this.handleWindowEvent : this.handleEvent, i3);
          }
          destroy() {
            for (const [t2, e2, i2] of this._listeners)
              r.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
          }
          _addDefaultHandlers(t2) {
            const e2 = this._map, i2 = e2.getCanvasContainer();
            this._add("mapEvent", new Ss(e2, t2));
            const s2 = e2.boxZoom = new zs(e2, t2);
            this._add("boxZoom", s2), t2.interactive && t2.boxZoom && s2.enable();
            const a2 = e2.cooperativeGestures = new la(e2, t2.cooperativeGestures);
            this._add("cooperativeGestures", a2), t2.cooperativeGestures && a2.enable();
            const o2 = new Ls(e2), n2 = new sa(e2);
            e2.doubleClickZoom = new ia(n2, o2), this._add("tapZoom", o2), this._add("clickZoom", n2), t2.interactive && t2.doubleClickZoom && e2.doubleClickZoom.enable();
            const l2 = new aa();
            this._add("tapDragZoom", l2);
            const h2 = e2.touchPitch = new Ks(e2);
            this._add("touchPitch", h2), t2.interactive && t2.touchPitch && e2.touchPitch.enable(t2.touchPitch);
            const c2 = Us(t2), u2 = Zs(t2);
            e2.dragRotate = new ra(t2, c2, u2), this._add("mouseRotate", c2, ["mousePitch"]), this._add("mousePitch", u2, ["mouseRotate"]), t2.interactive && t2.dragRotate && e2.dragRotate.enable();
            const d2 = (({ enable: t3, clickTolerance: e3 }) => {
              const i3 = new Bs({ checkCorrectEvent: (t4) => 0 === r.mouseButton(t4) && !t4.ctrlKey });
              return new ks({ clickTolerance: e3, move: (t4, e4) => ({ around: e4, panDelta: e4.sub(t4) }), activateOnStart: true, moveStateManager: i3, enable: t3, assignEvents: Ns });
            })(t2), _2 = new Gs(t2, e2);
            e2.dragPan = new oa(i2, d2, _2), this._add("mousePan", d2), this._add("touchPan", _2, ["touchZoom", "touchRotate"]), t2.interactive && t2.dragPan && e2.dragPan.enable(t2.dragPan);
            const p2 = new $s(), m2 = new Hs();
            e2.touchZoomRotate = new na(i2, m2, p2, l2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]), t2.interactive && t2.touchZoomRotate && e2.touchZoomRotate.enable(t2.touchZoomRotate);
            const f2 = e2.scrollZoom = new ea(e2, () => this._triggerRenderFrame());
            this._add("scrollZoom", f2, ["mousePan"]), t2.interactive && t2.scrollZoom && e2.scrollZoom.enable(t2.scrollZoom);
            const g2 = e2.keyboard = new Js(e2);
            this._add("keyboard", g2), t2.interactive && t2.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new Ps(e2));
          }
          _add(t2, e2, i2) {
            this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
          }
          stop(t2) {
            if (!this._updatingCamera) {
              for (const { handler: t3 } of this._handlers)
                t3.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t2 } of this._handlers)
              if (t2.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(ha(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t2, e2, i2) {
            for (const s2 in t2)
              if (s2 !== i2 && (!e2 || e2.indexOf(s2) < 0))
                return true;
            return false;
          }
          _getMapTouches(t2) {
            const e2 = [];
            for (const i2 of t2)
              this._el.contains(i2.target) && e2.push(i2);
            return e2;
          }
          mergeHandlerResult(t2, i2, s2, a2, o2) {
            if (!s2)
              return;
            e.e(t2, s2);
            const r2 = { handlerName: a2, originalEvent: s2.originalEvent || o2 };
            void 0 !== s2.zoomDelta && (i2.zoom = r2), void 0 !== s2.panDelta && (i2.drag = r2), void 0 !== s2.pitchDelta && (i2.pitch = r2), void 0 !== s2.bearingDelta && (i2.rotate = r2);
          }
          _applyChanges() {
            const t2 = {}, i2 = {}, s2 = {};
            for (const [a2, o2, r2] of this._changes)
              a2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(a2.panDelta)), a2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + a2.pitchDelta), void 0 !== a2.around && (t2.around = a2.around), void 0 !== a2.pinchAround && (t2.pinchAround = a2.pinchAround), a2.noInertia && (t2.noInertia = a2.noInertia), e.e(i2, o2), e.e(s2, r2);
            this._updateMapTransform(t2, i2, s2), this._changes = [];
          }
          _updateMapTransform(t2, e2, i2) {
            const s2 = this._map, a2 = s2._getTransformForUpdate(), o2 = s2.terrain;
            if (!(ua(t2) || o2 && this._terrainMovement))
              return this._fireEvents(e2, i2, true);
            let { panDelta: r2, zoomDelta: n2, bearingDelta: l2, pitchDelta: h2, around: c2, pinchAround: u2 } = t2;
            void 0 !== u2 && (c2 = u2), s2._stop(true), c2 = c2 || s2.transform.centerPoint;
            const d2 = a2.pointLocation(r2 ? c2.sub(r2) : c2);
            l2 && (a2.bearing += l2), h2 && (a2.pitch += h2), n2 && (a2.zoom += n2), o2 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? a2.center = a2.pointLocation(a2.centerPoint.sub(r2)) : a2.setLocationAtPoint(d2, c2) : (this._terrainMovement = true, this._map._elevationFreeze = true, a2.setLocationAtPoint(d2, c2), this._map.once("moveend", () => {
              this._map._elevationFreeze = false, this._terrainMovement = false, a2.recalculateZoom(s2.terrain);
            })) : a2.setLocationAtPoint(d2, c2), s2._applyUpdatedTransform(a2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
          }
          _fireEvents(t2, i2, s2) {
            const a2 = ha(this._eventsInProgress), r2 = ha(t2), n2 = {};
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._eventsInProgress[e2] || (n2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
            }
            !a2 && r2 && this._fireEvent("movestart", r2.originalEvent);
            for (const t3 in n2)
              this._fireEvent(t3, n2[t3]);
            r2 && this._fireEvent("move", r2.originalEvent);
            for (const e2 in t2) {
              const { originalEvent: i3 } = t2[e2];
              this._fireEvent(e2, i3);
            }
            const l2 = {};
            let h2;
            for (const t3 in this._eventsInProgress) {
              const { handlerName: e2, originalEvent: s3 } = this._eventsInProgress[t3];
              this._handlersById[e2].isActive() || (delete this._eventsInProgress[t3], h2 = i2[e2] || s3, l2[`${t3}end`] = h2);
            }
            for (const t3 in l2)
              this._fireEvent(t3, l2[t3]);
            const c2 = ha(this._eventsInProgress);
            if (s2 && (a2 || r2) && !c2) {
              this._updatingCamera = true;
              const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t4) => 0 !== t4 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
              !t3 || !t3.essential && o.prefersReducedMotion ? (this._map.fire(new e.k("moveend", { originalEvent: h2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), t3.freezeElevation = true, this._map.easeTo(t3, { originalEvent: h2 })), this._updatingCamera = false;
            }
          }
          _fireEvent(t2, i2) {
            this._map.fire(new e.k(t2, i2 ? { originalEvent: i2 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
              delete this._frameId, this.handleEvent(new ca("renderFrame", { timeStamp: t2 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class _a extends e.E {
          constructor(t2, e2) {
            super(), this._renderFrameCallback = () => {
              const t3 = Math.min((o.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = e2.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new e.M(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t2, e2) {
            return this.jumpTo({ center: t2 }, e2);
          }
          panBy(t2, i2, s2) {
            return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.e({ offset: t2 }, i2), s2);
          }
          panTo(t2, i2, s2) {
            return this.easeTo(e.e({ center: t2 }, i2), s2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t2, e2) {
            return this.jumpTo({ zoom: t2 }, e2), this;
          }
          zoomTo(t2, i2, s2) {
            return this.easeTo(e.e({ zoom: t2 }, i2), s2);
          }
          zoomIn(t2, e2) {
            return this.zoomTo(this.getZoom() + 1, t2, e2), this;
          }
          zoomOut(t2, e2) {
            return this.zoomTo(this.getZoom() - 1, t2, e2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t2, e2) {
            return this.jumpTo({ bearing: t2 }, e2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t2, e2) {
            return this.jumpTo({ padding: t2 }, e2), this;
          }
          rotateTo(t2, i2, s2) {
            return this.easeTo(e.e({ bearing: t2 }, i2), s2);
          }
          resetNorth(t2, i2) {
            return this.rotateTo(0, e.e({ duration: 1e3 }, t2), i2), this;
          }
          resetNorthPitch(t2, i2) {
            return this.easeTo(e.e({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
          }
          snapToNorth(t2, e2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t2, e2) {
            return this.jumpTo({ pitch: t2 }, e2), this;
          }
          cameraForBounds(t2, e2) {
            t2 = j.convert(t2);
            const i2 = e2 && e2.bearing || 0;
            return this._cameraForBoxAndBearing(t2.getNorthWest(), t2.getSouthEast(), i2, e2);
          }
          _cameraForBoxAndBearing(t2, i2, s2, a2) {
            const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (a2 = e.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding) {
              const t3 = a2.padding;
              a2.padding = { top: t3, bottom: t3, right: t3, left: t3 };
            }
            a2.padding = e.e(o2, a2.padding);
            const r2 = this.transform, n2 = r2.padding, l2 = new j(t2, i2), h2 = r2.project(l2.getNorthWest()), c2 = r2.project(l2.getNorthEast()), u2 = r2.project(l2.getSouthEast()), d2 = r2.project(l2.getSouthWest()), _2 = e.b8(-s2), p2 = h2.rotate(_2), m2 = c2.rotate(_2), f2 = u2.rotate(_2), g2 = d2.rotate(_2), v2 = new e.P(Math.max(p2.x, m2.x, g2.x, f2.x), Math.max(p2.y, m2.y, g2.y, f2.y)), x2 = new e.P(Math.min(p2.x, m2.x, g2.x, f2.x), Math.min(p2.y, m2.y, g2.y, f2.y)), y2 = v2.sub(x2), b2 = (r2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / y2.x, w2 = (r2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / y2.y;
            if (w2 < 0 || b2 < 0)
              return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const T2 = Math.min(r2.scaleZoom(r2.scale * Math.min(b2, w2)), a2.maxZoom), I2 = e.P.convert(a2.offset), E2 = new e.P((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(e.b8(s2)), C2 = I2.add(E2).mult(r2.scale / r2.zoomScale(T2));
            return { center: r2.unproject(h2.add(u2).div(2).sub(C2)), zoom: T2, bearing: s2 };
          }
          fitBounds(t2, e2, i2) {
            return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
          }
          fitScreenCoordinates(t2, i2, s2, a2, o2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(e.P.convert(t2)), this.transform.pointLocation(e.P.convert(i2)), s2, a2), a2, o2);
          }
          _fitInternal(t2, i2, s2) {
            return t2 ? (delete (i2 = e.e(t2, i2)).padding, i2.linear ? this.easeTo(i2, s2) : this.flyTo(i2, s2)) : this;
          }
          jumpTo(t2, i2) {
            this.stop();
            const s2 = this._getTransformForUpdate();
            let a2 = false, o2 = false, r2 = false;
            return "zoom" in t2 && s2.zoom !== +t2.zoom && (a2 = true, s2.zoom = +t2.zoom), void 0 !== t2.center && (s2.center = e.M.convert(t2.center)), "bearing" in t2 && s2.bearing !== +t2.bearing && (o2 = true, s2.bearing = +t2.bearing), "pitch" in t2 && s2.pitch !== +t2.pitch && (r2 = true, s2.pitch = +t2.pitch), null == t2.padding || s2.isPaddingEqual(t2.padding) || (s2.padding = t2.padding), this._applyUpdatedTransform(s2), this.fire(new e.k("movestart", i2)).fire(new e.k("move", i2)), a2 && this.fire(new e.k("zoomstart", i2)).fire(new e.k("zoom", i2)).fire(new e.k("zoomend", i2)), o2 && this.fire(new e.k("rotatestart", i2)).fire(new e.k("rotate", i2)).fire(new e.k("rotateend", i2)), r2 && this.fire(new e.k("pitchstart", i2)).fire(new e.k("pitch", i2)).fire(new e.k("pitchend", i2)), this.fire(new e.k("moveend", i2));
          }
          calculateCameraOptionsFromTo(t2, i2, s2, a2 = 0) {
            const o2 = e.Y.fromLngLat(t2, i2), r2 = e.Y.fromLngLat(s2, a2), n2 = r2.x - o2.x, l2 = r2.y - o2.y, h2 = r2.z - o2.z, c2 = Math.hypot(n2, l2, h2);
            if (0 === c2)
              throw new Error("Can't calculate camera options with same From and To");
            const u2 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l2) / Math.PI;
            let p2 = 180 * Math.acos(u2 / c2) / Math.PI;
            return p2 = h2 < 0 ? 90 - p2 : 90 + p2, { center: r2.toLngLat(), zoom: d2, pitch: p2, bearing: _2 };
          }
          easeTo(t2, i2) {
            var s2;
            this._stop(false, t2.easeId), (false === (t2 = e.e({ offset: [0, 0], duration: 500, easing: e.b7 }, t2)).animate || !t2.essential && o.prefersReducedMotion) && (t2.duration = 0);
            const a2 = this._getTransformForUpdate(), r2 = this.getZoom(), n2 = this.getBearing(), l2 = this.getPitch(), h2 = this.getPadding(), c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : a2.padding, _2 = e.P.convert(t2.offset);
            let p2 = a2.centerPoint.add(_2);
            const m2 = a2.pointLocation(p2), { center: f2, zoom: g2 } = a2.getConstrained(e.M.convert(t2.center || m2), null !== (s2 = t2.zoom) && void 0 !== s2 ? s2 : r2);
            this._normalizeCenter(f2);
            const v2 = a2.project(m2), x2 = a2.project(f2).sub(v2), y2 = a2.zoomScale(g2 - r2);
            let b2, w2;
            t2.around && (b2 = e.M.convert(t2.around), w2 = a2.locationPoint(b2));
            const T2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || g2 !== r2, this._rotating = this._rotating || n2 !== c2, this._pitching = this._pitching || u2 !== l2, this._padding = !a2.isPaddingEqual(d2), this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, T2), this.terrain && this._prepareElevation(f2), this._ease((s3) => {
              if (this._zooming && (a2.zoom = e.z.number(r2, g2, s3)), this._rotating && (a2.bearing = e.z.number(n2, c2, s3)), this._pitching && (a2.pitch = e.z.number(l2, u2, s3)), this._padding && (a2.interpolatePadding(h2, d2, s3), p2 = a2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(s3), b2)
                a2.setLocationAtPoint(b2, w2);
              else {
                const t3 = a2.zoomScale(a2.zoom - r2), e2 = g2 > r2 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(e2, 1 - s3), o2 = a2.unproject(v2.add(x2.mult(s3 * i3)).mult(t3));
                a2.setLocationAtPoint(a2.renderWorldCopies ? o2.wrap() : o2, p2);
              }
              this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
            }, (t3) => {
              this.terrain && this._finalizeElevation(), this._afterEase(i2, t3);
            }, t2), this;
          }
          _prepareEase(t2, i2, s2 = {}) {
            this._moving = true, i2 || s2.moving || this.fire(new e.k("movestart", t2)), this._zooming && !s2.zooming && this.fire(new e.k("zoomstart", t2)), this._rotating && !s2.rotating && this.fire(new e.k("rotatestart", t2)), this._pitching && !s2.pitching && this.fire(new e.k("pitchstart", t2));
          }
          _prepareElevation(t2) {
            this._elevationCenter = t2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t2, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(t2) {
            this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t2 < 1 && i2 !== this._elevationTarget) {
              const e2 = this._elevationTarget - this._elevationStart;
              this._elevationStart += t2 * (e2 - (i2 - (e2 * t2 + this._elevationStart)) / (1 - t2)), this._elevationTarget = i2;
            }
            this.transform.elevation = e.z.number(this._elevationStart, this._elevationTarget, t2);
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _applyUpdatedTransform(t2) {
            if (!this.transformCameraUpdate)
              return;
            const e2 = t2.clone(), { center: i2, zoom: s2, pitch: a2, bearing: o2, elevation: r2 } = this.transformCameraUpdate(e2);
            i2 && (e2.center = i2), void 0 !== s2 && (e2.zoom = s2), void 0 !== a2 && (e2.pitch = a2), void 0 !== o2 && (e2.bearing = o2), void 0 !== r2 && (e2.elevation = r2), this.transform.apply(e2);
          }
          _fireMoveEvents(t2) {
            this.fire(new e.k("move", t2)), this._zooming && this.fire(new e.k("zoom", t2)), this._rotating && this.fire(new e.k("rotate", t2)), this._pitching && this.fire(new e.k("pitch", t2));
          }
          _afterEase(t2, i2) {
            if (this._easeId && i2 && this._easeId === i2)
              return;
            delete this._easeId;
            const s2 = this._zooming, a2 = this._rotating, o2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s2 && this.fire(new e.k("zoomend", t2)), a2 && this.fire(new e.k("rotateend", t2)), o2 && this.fire(new e.k("pitchend", t2)), this.fire(new e.k("moveend", t2));
          }
          flyTo(t2, i2) {
            var s2;
            if (!t2.essential && o.prefersReducedMotion) {
              const s3 = e.L(t2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(s3, i2);
            }
            this.stop(), t2 = e.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.b7 }, t2);
            const a2 = this._getTransformForUpdate(), r2 = this.getZoom(), n2 = this.getBearing(), l2 = this.getPitch(), h2 = this.getPadding(), c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : a2.padding, _2 = e.P.convert(t2.offset);
            let p2 = a2.centerPoint.add(_2);
            const m2 = a2.pointLocation(p2), { center: f2, zoom: g2 } = a2.getConstrained(e.M.convert(t2.center || m2), null !== (s2 = t2.zoom) && void 0 !== s2 ? s2 : r2);
            this._normalizeCenter(f2);
            const v2 = a2.zoomScale(g2 - r2), x2 = a2.project(m2), y2 = a2.project(f2).sub(x2);
            let b2 = t2.curve;
            const w2 = Math.max(a2.width, a2.height), T2 = w2 / v2, I2 = y2.mag();
            if ("minZoom" in t2) {
              const i3 = e.ac(Math.min(t2.minZoom, r2, g2), a2.minZoom, a2.maxZoom), s3 = w2 / a2.zoomScale(i3 - r2);
              b2 = Math.sqrt(s3 / I2 * 2);
            }
            const E2 = b2 * b2;
            function C2(t3) {
              const e2 = (T2 * T2 - w2 * w2 + (t3 ? -1 : 1) * E2 * E2 * I2 * I2) / (2 * (t3 ? T2 : w2) * E2 * I2);
              return Math.log(Math.sqrt(e2 * e2 + 1) - e2);
            }
            function S2(t3) {
              return (Math.exp(t3) - Math.exp(-t3)) / 2;
            }
            function P2(t3) {
              return (Math.exp(t3) + Math.exp(-t3)) / 2;
            }
            const D2 = C2(false);
            let z2 = function(t3) {
              return P2(D2) / P2(D2 + b2 * t3);
            }, M2 = function(t3) {
              return w2 * ((P2(D2) * (S2(e2 = D2 + b2 * t3) / P2(e2)) - S2(D2)) / E2) / I2;
              var e2;
            }, A2 = (C2(true) - D2) / b2;
            if (Math.abs(I2) < 1e-6 || !isFinite(A2)) {
              if (Math.abs(w2 - T2) < 1e-6)
                return this.easeTo(t2, i2);
              const e2 = T2 < w2 ? -1 : 1;
              A2 = Math.abs(Math.log(T2 / w2)) / b2, M2 = function() {
                return 0;
              }, z2 = function(t3) {
                return Math.exp(e2 * b2 * t3);
              };
            }
            return t2.duration = "duration" in t2 ? +t2.duration : 1e3 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / b2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0), this._zooming = true, this._rotating = n2 !== c2, this._pitching = u2 !== l2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2), this._ease((s3) => {
              const o2 = s3 * A2, m3 = 1 / z2(o2);
              a2.zoom = 1 === s3 ? g2 : r2 + a2.scaleZoom(m3), this._rotating && (a2.bearing = e.z.number(n2, c2, s3)), this._pitching && (a2.pitch = e.z.number(l2, u2, s3)), this._padding && (a2.interpolatePadding(h2, d2, s3), p2 = a2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(s3);
              const v3 = 1 === s3 ? f2 : a2.unproject(x2.add(y2.mult(M2(o2))).mult(m3));
              a2.setLocationAtPoint(a2.renderWorldCopies ? v3.wrap() : v3, p2), this._applyUpdatedTransform(a2), this._fireMoveEvents(i2);
            }, () => {
              this.terrain && this._finalizeElevation(), this._afterEase(i2);
            }, t2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t2, e2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t3 = this._onEaseEnd;
              delete this._onEaseEnd, t3.call(this, e2);
            }
            if (!t2) {
              const t3 = this.handlers;
              t3 && t3.stop(false);
            }
            return this;
          }
          _ease(t2, e2, i2) {
            false === i2.animate || 0 === i2.duration ? (t2(1), e2()) : (this._easeStart = o.now(), this._easeOptions = i2, this._onEaseFrame = t2, this._onEaseEnd = e2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t2, i2) {
            t2 = e.b1(t2, -180, 180);
            const s2 = Math.abs(t2 - i2);
            return Math.abs(t2 - 360 - i2) < s2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < s2 && (t2 += 360), t2;
          }
          _normalizeCenter(t2) {
            const e2 = this.transform;
            if (!e2.renderWorldCopies || e2.lngRange)
              return;
            const i2 = t2.lng - e2.center.lng;
            t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          queryTerrainElevation(t2) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(e.M.convert(t2), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        const pa = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class ma {
          constructor(t2 = pa) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (t3) => {
              !t3 || "metadata" !== t3.sourceDataType && "visibility" !== t3.sourceDataType && "style" !== t3.dataType && "terrain" !== t3.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t2;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t2) {
            return this._map = t2, this._compact = this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t2, e2) {
            const i2 = this._map._getUIString(`AttributionControl.${e2}`);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let t2 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => "string" != typeof t3 ? "" : t3)) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t3 = this._map.style.stylesheet;
              this.styleOwner = t3.owner, this.styleId = t3.id;
            }
            const e2 = this._map.style.sourceCaches;
            for (const i3 in e2) {
              const s2 = e2[i3];
              if (s2.used || s2.usedForTerrain) {
                const e3 = s2.getSource();
                e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
              }
            }
            t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
              for (let s2 = i3 + 1; s2 < t2.length; s2++)
                if (t2[s2].indexOf(e3) >= 0)
                  return false;
              return true;
            });
            const i2 = t2.join(" | ");
            i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class fa {
          constructor(t2 = {}) {
            this._updateCompact = () => {
              const t3 = this._container.children;
              if (t3.length) {
                const e2 = t3[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
              }
            }, this.options = t2;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl");
            const e2 = r.create("a", "maplibregl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class ga {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t2) {
            const e2 = ++this._id;
            return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
          }
          remove(t2) {
            const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
            for (const e3 of i2)
              if (e3.id === t2)
                return void (e3.cancelled = true);
          }
          run(t2 = 0) {
            if (this._currentlyRunning)
              throw new Error("Attempting to run(), but is already running.");
            const e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i2 of e2)
              if (!i2.cancelled && (i2.callback(t2), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var va = e.X([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class xa extends e.E {
          constructor(t2) {
            super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(t2, i2) {
            this.sourceCache.update(t2, i2), this._renderableTilesKeys = [];
            const s2 = {};
            for (const a2 of t2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2 }))
              s2[a2.key] = true, this._renderableTilesKeys.push(a2.key), this._tiles[a2.key] || (a2.posMatrix = new Float64Array(16), e.aN(a2.posMatrix, 0, e.W, 0, e.W, 0, 1), this._tiles[a2.key] = new rt(a2, this.tileSize));
            for (const t3 in this._tiles)
              s2[t3] || delete this._tiles[t3];
          }
          freeRtt(t2) {
            for (const e2 in this._tiles) {
              const i2 = this._tiles[e2];
              (!t2 || i2.tileID.equals(t2) || i2.tileID.isChildOf(t2) || t2.isChildOf(i2.tileID)) && (i2.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
          }
          getTileByID(t2) {
            return this._tiles[t2];
          }
          getTerrainCoords(t2) {
            const i2 = {};
            for (const s2 of this._renderableTilesKeys) {
              const a2 = this._tiles[s2].tileID;
              if (a2.canonical.equals(t2.canonical)) {
                const a3 = t2.clone();
                a3.posMatrix = new Float64Array(16), e.aN(a3.posMatrix, 0, e.W, 0, e.W, 0, 1), i2[s2] = a3;
              } else if (a2.canonical.isChildOf(t2.canonical)) {
                const o2 = t2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = a2.canonical.z - t2.canonical.z, n2 = a2.canonical.x - (a2.canonical.x >> r2 << r2), l2 = a2.canonical.y - (a2.canonical.y >> r2 << r2), h2 = e.W >> r2;
                e.aN(o2.posMatrix, 0, h2, 0, h2, 0, 1), e.H(o2.posMatrix, o2.posMatrix, [-n2 * h2, -l2 * h2, 0]), i2[s2] = o2;
              } else if (t2.canonical.isChildOf(a2.canonical)) {
                const o2 = t2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = t2.canonical.z - a2.canonical.z, n2 = t2.canonical.x - (t2.canonical.x >> r2 << r2), l2 = t2.canonical.y - (t2.canonical.y >> r2 << r2), h2 = e.W >> r2;
                e.aN(o2.posMatrix, 0, e.W, 0, e.W, 0, 1), e.H(o2.posMatrix, o2.posMatrix, [n2 * h2, l2 * h2, 0]), e.J(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i2[s2] = o2;
              }
            }
            return i2;
          }
          getSourceTile(t2, e2) {
            const i2 = this.sourceCache._source;
            let s2 = t2.overscaledZ - this.deltaZoom;
            if (s2 > i2.maxzoom && (s2 = i2.maxzoom), s2 < i2.minzoom)
              return null;
            this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(s2).key);
            let a2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
            if ((!a2 || !a2.dem) && e2)
              for (; s2 >= i2.minzoom && (!a2 || !a2.dem); )
                a2 = this.sourceCache.getTileByID(t2.scaledTo(s2--).key);
            return a2;
          }
          tilesAfterTime(t2 = Date.now()) {
            return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t2);
          }
        }
        class ya {
          constructor(t2, e2, i2) {
            this.painter = t2, this.sourceCache = new xa(e2), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t2, i2, s2, a2 = e.W) {
            var o2;
            if (!(i2 >= 0 && i2 < a2 && s2 >= 0 && s2 < a2))
              return 0;
            const r2 = this.getTerrainData(t2), n2 = null === (o2 = r2.tile) || void 0 === o2 ? void 0 : o2.dem;
            if (!n2)
              return 0;
            const l2 = function(t3, e2, i3) {
              var s3 = e2[0], a3 = e2[1];
              return t3[0] = i3[0] * s3 + i3[4] * a3 + i3[12], t3[1] = i3[1] * s3 + i3[5] * a3 + i3[13], t3;
            }([], [i2 / a2 * e.W, s2 / a2 * e.W], r2.u_terrain_matrix), h2 = [l2[0] * n2.dim, l2[1] * n2.dim], c2 = Math.floor(h2[0]), u2 = Math.floor(h2[1]), d2 = h2[0] - c2, _2 = h2[1] - u2;
            return n2.get(c2, u2) * (1 - d2) * (1 - _2) + n2.get(c2 + 1, u2) * d2 * (1 - _2) + n2.get(c2, u2 + 1) * (1 - d2) * _2 + n2.get(c2 + 1, u2 + 1) * d2 * _2;
          }
          getElevationForLngLatZoom(t2, i2) {
            const { tileID: s2, mercatorX: a2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(t2, i2);
            return this.getElevation(s2, a2 % e.W, o2 % e.W, e.W);
          }
          getElevation(t2, i2, s2, a2 = e.W) {
            return this.getDEMElevation(t2, i2, s2, a2) * this.exaggeration;
          }
          getTerrainData(t2) {
            if (!this._emptyDemTexture) {
              const t3 = this.painter.context, i3 = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new b(t3, i3, t3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new b(t3, new e.R({ width: 1, height: 1 }), t3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = e.an([]);
            }
            const i2 = this.sourceCache.getSourceTile(t2, true);
            if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
              const t3 = this.painter.context;
              i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new b(t3, i2.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
            }
            const s2 = i2 && i2 + i2.tileID.key + t2.key;
            if (s2 && !this._demMatrixCache[s2]) {
              const s3 = this.sourceCache.sourceCache._source.maxzoom;
              let a2 = t2.canonical.z - i2.tileID.canonical.z;
              t2.overscaledZ > t2.canonical.z && (t2.canonical.z >= s3 ? a2 = t2.canonical.z - s3 : e.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o2 = t2.canonical.x - (t2.canonical.x >> a2 << a2), r2 = t2.canonical.y - (t2.canonical.y >> a2 << a2), n2 = e.b9(new Float64Array(16), [1 / (e.W << a2), 1 / (e.W << a2), 0]);
              e.H(n2, n2, [o2 * e.W, r2 * e.W, 0]), this._demMatrixCache[t2.key] = { matrix: n2, coord: t2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: s2 ? this._demMatrixCache[t2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
          }
          getFramebuffer(t2) {
            const e2 = this.painter, i2 = e2.width / devicePixelRatio, s2 = e2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i2 && this._fbo.height === s2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new b(e2.context, { width: i2, height: s2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new b(e2.context, { width: i2, height: s2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, s2, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, s2))), this._fbo.colorAttachment.set("coords" === t2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t2 = this.painter.context;
            if (this._coordsTexture)
              return this._coordsTexture;
            const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t3 = 0, e2 = 0; t3 < this._coordsTextureSize; t3++)
              for (let s3 = 0; s3 < this._coordsTextureSize; s3++, e2 += 4)
                i2[e2 + 0] = 255 & s3, i2[e2 + 1] = 255 & t3, i2[e2 + 2] = s3 >> 8 << 4 | t3 >> 8, i2[e2 + 3] = 0;
            const s2 = new e.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), a2 = new b(t2, s2, t2.gl.RGBA, { premultiply: false });
            return a2.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), this._coordsTexture = a2, a2;
          }
          pointCoordinate(t2) {
            this.painter.maybeDrawDepthAndCoords(true);
            const i2 = new Uint8Array(4), s2 = this.painter.context, a2 = s2.gl, o2 = Math.round(t2.x * this.painter.pixelRatio / devicePixelRatio), r2 = Math.round(t2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
            s2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a2.readPixels(o2, n2 - r2 - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, i2), s2.bindFramebuffer.set(null);
            const l2 = i2[0] + (i2[2] >> 4 << 8), h2 = i2[1] + ((15 & i2[2]) << 8), c2 = this.coordsIndex[255 - i2[3]], u2 = c2 && this.sourceCache.getTileByID(c2);
            if (!u2)
              return null;
            const d2 = this._coordsTextureSize, _2 = (1 << u2.tileID.canonical.z) * d2;
            return new e.Y((u2.tileID.canonical.x * d2 + l2) / _2 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + h2) / _2, this.getElevation(u2.tileID, l2, h2, d2));
          }
          depthAtPoint(t2) {
            const e2 = new Uint8Array(4), i2 = this.painter.context, s2 = i2.gl;
            return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), s2.readPixels(t2.x, this.painter.height / devicePixelRatio - t2.y - 1, 1, 1, s2.RGBA, s2.UNSIGNED_BYTE, e2), i2.bindFramebuffer.set(null), (e2[0] / 16777216 + e2[1] / 65536 + e2[2] / 256 + e2[3]) / 256;
          }
          getTerrainMesh() {
            if (this._mesh)
              return this._mesh;
            const t2 = this.painter.context, i2 = new e.ba(), s2 = new e.aX(), a2 = this.meshSize, o2 = e.W / a2, r2 = a2 * a2;
            for (let t3 = 0; t3 <= a2; t3++)
              for (let e2 = 0; e2 <= a2; e2++)
                i2.emplaceBack(e2 * o2, t3 * o2, 0);
            for (let t3 = 0; t3 < r2; t3 += a2 + 1)
              for (let e2 = 0; e2 < a2; e2++)
                s2.emplaceBack(e2 + t3, a2 + e2 + t3 + 1, a2 + e2 + t3 + 2), s2.emplaceBack(e2 + t3, a2 + e2 + t3 + 2, e2 + t3 + 1);
            const n2 = i2.length, l2 = n2 + 2 * (a2 + 1);
            for (const t3 of [0, 1])
              for (let s3 = 0; s3 <= a2; s3++)
                for (const a3 of [0, 1])
                  i2.emplaceBack(s3 * o2, t3 * e.W, a3);
            for (let t3 = 0; t3 < 2 * a2; t3 += 2)
              s2.emplaceBack(l2 + t3, l2 + t3 + 1, l2 + t3 + 3), s2.emplaceBack(l2 + t3, l2 + t3 + 3, l2 + t3 + 2), s2.emplaceBack(n2 + t3, n2 + t3 + 3, n2 + t3 + 1), s2.emplaceBack(n2 + t3, n2 + t3 + 2, n2 + t3 + 3);
            const h2 = i2.length, c2 = h2 + 2 * (a2 + 1);
            for (const t3 of [0, 1])
              for (let s3 = 0; s3 <= a2; s3++)
                for (const a3 of [0, 1])
                  i2.emplaceBack(t3 * e.W, s3 * o2, a3);
            for (let t3 = 0; t3 < 2 * a2; t3 += 2)
              s2.emplaceBack(h2 + t3, h2 + t3 + 1, h2 + t3 + 3), s2.emplaceBack(h2 + t3, h2 + t3 + 3, h2 + t3 + 2), s2.emplaceBack(c2 + t3, c2 + t3 + 3, c2 + t3 + 1), s2.emplaceBack(c2 + t3, c2 + t3 + 2, c2 + t3 + 3);
            return this._mesh = { indexBuffer: t2.createIndexBuffer(s2), vertexBuffer: t2.createVertexBuffer(i2, va.members), segments: e.$.simpleSegment(0, 0, i2.length, s2.length) }, this._mesh;
          }
          getMeshFrameDelta(t2) {
            return 2 * Math.PI * e.bb / Math.pow(2, t2) / 5;
          }
          getMinTileElevationForLngLatZoom(t2, e2) {
            var i2;
            const { tileID: s2 } = this._getOverscaledTileIDFromLngLatZoom(t2, e2);
            return null !== (i2 = this.getMinMaxElevation(s2).minElevation) && void 0 !== i2 ? i2 : 0;
          }
          getMinMaxElevation(t2) {
            const e2 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
            return e2 && e2.dem && (i2.minElevation = e2.dem.min * this.exaggeration, i2.maxElevation = e2.dem.max * this.exaggeration), i2;
          }
          _getOverscaledTileIDFromLngLatZoom(t2, i2) {
            const s2 = e.Y.fromLngLat(t2.wrap()), a2 = (1 << i2) * e.W, o2 = s2.x * a2, r2 = s2.y * a2, n2 = Math.floor(o2 / e.W), l2 = Math.floor(r2 / e.W);
            return { tileID: new e.Q(i2, 0, i2, n2, l2), mercatorX: o2, mercatorY: r2 };
          }
        }
        class ba {
          constructor(t2, e2, i2) {
            this._context = t2, this._size = e2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t2 of this._objects)
              t2.texture.destroy(), t2.fbo.destroy();
          }
          _createObject(t2) {
            const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new b(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i2.texture), { id: t2, fbo: e2, texture: i2, stamp: -1, inUse: false };
          }
          getObjectForId(t2) {
            return this._objects[t2];
          }
          useObject(t2) {
            t2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t2.id !== e2), this._recentlyUsed.push(t2.id);
          }
          stampObject(t2) {
            t2.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t3 of this._recentlyUsed)
              if (!this._objects[t3].inUse)
                return this._objects[t3];
            if (this._objects.length >= this._size)
              throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t2 = this._createObject(this._objects.length);
            return this._objects.push(t2), t2;
          }
          freeObject(t2) {
            t2.inUse = false;
          }
          freeAllObjects() {
            for (const t2 of this._objects)
              this.freeObject(t2);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((t2) => !t2.inUse);
          }
        }
        const wa = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class Ta {
          constructor(t2, e2) {
            this.painter = t2, this.terrain = e2, this.pool = new ba(t2.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t2) {
            return this.pool.getObjectForId(t2.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t2, e2) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t2._order.filter((i2) => !t2._layers[i2].isHidden(e2)), this._coordsDescendingInv = {};
            for (const e3 in t2.sourceCaches) {
              this._coordsDescendingInv[e3] = {};
              const i2 = t2.sourceCaches[e3].getVisibleCoordinates();
              for (const t3 of i2) {
                const i3 = this.terrain.sourceCache.getTerrainCoords(t3);
                for (const t4 in i3)
                  this._coordsDescendingInv[e3][t4] || (this._coordsDescendingInv[e3][t4] = []), this._coordsDescendingInv[e3][t4].push(i3[t4]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const e3 of t2._order) {
              const i2 = t2._layers[e3], s2 = i2.source;
              if (wa[i2.type] && !this._coordsDescendingInvStr[s2]) {
                this._coordsDescendingInvStr[s2] = {};
                for (const t3 in this._coordsDescendingInv[s2])
                  this._coordsDescendingInvStr[s2][t3] = this._coordsDescendingInv[s2][t3].map((t4) => t4.key).sort().join();
              }
            }
            for (const t3 of this._renderableTiles)
              for (const e3 in this._coordsDescendingInvStr) {
                const i2 = this._coordsDescendingInvStr[e3][t3.tileID.key];
                i2 && i2 !== t3.rttCoords[e3] && (t3.rtt = []);
              }
          }
          renderLayer(t2) {
            if (t2.isHidden(this.painter.transform.zoom))
              return false;
            const i2 = t2.type, s2 = this.painter, a2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t2.id;
            if (wa[i2] && (this._prevType && wa[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(t2.id), !a2))
              return true;
            if (wa[this._prevType] || wa[i2] && a2) {
              this._prevType = i2;
              const t3 = this._stacks.length - 1, a3 = this._stacks[t3] || [];
              for (const i3 of this._renderableTiles) {
                if (this.pool.isFull() && (ns(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i3), i3.rtt[t3]) {
                  const e2 = this.pool.getObjectForId(i3.rtt[t3].id);
                  if (e2.stamp === i3.rtt[t3].stamp) {
                    this.pool.useObject(e2);
                    continue;
                  }
                }
                const o2 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(o2), this.pool.stampObject(o2), i3.rtt[t3] = { id: o2.id, stamp: o2.stamp }, s2.context.bindFramebuffer.set(o2.fbo.framebuffer), s2.context.clear({ color: e.aO.transparent, stencil: 0 }), s2.currentStencilSource = void 0;
                for (let t4 = 0; t4 < a3.length; t4++) {
                  const e2 = s2.style._layers[a3[t4]], r2 = e2.source ? this._coordsDescendingInv[e2.source][i3.tileID.key] : [i3.tileID];
                  s2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), s2._renderTileClippingMasks(e2, r2), s2.renderLayer(s2, s2.style.sourceCaches[e2.source], e2, r2), e2.source && (i3.rttCoords[e2.source] = this._coordsDescendingInvStr[e2.source][i3.tileID.key]);
                }
              }
              return ns(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), wa[i2];
            }
            return false;
          }
        }
        const Ia = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Ea = i, Ca = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: pa, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, Sa = (t2) => {
          t2.touchstart = t2.dragStart, t2.touchmoveWindow = t2.dragMove, t2.touchend = t2.dragEnd;
        }, Pa = { showCompass: true, showZoom: true, visualizePitch: false };
        class Da {
          constructor(t2, i2, s2 = false) {
            this.mousedown = (t3) => {
              this.startMouse(e.e({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), r.mousePos(this.element, t3)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (t3) => {
              this.moveMouse(t3, r.mousePos(this.element, t3));
            }, this.mouseup = (t3) => {
              this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
            }, this.touchstart = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), r.addEventListener(window, "touchmove", this.touchmove, { passive: false }), r.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (t3) => {
              1 !== t3.targetTouches.length ? this.reset() : (this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
            }, this.touchend = (t3) => {
              0 === t3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            const a2 = t2.dragRotate._mouseRotate.getClickTolerance(), o2 = t2.dragRotate._mousePitch.getClickTolerance();
            this.element = i2, this.mouseRotate = Us({ clickTolerance: a2, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e2, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
              const s3 = new Os();
              return new ks({ clickTolerance: e2, move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * i3 }), moveStateManager: s3, enable: t3, assignEvents: Sa });
            })({ clickTolerance: a2, enable: true }), this.map = t2, s2 && (this.mousePitch = Zs({ clickTolerance: o2, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e2, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
              const s3 = new Os();
              return new ks({ clickTolerance: e2, move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * i3 }), moveStateManager: s3, enable: t3, assignEvents: Sa });
            })({ clickTolerance: o2, enable: true })), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), r.addEventListener(i2, "touchcancel", this.reset);
          }
          startMouse(t2, e2) {
            this.mouseRotate.dragStart(t2, e2), this.mousePitch && this.mousePitch.dragStart(t2, e2), r.disableDrag();
          }
          startTouch(t2, e2) {
            this.touchRotate.dragStart(t2, e2), this.touchPitch && this.touchPitch.dragStart(t2, e2), r.disableDrag();
          }
          moveMouse(t2, e2) {
            const i2 = this.map, { bearingDelta: s2 } = this.mouseRotate.dragMove(t2, e2) || {};
            if (s2 && i2.setBearing(i2.getBearing() + s2), this.mousePitch) {
              const { pitchDelta: s3 } = this.mousePitch.dragMove(t2, e2) || {};
              s3 && i2.setPitch(i2.getPitch() + s3);
            }
          }
          moveTouch(t2, e2) {
            const i2 = this.map, { bearingDelta: s2 } = this.touchRotate.dragMove(t2, e2) || {};
            if (s2 && i2.setBearing(i2.getBearing() + s2), this.touchPitch) {
              const { pitchDelta: s3 } = this.touchPitch.dragMove(t2, e2) || {};
              s3 && i2.setPitch(i2.getPitch() + s3);
            }
          }
          off() {
            const t2 = this.element;
            r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let za;
        function Ma(t2, i2, s2) {
          const a2 = new e.M(t2.lng, t2.lat);
          if (t2 = new e.M(t2.lng, t2.lat), i2) {
            const a3 = new e.M(t2.lng - 360, t2.lat), o2 = new e.M(t2.lng + 360, t2.lat), r2 = s2.locationPoint(t2).distSqr(i2);
            s2.locationPoint(a3).distSqr(i2) < r2 ? t2 = a3 : s2.locationPoint(o2).distSqr(i2) < r2 && (t2 = o2);
          }
          for (; Math.abs(t2.lng - s2.center.lng) > 180; ) {
            const e2 = s2.locationPoint(t2);
            if (e2.x >= 0 && e2.y >= 0 && e2.x <= s2.width && e2.y <= s2.height)
              break;
            t2.lng > s2.center.lng ? t2.lng -= 360 : t2.lng += 360;
          }
          return t2.lng !== a2.lng && s2.locationPoint(t2).y > s2.height / 2 - s2.getHorizon() ? t2 : a2;
        }
        const Aa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Ra(t2, e2, i2) {
          const s2 = t2.classList;
          for (const t3 in Aa)
            s2.remove(`maplibregl-${i2}-anchor-${t3}`);
          s2.add(`maplibregl-${i2}-anchor-${e2}`);
        }
        class La extends e.E {
          constructor(t2) {
            if (super(), this._onKeyPress = (t3) => {
              const e2 = t3.code, i2 = t3.charCode || t3.keyCode;
              "Space" !== e2 && "Enter" !== e2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }, this._onMapClick = (t3) => {
              const e2 = t3.originalEvent.target, i2 = this._element;
              this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
            }, this._update = (t3) => {
              var e2;
              if (!this._map)
                return;
              const i2 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == t3 ? void 0 : t3.type) || "render" === (null == t3 ? void 0 : t3.type) && !i2) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Ma(this._lngLat, this._flatPos, this._map.transform) : null === (e2 = this._lngLat) || void 0 === e2 ? void 0 : e2.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
              let s2 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let a2 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a2 = `rotateX(${this._map.getPitch()}deg)`), t3 && "moveend" !== t3.type || (this._pos = this._pos.round()), r.setTransform(this._element, `${Aa[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a2} ${s2}`), o.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(t3 && "moveend" === t3.type);
              }).catch(() => {
              });
            }, this._onMove = (t3) => {
              if (!this._isDragging) {
                const e2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = t3.point.dist(this._pointerdownPos) >= e2;
              }
              this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.k("dragstart"))), this.fire(new e.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new e.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (t3) => {
              this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && "auto" !== t2.pitchAlignment ? t2.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(null == t2 ? void 0 : t2.opacity, null == t2 ? void 0 : t2.opacityWhenCovered), t2 && t2.element)
              this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = r.create("div"), this._element.setAttribute("aria-label", "Map marker");
              const i2 = r.createNS("http://www.w3.org/2000/svg", "svg"), s2 = 41, a2 = 27;
              i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${s2}px`), i2.setAttributeNS(null, "width", `${a2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${a2} ${s2}`);
              const o2 = r.createNS("http://www.w3.org/2000/svg", "g");
              o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
              const n2 = r.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "fill-rule", "nonzero");
              const l2 = r.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              const h2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t3 of h2) {
                const e2 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
                e2.setAttributeNS(null, "opacity", "0.04"), e2.setAttributeNS(null, "cx", "10.5"), e2.setAttributeNS(null, "cy", "5.80029008"), e2.setAttributeNS(null, "rx", t3.rx), e2.setAttributeNS(null, "ry", t3.ry), l2.appendChild(e2);
              }
              const c2 = r.createNS("http://www.w3.org/2000/svg", "g");
              c2.setAttributeNS(null, "fill", this._color);
              const u2 = r.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
              const d2 = r.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const _2 = r.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
              const p2 = r.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
              const m2 = r.createNS("http://www.w3.org/2000/svg", "g");
              m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              const g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), n2.appendChild(l2), n2.appendChild(c2), n2.appendChild(d2), n2.appendChild(p2), n2.appendChild(m2), i2.appendChild(n2), i2.setAttributeNS(null, "height", s2 * this._scale + "px"), i2.setAttributeNS(null, "width", a2 * this._scale + "px"), this._element.appendChild(i2), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
              t3.preventDefault();
            }), this._element.addEventListener("mousedown", (t3) => {
              t3.preventDefault();
            }), Ra(this._element, this._anchor, "marker"), t2 && t2.className)
              for (const e2 of t2.className.split(" "))
                this._element.classList.add(e2);
            this._popup = null;
          }
          addTo(t2) {
            return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), t2.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.M.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t2) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
              if (!("offset" in t2.options)) {
                const e2 = 38.1, i2 = 13.5, s2 = Math.abs(i2) / Math.SQRT2;
                t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [s2, -1 * (e2 - i2 + s2)], "bottom-right": [-s2, -1 * (e2 - i2 + s2)], left: [i2, -1 * (e2 - i2)], right: [-i2, -1 * (e2 - i2)] } : this._offset;
              }
              this._popup = t2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t2 = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : t2 ? (t2.isOpen() ? t2.remove() : (t2.setLngLat(this._lngLat), t2.addTo(this._map)), this) : this;
          }
          _updateOpacity(t2 = false) {
            var i2, s2;
            if (!(null === (i2 = this._map) || void 0 === i2 ? void 0 : i2.terrain))
              return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
            if (t2)
              this._opacityTimeout = null;
            else {
              if (this._opacityTimeout)
                return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const a2 = this._map, o2 = a2.terrain.depthAtPoint(this._pos), r2 = a2.terrain.getElevationForLngLatZoom(this._lngLat, a2.transform.tileZoom);
            if (a2.transform.lngLatToCameraDepth(this._lngLat, r2) - o2 < 6e-3)
              return void (this._element.style.opacity = this._opacity);
            const n2 = -this._offset.y / a2.transform._pixelPerMeter, l2 = Math.sin(a2.getPitch() * Math.PI / 180) * n2, h2 = a2.terrain.depthAtPoint(new e.P(this._pos.x, this._pos.y - this._offset.y)), c2 = a2.transform.lngLatToCameraDepth(this._lngLat, r2 + l2) - h2 > 6e-3;
            (null === (s2 = this._popup) || void 0 === s2 ? void 0 : s2.isOpen()) && c2 && this._popup.remove(), this._element.style.opacity = c2 ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t2) {
            return this._offset = e.P.convert(t2), this._update(), this;
          }
          addClassName(t2) {
            this._element.classList.add(t2);
          }
          removeClassName(t2) {
            this._element.classList.remove(t2);
          }
          toggleClassName(t2) {
            return this._element.classList.toggle(t2);
          }
          setDraggable(t2) {
            return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t2) {
            return this._rotation = t2 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t2) {
            return this._rotationAlignment = t2 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t2) {
            return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t2, e2) {
            return void 0 === t2 && void 0 === e2 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== t2 && (this._opacity = t2), void 0 !== e2 && (this._opacityWhenCovered = e2), this._map && this._updateOpacity(true), this;
          }
        }
        const ka = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Fa = 0, Ba = false;
        const Oa = { maxWidth: 100, unit: "metric" };
        function Na(t2, e2, i2) {
          const s2 = i2 && i2.maxWidth || 100, a2 = t2._container.clientHeight / 2, o2 = t2.unproject([0, a2]), r2 = t2.unproject([s2, a2]), n2 = o2.distanceTo(r2);
          if (i2 && "imperial" === i2.unit) {
            const i3 = 3.2808 * n2;
            i3 > 5280 ? Ua(e2, s2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : Ua(e2, s2, i3, t2._getUIString("ScaleControl.Feet"));
          } else
            i2 && "nautical" === i2.unit ? Ua(e2, s2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? Ua(e2, s2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : Ua(e2, s2, n2, t2._getUIString("ScaleControl.Meters"));
        }
        function Ua(t2, e2, i2, s2) {
          const a2 = function(t3) {
            const e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
            let i3 = t3 / e3;
            return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
              const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
              return Math.round(t4 * e4) / e4;
            }(i3), e3 * i3;
          }(i2);
          t2.style.width = e2 * (a2 / i2) + "px", t2.innerHTML = `${a2}&nbsp;${s2}`;
        }
        const Za = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false }, Ga = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function qa(t2) {
          if (t2) {
            if ("number" == typeof t2) {
              const i2 = Math.round(Math.abs(t2) / Math.SQRT2);
              return { center: new e.P(0, 0), top: new e.P(0, t2), "top-left": new e.P(i2, i2), "top-right": new e.P(-i2, i2), bottom: new e.P(0, -t2), "bottom-left": new e.P(i2, -i2), "bottom-right": new e.P(-i2, -i2), left: new e.P(t2, 0), right: new e.P(-t2, 0) };
            }
            if (t2 instanceof e.P || Array.isArray(t2)) {
              const i2 = e.P.convert(t2);
              return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
            }
            return { center: e.P.convert(t2.center || [0, 0]), top: e.P.convert(t2.top || [0, 0]), "top-left": e.P.convert(t2["top-left"] || [0, 0]), "top-right": e.P.convert(t2["top-right"] || [0, 0]), bottom: e.P.convert(t2.bottom || [0, 0]), "bottom-left": e.P.convert(t2["bottom-left"] || [0, 0]), "bottom-right": e.P.convert(t2["bottom-right"] || [0, 0]), left: e.P.convert(t2.left || [0, 0]), right: e.P.convert(t2.right || [0, 0]) };
          }
          return qa(new e.P(0, 0));
        }
        const ja = i;
        t.AJAXError = e.be, t.Evented = e.E, t.LngLat = e.M, t.MercatorCoordinate = e.Y, t.Point = e.P, t.addProtocol = e.bf, t.config = e.a, t.removeProtocol = e.bg, t.AttributionControl = ma, t.BoxZoomHandler = zs, t.CanvasSource = Q, t.CooperativeGesturesHandler = la, t.DoubleClickZoomHandler = ia, t.DragPanHandler = oa, t.DragRotateHandler = ra, t.EdgeInsets = us, t.FullscreenControl = class extends e.E {
          constructor(t2 = {}) {
            super(), this._onFullscreenChange = () => {
              var t3;
              let e2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; null === (t3 = null == e2 ? void 0 : e2.shadowRoot) || void 0 === t3 ? void 0 : t3.fullscreenElement; )
                e2 = e2.shadowRoot.fullscreenElement;
              e2 === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(t2) {
            return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            r.create("span", "maplibregl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const t2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new e.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new e.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, t.GeoJSONSource = X, t.GeolocateControl = class extends e.E {
          constructor(t2) {
            super(), this._onSuccess = (t3) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t3))
                  return this._setErrorState(), this.fire(new e.k("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = t3, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new e.k("geolocate", t3)), this._finish();
              }
            }, this._updateCamera = (t3) => {
              const i2 = new e.M(t3.coords.longitude, t3.coords.latitude), s2 = t3.coords.accuracy, a2 = this._map.getBearing(), o2 = e.e({ bearing: a2 }, this.options.fitBoundsOptions), r2 = j.fromLngLat(i2, s2);
              this._map.fitBounds(r2, o2, { geolocateSource: true });
            }, this._updateMarker = (t3) => {
              if (t3) {
                const i2 = new e.M(t3.coords.longitude, t3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (t3) => {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === t3.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === t3.code && Ba)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new e.k("error", t3)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = (t3) => {
              if (this._map) {
                if (this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t3) {
                  e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                } else {
                  const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new La({ element: this._dotElement }), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new La({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                  t4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t4.originalEvent && "resize" === t4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new e.k("trackuserlocationend")));
                });
              }
            }, this.options = e.e({}, ka, t2);
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function() {
              return e._(this, arguments, void 0, function* (t3 = false) {
                if (void 0 !== za && !t3)
                  return za;
                if (void 0 === window.navigator.permissions)
                  return za = !!window.navigator.geolocation, za;
                try {
                  const t4 = yield window.navigator.permissions.query({ name: "geolocation" });
                  za = "denied" !== t4.state;
                } catch (t4) {
                  za = !!window.navigator.geolocation;
                }
                return za;
              });
            }().then((t3) => this._setupUI(t3)), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fa = 0, Ba = false;
          }
          _isOutOfMapMaxBounds(t2) {
            const e2 = this._map.getMaxBounds(), i2 = t2.coords;
            return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const t2 = this._map.getBounds(), e2 = t2.getSouthEast(), i2 = t2.getNorthEast(), s2 = e2.distanceTo(i2), a2 = Math.ceil(this._accuracy / (s2 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
          }
          trigger() {
            if (!this._setup)
              return e.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Fa--, Ba = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new e.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.k("trackuserlocationstart"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t2;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Fa++, Fa > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, Ba = true) : (t2 = this.options.positionOptions, Ba = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
              }
            } else
              window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, t.Hash = ms, t.ImageSource = Y, t.KeyboardHandler = Js, t.LngLatBounds = j, t.LogoControl = fa, t.Map = class extends _a {
          constructor(t2) {
            if (e.bc.mark(e.bd.create), null != (t2 = e.e({}, Ca, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t2.minPitch && t2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != t2.maxPitch && t2.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (super(new _s(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), { bearingSnap: t2.bearingSnap }), this._contextLost = (t3) => {
              t3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new e.k("webglcontextlost", { originalEvent: t3 }));
            }, this._contextRestored = (t3) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new e.k("webglcontextrestored", { originalEvent: t3 }));
            }, this._onMapScroll = (t3) => {
              if (t3.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = t2.interactive, this._maxTileCacheSize = t2.maxTileCacheSize, this._maxTileCacheZoomLevels = t2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._crossSourceCollisions = t2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t2.collectResourceTiming, this._renderTaskQueue = new ga(), this._controls = [], this._mapId = e.a3(), this._locale = e.e({}, Ia, t2.locale), this._clickTolerance = t2.clickTolerance, this._overridePixelRatio = t2.pixelRatio, this._maxCanvasSize = t2.maxCanvasSize, this.transformCameraUpdate = t2.transformCameraUpdate, this._imageQueueHandle = _.addThrottleControl(() => this.isMoving()), this._requestManager = new p(t2.transformRequest), "string" == typeof t2.container) {
              if (this._container = document.getElementById(t2.container), !this._container)
                throw new Error(`Container '${t2.container}' not found.`);
            } else {
              if (!(t2.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t2.container;
            }
            if (t2.maxBounds && this.setMaxBounds(t2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }), this.once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let t3 = false;
              const e2 = ps((t4) => {
                this._trackResize && !this._removed && this.resize(t4)._update();
              }, 50);
              this._resizeObserver = new ResizeObserver((i2) => {
                t3 ? e2(i2) : t3 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new da(this, t2), this._hash = t2.hash && new ms("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.e({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t2.localIdeographFontFamily, this._validateStyle = t2.validateStyle, t2.style && this.setStyle(t2.style, { localIdeographFontFamily: t2.localIdeographFontFamily }), t2.attributionControl && this.addControl(new ma("boolean" == typeof t2.attributionControl ? void 0 : t2.attributionControl)), t2.maplibreLogo && this.addControl(new fa(), t2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t3) => {
              this._update("style" === t3.dataType), this.fire(new e.k(`${t3.dataType}data`, t3));
            }), this.on("dataloading", (t3) => {
              this.fire(new e.k(`${t3.dataType}dataloading`, t3));
            }), this.on("dataabort", (t3) => {
              this.fire(new e.k("sourcedataabort", t3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t2, i2) {
            if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
              return this.fire(new e.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s2 = t2.onAdd(this);
            this._controls.push(t2);
            const a2 = this._controlPositions[i2];
            return -1 !== i2.indexOf("bottom") ? a2.insertBefore(s2, a2.firstChild) : a2.appendChild(s2), this;
          }
          removeControl(t2) {
            if (!t2 || !t2.onRemove)
              return this.fire(new e.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i2 = this._controls.indexOf(t2);
            return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
          }
          hasControl(t2) {
            return this._controls.indexOf(t2) > -1;
          }
          calculateCameraOptionsFromTo(t2, e2, i2, s2) {
            return null == s2 && this.terrain && (s2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t2, e2, i2, s2);
          }
          resize(t2) {
            var i2;
            const s2 = this._containerDimensions(), a2 = s2[0], o2 = s2[1], r2 = this._getClampedPixelRatio(a2, o2);
            if (this._resizeCanvas(a2, o2, r2), this.painter.resize(a2, o2, r2), this.painter.overLimit()) {
              const t3 = this.painter.context.gl;
              this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
              const e2 = this._getClampedPixelRatio(a2, o2);
              this._resizeCanvas(a2, o2, e2), this.painter.resize(a2, o2, e2);
            }
            this.transform.resize(a2, o2), null === (i2 = this._requestedCameraState) || void 0 === i2 || i2.resize(a2, o2);
            const n2 = !this._moving;
            return n2 && (this.stop(), this.fire(new e.k("movestart", t2)).fire(new e.k("move", t2))), this.fire(new e.k("resize", t2)), n2 && this.fire(new e.k("moveend", t2)), this;
          }
          _getClampedPixelRatio(t2, e2) {
            const { 0: i2, 1: s2 } = this._maxCanvasSize, a2 = this.getPixelRatio(), o2 = t2 * a2, r2 = e2 * a2;
            return Math.min(o2 > i2 ? i2 / o2 : 1, r2 > s2 ? s2 / r2 : 1) * a2;
          }
          getPixelRatio() {
            var t2;
            return null !== (t2 = this._overridePixelRatio) && void 0 !== t2 ? t2 : devicePixelRatio;
          }
          setPixelRatio(t2) {
            this._overridePixelRatio = t2, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t2) {
            return this.transform.setMaxBounds(j.convert(t2)), this._update();
          }
          setMinZoom(t2) {
            if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
              return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t2) {
            if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
              return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t2) {
            if ((t2 = null == t2 ? 0 : t2) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t2 >= 0 && t2 <= this.transform.maxPitch)
              return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t2) {
            if ((t2 = null == t2 ? 60 : t2) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t2 >= this.transform.minPitch)
              return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t2) {
            return this.transform.renderWorldCopies = t2, this._update();
          }
          project(t2) {
            return this.transform.locationPoint(e.M.convert(t2), this.style && this.terrain);
          }
          unproject(t2) {
            return this.transform.pointLocation(e.P.convert(t2), this.terrain);
          }
          isMoving() {
            var t2;
            return this._moving || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isMoving());
          }
          isZooming() {
            var t2;
            return this._zooming || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isZooming());
          }
          isRotating() {
            var t2;
            return this._rotating || (null === (t2 = this.handlers) || void 0 === t2 ? void 0 : t2.isRotating());
          }
          _createDelegatedListener(t2, e2, i2) {
            if ("mouseenter" === t2 || "mouseover" === t2) {
              let s2 = false;
              const a2 = (a3) => {
                const o2 = this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : [];
                o2.length ? s2 || (s2 = true, i2.call(this, new Is(t2, this, a3.originalEvent, { features: o2 }))) : s2 = false;
              };
              return { layer: e2, listener: i2, delegates: { mousemove: a2, mouseout: () => {
                s2 = false;
              } } };
            }
            if ("mouseleave" === t2 || "mouseout" === t2) {
              let s2 = false;
              const a2 = (a3) => {
                (this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : []).length ? s2 = true : s2 && (s2 = false, i2.call(this, new Is(t2, this, a3.originalEvent)));
              }, o2 = (e3) => {
                s2 && (s2 = false, i2.call(this, new Is(t2, this, e3.originalEvent)));
              };
              return { layer: e2, listener: i2, delegates: { mousemove: a2, mouseout: o2 } };
            }
            {
              const s2 = (t3) => {
                const s3 = this.getLayer(e2) ? this.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                s3.length && (t3.features = s3, i2.call(this, t3), delete t3.features);
              };
              return { layer: e2, listener: i2, delegates: { [t2]: s2 } };
            }
          }
          on(t2, e2, i2) {
            if (void 0 === i2)
              return super.on(t2, e2);
            const s2 = this._createDelegatedListener(t2, e2, i2);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(s2);
            for (const t3 in s2.delegates)
              this.on(t3, s2.delegates[t3]);
            return this;
          }
          once(t2, e2, i2) {
            if (void 0 === i2)
              return super.once(t2, e2);
            const s2 = this._createDelegatedListener(t2, e2, i2);
            for (const t3 in s2.delegates)
              this.once(t3, s2.delegates[t3]);
            return this;
          }
          off(t2, e2, i2) {
            return void 0 === i2 ? super.off(t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && ((s2) => {
              const a2 = this._delegatedListeners[t2];
              for (let t3 = 0; t3 < a2.length; t3++) {
                const s3 = a2[t3];
                if (s3.layer === e2 && s3.listener === i2) {
                  for (const t4 in s3.delegates)
                    this.off(t4, s3.delegates[t4]);
                  return a2.splice(t3, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(t2, i2) {
            if (!this.style)
              return [];
            let s2;
            const a2 = t2 instanceof e.P || Array.isArray(t2), o2 = a2 ? t2 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i2 = i2 || (a2 ? {} : t2) || {}, o2 instanceof e.P || "number" == typeof o2[0])
              s2 = [e.P.convert(o2)];
            else {
              const t3 = e.P.convert(o2[0]), i3 = e.P.convert(o2[1]);
              s2 = [t3, new e.P(i3.x, t3.y), i3, new e.P(t3.x, i3.y), t3];
            }
            return this.style.queryRenderedFeatures(s2, i2, this.transform);
          }
          querySourceFeatures(t2, e2) {
            return this.style.querySourceFeatures(t2, e2);
          }
          setStyle(t2, i2) {
            return false !== (i2 = e.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(t2, i2));
          }
          setTransformRequest(t2) {
            return this._requestManager.setTransformRequest(t2), this;
          }
          _getUIString(t2) {
            const e2 = this._locale[t2];
            if (null == e2)
              throw new Error(`Missing UI string '${t2}'`);
            return e2;
          }
          _updateStyle(t2, e2) {
            if (e2.transformStyle && this.style && !this.style._loaded)
              return void this.style.once("style.load", () => this._updateStyle(t2, e2));
            const i2 = this.style && e2.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!t2)), t2 ? (this.style = new he(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2, e2, i2) : this.style.loadJSON(t2, e2, i2), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new he(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t2, i2) {
            if ("string" == typeof t2) {
              const s2 = this._requestManager.transformRequest(t2, "Style");
              e.h(s2, new AbortController()).then((t3) => {
                this._updateDiff(t3.data, i2);
              }).catch((t3) => {
                t3 && this.fire(new e.j(t3));
              });
            } else
              "object" == typeof t2 && this._updateDiff(t2, i2);
          }
          _updateDiff(t2, i2) {
            try {
              this.style.setState(t2, i2) && this._update(true);
            } catch (s2) {
              e.w(`Unable to perform style diff: ${s2.message || s2.error || s2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : e.w("There is no style added to the map.");
          }
          addSource(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
          }
          isSourceLoaded(t2) {
            const i2 = this.style && this.style.sourceCaches[t2];
            if (void 0 !== i2)
              return i2.loaded();
            this.fire(new e.j(new Error(`There is no source with ID '${t2}'`)));
          }
          setTerrain(t2) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t2) {
              const i2 = this.style.sourceCaches[t2.source];
              if (!i2)
                throw new Error(`cannot load terrain, because there exists no source with ID: ${t2.source}`);
              null === this.terrain && i2.reload();
              for (const i3 in this.style._layers) {
                const s2 = this.style._layers[i3];
                "hillshade" === s2.type && s2.source === t2.source && e.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new ya(this.painter, i2, t2), this.painter.renderToTexture = new Ta(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (e2) => {
                "style" === e2.dataType ? this.terrain.sourceCache.freeRtt() : "source" === e2.dataType && e2.tile && (e2.sourceId !== t2.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e2.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else
              this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new e.k("terrain", { terrain: t2 })), this;
          }
          getTerrain() {
            var t2, e2;
            return null !== (e2 = null === (t2 = this.terrain) || void 0 === t2 ? void 0 : t2.options) && void 0 !== e2 ? e2 : null;
          }
          areTilesLoaded() {
            const t2 = this.style && this.style.sourceCaches;
            for (const e2 in t2) {
              const i2 = t2[e2]._tiles;
              for (const t3 in i2) {
                const e3 = i2[t3];
                if ("loaded" !== e3.state && "errored" !== e3.state)
                  return false;
              }
            }
            return true;
          }
          removeSource(t2) {
            return this.style.removeSource(t2), this._update(true);
          }
          getSource(t2) {
            return this.style.getSource(t2);
          }
          addImage(t2, i2, s2 = {}) {
            const { pixelRatio: a2 = 1, sdf: r2 = false, stretchX: n2, stretchY: l2, content: h2 } = s2;
            if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || e.b(i2))) {
              if (void 0 === i2.width || void 0 === i2.height)
                return this.fire(new e.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: s3, height: o2, data: c2 } = i2, u2 = i2;
                return this.style.addImage(t2, { data: new e.R({ width: s3, height: o2 }, new Uint8Array(c2)), pixelRatio: a2, stretchX: n2, stretchY: l2, content: h2, sdf: r2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, t2), this;
              }
            }
            {
              const { width: s3, height: c2, data: u2 } = o.getImageData(i2);
              this.style.addImage(t2, { data: new e.R({ width: s3, height: c2 }, u2), pixelRatio: a2, stretchX: n2, stretchY: l2, content: h2, sdf: r2, version: 0 });
            }
          }
          updateImage(t2, i2) {
            const s2 = this.style.getImage(t2);
            if (!s2)
              return this.fire(new e.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a2 = i2 instanceof HTMLImageElement || e.b(i2) ? o.getImageData(i2) : i2, { width: r2, height: n2, data: l2 } = a2;
            if (void 0 === r2 || void 0 === n2)
              return this.fire(new e.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (r2 !== s2.data.width || n2 !== s2.data.height)
              return this.fire(new e.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const h2 = !(i2 instanceof HTMLImageElement || e.b(i2));
            return s2.data.replace(l2, h2), this.style.updateImage(t2, s2), this;
          }
          getImage(t2) {
            return this.style.getImage(t2);
          }
          hasImage(t2) {
            return t2 ? !!this.style.getImage(t2) : (this.fire(new e.j(new Error("Missing required image id"))), false);
          }
          removeImage(t2) {
            this.style.removeImage(t2);
          }
          loadImage(t2) {
            return _.getImage(this._requestManager.transformRequest(t2, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t2, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
          }
          moveLayer(t2, e2) {
            return this.style.moveLayer(t2, e2), this._update(true);
          }
          removeLayer(t2) {
            return this.style.removeLayer(t2), this._update(true);
          }
          getLayer(t2) {
            return this.style.getLayer(t2);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t2, e2, i2) {
            return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
          }
          setFilter(t2, e2, i2 = {}) {
            return this.style.setFilter(t2, e2, i2), this._update(true);
          }
          getFilter(t2) {
            return this.style.getFilter(t2);
          }
          setPaintProperty(t2, e2, i2, s2 = {}) {
            return this.style.setPaintProperty(t2, e2, i2, s2), this._update(true);
          }
          getPaintProperty(t2, e2) {
            return this.style.getPaintProperty(t2, e2);
          }
          setLayoutProperty(t2, e2, i2, s2 = {}) {
            return this.style.setLayoutProperty(t2, e2, i2, s2), this._update(true);
          }
          getLayoutProperty(t2, e2) {
            return this.style.getLayoutProperty(t2, e2);
          }
          setGlyphs(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(t2, e2), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t2, e2, i2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(t2, e2, i2, (t3) => {
              t3 || this._update(true);
            }), this;
          }
          removeSprite(t2) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(t2), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(t2, e2, (t3) => {
              t3 || this._update(true);
            }), this;
          }
          setLight(t2, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t2, e2) {
            return this.style.setFeatureState(t2, e2), this._update();
          }
          removeFeatureState(t2, e2) {
            return this.style.removeFeatureState(t2, e2), this._update();
          }
          getFeatureState(t2) {
            return this.style.getFeatureState(t2);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t2 = 0, e2 = 0;
            return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
          }
          _setupContainer() {
            const t2 = this._container;
            t2.classList.add("maplibregl-map");
            const e2 = this._canvasContainer = r.create("div", "maplibregl-canvas-container", t2);
            this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            const i2 = this._containerDimensions(), s2 = this._getClampedPixelRatio(i2[0], i2[1]);
            this._resizeCanvas(i2[0], i2[1], s2);
            const a2 = this._controlContainer = r.create("div", "maplibregl-control-container", t2), o2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
              o2[t3] = r.create("div", `maplibregl-ctrl-${t3} `, a2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t2, e2, i2) {
            this._canvas.width = Math.floor(i2 * t2), this._canvas.height = Math.floor(i2 * e2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e2}px`;
          }
          _setupPainter() {
            const t2 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
            let e2 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
              e2 = { requestedAttributes: t2 }, i3 && (e2.statusMessage = i3.statusMessage, e2.type = i3.type);
            }, { once: true });
            const i2 = this._canvas.getContext("webgl2", t2) || this._canvas.getContext("webgl", t2);
            if (!i2) {
              const t3 = "Failed to initialize WebGL";
              throw e2 ? (e2.message = t3, new Error(JSON.stringify(e2))) : new Error(t3);
            }
            this.painter = new ls(i2, this.transform), n.testSupport(i2);
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t2) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t2) {
            return this._update(), this._renderTaskQueue.add(t2);
          }
          _cancelRenderFrame(t2) {
            this._renderTaskQueue.remove(t2);
          }
          _render(t2) {
            const i2 = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t2), this._removed)
              return;
            let s2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t3 = this.transform.zoom, a3 = o.now();
              this.style.zoomHistory.update(t3, a3);
              const r2 = new e.a8(t3, { now: a3, fadeDuration: i2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n2 = r2.crossFadingFactor();
              1 === n2 && n2 === this._crossFadingFactor || (s2 = true, this._crossFadingFactor = n2), this.style.update(r2);
            }
            this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i2, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i2, showPadding: this.showPadding }), this.fire(new e.k("render")), this.loaded() && !this._loaded && (this._loaded = true, e.bc.mark(e.bd.load), this.fire(new e.k("load"))), this.style && (this.style.hasTransitions() || s2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return a2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new e.k("idle")), !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, e.bc.mark(e.bd.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var t2;
            this._hash && this._hash.remove();
            for (const t3 of this._controls)
              t3.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), _.removeThrottleControl(this._imageQueueHandle), null === (t2 = this._resizeObserver) || void 0 === t2 || t2.disconnect();
            const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            i2 && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), e.bc.clearMetrics(), this._removed = true, this.fire(new e.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), o.frameAsync(this._frameRequest).then((t2) => {
              e.bc.frame(t2), this._frameRequest = null, this._render(t2);
            }).catch(() => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t2) {
            this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t2) {
            this._showPadding !== t2 && (this._showPadding = t2, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t2) {
            this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t2) {
            this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t2) {
            this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t2) {
            this._vertices = t2, this._update();
          }
          get version() {
            return Ea;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        }, t.MapMouseEvent = Is, t.MapTouchEvent = Es, t.MapWheelEvent = Cs, t.Marker = La, t.NavigationControl = class {
          constructor(t2) {
            this._updateZoomButtons = () => {
              const t3 = this._map.getZoom(), e2 = t3 === this._map.getMaxZoom(), i2 = t3 === this._map.getMinZoom();
              this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }, this._rotateCompassArrow = () => {
              const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t3;
            }, this._setButtonTitle = (t3, e2) => {
              const i2 = this._map._getUIString(`NavigationControl.${e2}`);
              t3.title = i2, t3.setAttribute("aria-label", i2);
            }, this.options = e.e({}, Pa, t2), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
            }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(t2) {
            return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Da(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t2, e2) {
            const i2 = r.create("button", t2, this._container);
            return i2.type = "button", i2.addEventListener("click", e2), i2;
          }
        }, t.Popup = class extends e.E {
          constructor(t2) {
            super(), this.remove = () => (this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new e.k("close"))), this), this._onMouseUp = (t3) => {
              this._update(t3.point);
            }, this._onMouseMove = (t3) => {
              this._update(t3.point);
            }, this._onDrag = (t3) => {
              this._update(t3.point);
            }, this._update = (t3) => {
              var e2;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (!this._container) {
                if (this._container = r.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const t4 of this.options.className.split(" "))
                    this._container.classList.add(t4);
                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Ma(this._lngLat, this._flatPos, this._map.transform) : null === (e2 = this._lngLat) || void 0 === e2 ? void 0 : e2.wrap(), this._trackPointer && !t3)
                return;
              const i2 = this._flatPos = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t3 ? t3 : this._map.transform.locationPoint(this._lngLat));
              let s2 = this.options.anchor;
              const a2 = qa(this.options.offset);
              if (!s2) {
                const t4 = this._container.offsetWidth, e3 = this._container.offsetHeight;
                let o3;
                o3 = i2.y + a2.bottom.y < e3 ? ["top"] : i2.y > this._map.transform.height - e3 ? ["bottom"] : [], i2.x < t4 / 2 ? o3.push("left") : i2.x > this._map.transform.width - t4 / 2 && o3.push("right"), s2 = 0 === o3.length ? "bottom" : o3.join("-");
              }
              let o2 = i2.add(a2[s2]);
              this.options.subpixelPositioning || (o2 = o2.round()), r.setTransform(this._container, `${Aa[s2]} translate(${o2.x}px,${o2.y}px)`), Ra(this._container, s2, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = e.e(Object.create(Za), t2);
          }
          addTo(t2) {
            return this._map && this.remove(), this._map = t2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t2) {
            return this._lngLat = e.M.convert(t2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t2) {
            return this.setDOMContent(document.createTextNode(t2));
          }
          setHTML(t2) {
            const e2 = document.createDocumentFragment(), i2 = document.createElement("body");
            let s2;
            for (i2.innerHTML = t2; s2 = i2.firstChild, s2; )
              e2.appendChild(s2);
            return this.setDOMContent(e2);
          }
          getMaxWidth() {
            var t2;
            return null === (t2 = this._container) || void 0 === t2 ? void 0 : t2.style.maxWidth;
          }
          setMaxWidth(t2) {
            return this.options.maxWidth = t2, this._update(), this;
          }
          setDOMContent(t2) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = r.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t2) {
            this._container && this._container.classList.add(t2);
          }
          removeClassName(t2) {
            this._container && this._container.classList.remove(t2);
          }
          setOffset(t2) {
            return this.options.offset = t2, this._update(), this;
          }
          toggleClassName(t2) {
            if (this._container)
              return this._container.classList.toggle(t2);
          }
          setSubpixelPositioning(t2) {
            this.options.subpixelPositioning = t2;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const t2 = this._container.querySelector(Ga);
            t2 && t2.focus();
          }
        }, t.RasterDEMTileSource = $, t.RasterTileSource = W, t.ScaleControl = class {
          constructor(t2) {
            this._onMove = () => {
              Na(this._map, this._container, this.options);
            }, this.setUnit = (t3) => {
              this.options.unit = t3, Na(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Oa), t2);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, t.ScrollZoomHandler = ea, t.Style = he, t.TerrainControl = class {
          constructor(t2) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = t2;
          }
          onAdd(t2) {
            return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, t.TwoFingersTouchPitchHandler = Ks, t.TwoFingersTouchRotateHandler = $s, t.TwoFingersTouchZoomHandler = Hs, t.TwoFingersTouchZoomRotateHandler = na, t.VectorTileSource = H, t.VideoSource = J, t.addSourceType = (t2, i2) => e._(void 0, void 0, void 0, function* () {
          if (et(t2))
            throw new Error(`A source type called "${t2}" already exists.`);
          ((t3, e2) => {
            tt[t3] = e2;
          })(t2, i2);
        }), t.clearPrewarmedResources = function() {
          const t2 = k;
          t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(A), k = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t.getMaxParallelImageRequests = function() {
          return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, t.getRTLTextPluginStatus = function() {
          return ot().getRTLTextPluginStatus();
        }, t.getVersion = function() {
          return ja;
        }, t.getWorkerCount = function() {
          return R.workerCount;
        }, t.getWorkerUrl = function() {
          return e.a.WORKER_URL;
        }, t.importScriptInWorkers = function(t2) {
          return N().broadcast("IS", t2);
        }, t.prewarm = function() {
          B().acquire(A);
        }, t.setMaxParallelImageRequests = function(t2) {
          e.a.MAX_PARALLEL_IMAGE_REQUESTS = t2;
        }, t.setRTLTextPlugin = function(t2, e2) {
          return ot().setRTLTextPlugin(t2, e2);
        }, t.setWorkerCount = function(t2) {
          R.workerCount = t2;
        }, t.setWorkerUrl = function(t2) {
          e.a.WORKER_URL = t2;
        };
      });
      var maplibregl$1 = maplibregl;
      return maplibregl$1;
    });
  }
});
export default require_maplibre_gl();
/*! Bundled license information:

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.1.3/LICENSE.txt
   *)
*/
//# sourceMappingURL=maplibre-gl.js.map
